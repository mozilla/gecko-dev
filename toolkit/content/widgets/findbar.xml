<?xml version="1.0"?>

<!-- This Source Code Form is subject to the terms of the Mozilla Public
   - License, v. 2.0. If a copy of the MPL was not distributed with this
   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->

<!DOCTYPE bindings [
<!ENTITY % findBarDTD SYSTEM "chrome://global/locale/findbar.dtd" >
%findBarDTD;
]>

<bindings id="findbarBindings"
   xmlns="http://www.mozilla.org/xbl"
   xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
   xmlns:xbl="http://www.mozilla.org/xbl">

  <!-- Private binding -->
  <binding id="findbar-textbox"
           extends="chrome://global/content/bindings/textbox.xml#textbox">
    <implementation>

      <field name="_findbar">null</field>
      <property name="findbar" readonly="true">
        <getter>
          return this._findbar ?
                 this._findbar : this._findbar = document.getBindingParent(this);
        </getter>
      </property>

      <method name="_handleEnter">
        <parameter name="aEvent"/>
        <body><![CDATA[
          if (this.findbar._findMode == this.findbar.FIND_NORMAL) {
            let findString = this.findbar._findField;
            if (!findString.value)
              return;
#ifdef XP_MACOSX
            if (aEvent.metaKey) {
#else
            if (aEvent.ctrlKey) {
#endif
              this.findbar.getElement("highlight").click();
              return;
            }

            this.findbar.onFindAgainCommand(aEvent.shiftKey);
          } else {
            this.findbar._finishFAYT(aEvent);
          }
        ]]></body>
      </method>

      <method name="_handleTab">
        <parameter name="aEvent"/>
        <body><![CDATA[
          let shouldHandle = !aEvent.altKey && !aEvent.ctrlKey &&
                             !aEvent.metaKey;
          if (shouldHandle &&
              this.findbar._findMode != this.findbar.FIND_NORMAL) {

            this.findbar._finishFAYT(aEvent);
          }
        ]]></body>
      </method>
    </implementation>

    <handlers>
      <handler event="input"><![CDATA[
        // We should do nothing during composition.  E.g., composing string
        // before converting may matches a forward word of expected word.
        // After that, even if user converts the composition string to the
        // expected word, it may find second or later searching word in the
        // document.
        if (this.findbar._isIMEComposing) {
          return;
        }
        this.findbar._find(this.value);
      ]]></handler>

      <handler event="keypress"><![CDATA[
        let shouldHandle = !event.altKey && !event.ctrlKey &&
                           !event.metaKey && !event.shiftKey;

        switch (event.keyCode) {
          case KeyEvent.DOM_VK_RETURN:
            this._handleEnter(event);
            break;
          case KeyEvent.DOM_VK_TAB:
            this._handleTab(event);
            break;
          case KeyEvent.DOM_VK_PAGE_UP:
          case KeyEvent.DOM_VK_PAGE_DOWN:
            if (shouldHandle) {
              this.findbar.browser.finder.keyPress(event);
              event.preventDefault();
            }
            break;
          case KeyEvent.DOM_VK_UP:
          case KeyEvent.DOM_VK_DOWN:
            this.findbar.browser.finder.keyPress(event);
            event.preventDefault();
            break;
        }
      ]]></handler>

      <handler event="blur"><![CDATA[
        let findbar = this.findbar;
        // Note: This code used to remove the selection
        // if it matched an editable.
        findbar.browser.finder.enableSelection();
      ]]></handler>

      <handler event="compositionstart"><![CDATA[
        // Don't close the find toolbar while IME is composing.
        let findbar = this.findbar;
        findbar._isIMEComposing = true;
        if (findbar._quickFindTimeout) {
          clearTimeout(findbar._quickFindTimeout);
          findbar._quickFindTimeout = null;
        }
      ]]></handler>

      <handler event="compositionend"><![CDATA[
        let findbar = this.findbar;
        findbar._isIMEComposing = false;
        if (findbar._findMode != findbar.FIND_NORMAL &&
            !findbar.hidden)
          findbar._setFindCloseTimeout();
      ]]></handler>

      <handler event="dragover"><![CDATA[
        if (event.dataTransfer.types.contains("text/plain"))
          event.preventDefault();
      ]]></handler>

      <handler event="drop"><![CDATA[
        let value = event.dataTransfer.getData("text/plain");
        this.value = value;
        this.findbar._find(value);
        event.stopPropagation();
        event.preventDefault();
      ]]></handler>
    </handlers>
  </binding>

  <binding id="findbar"
           extends="chrome://global/content/bindings/toolbar.xml#toolbar">
    <resources>
      <stylesheet src="chrome://global/skin/findBar.css"/>
    </resources>

    <content hidden="true">
    <xul:hbox anonid="findbar-container" class="findbar-container" flex="1" align="center">
      <xul:hbox anonid="findbar-textbox-wrapper" align="stretch">
        <xul:textbox anonid="findbar-textbox"
                     class="findbar-textbox findbar-find-fast"
                     xbl:inherits="flash"/>
        <xul:toolbarbutton anonid="find-previous"
                           class="findbar-find-previous tabbable"
                           tooltiptext="&previous.tooltip;"
                           oncommand="onFindAgainCommand(true);"
                           disabled="true"
                           xbl:inherits="accesskey=findpreviousaccesskey"/>
        <xul:toolbarbutton anonid="find-next"
                           class="findbar-find-next tabbable"
                           tooltiptext="&next.tooltip;"
                           oncommand="onFindAgainCommand(false);"
                           disabled="true"
                           xbl:inherits="accesskey=findnextaccesskey"/>
      </xul:hbox>
      <xul:image anonid="find-status-icon" class="findbar-find-fast find-status-icon"/>
      <xul:description anonid="find-status"
                       control="findbar-textbox"
                       class="findbar-find-fast findbar-find-status">
      <!-- Do not use value, first child is used because it provides a11y with text change events -->
      </xul:description>
      <xul:spacer flex="1"/>
      <xul:toolbarbutton anonid="highlight"
                         class="findbar-highlight tabbable"
                         label="&highlightAll.label;"
                         accesskey="&highlightAll.accesskey;"
                         tooltiptext="&highlightAll.tooltiptext;"
                         oncommand="toggleHighlight(this.checked);"
                         type="checkbox"
                         xbl:inherits="accesskey=highlightaccesskey"/>
      <xul:toolbarbutton anonid="find-case-sensitive"
                         class="findbar-case-sensitive tabbable"
                         label="&caseSensitive.label;"
                         accesskey="&caseSensitive.accesskey;"
                         tooltiptext="&caseSensitive.tooltiptext;"
                         oncommand="_setCaseSensitivity(this.checked);"
                         type="checkbox"
                         xbl:inherits="accesskey=matchcaseaccesskey"/>
      <xul:label anonid="match-case-status" class="findbar-find-fast"/>
    </xul:hbox>
    <xul:toolbarbutton anonid="find-closebutton"
                       class="findbar-closebutton close-icon"
                       tooltiptext="&findCloseButton.tooltip;"
                       oncommand="close();"/>
    </content>

    <implementation implements="nsIDOMEventListener, nsIEditActionListener">
      <field name="FIND_NORMAL">0</field>
      <field name="FIND_TYPEAHEAD">1</field>
      <field name="FIND_LINKS">2</field>

      <field name="_findMode">0</field>

      <field name="_flashFindBar">0</field>
      <field name="_initialFlashFindBarCount">6</field>

      <property name="prefillWithSelection"
                onget="return this.getAttribute('prefillwithselection') != 'false'"
                onset="this.setAttribute('prefillwithselection', val); return val;"/>
      <field name="_selectionMaxLen">150</field>

      <method name="getElement">
        <parameter name="aAnonymousID"/>
        <body><![CDATA[
          return document.getAnonymousElementByAttribute(this,
                                                         "anonid",
                                                         aAnonymousID)
        ]]></body>
      </method>

      <property name="findMode"
                readonly="true"
                onget="return this._findMode;"/>

      <property name="canClear" readonly="true">
        <getter><![CDATA[
          if (this._findField.value)
            return true;

          // Watch out for lazy editor init
          if (this._findField.editor) {
            let tm = this._findField.editor.transactionManager;
            return !!(tm.numberOfUndoItems || tm.numberOfRedoItems);
          }
          return false;
        ]]></getter>
      </property>

      <field name="_browser">null</field>
      <property name="browser">
        <getter><![CDATA[
          if (!this._browser) {
            this._browser =
              document.getElementById(this.getAttribute("browserid"));
          }
          return this._browser;
        ]]></getter>
        <setter><![CDATA[
          if (this._browser) {
            this._browser.removeEventListener("keypress", this, false);
            this._browser.removeEventListener("mouseup", this, false);
            let finder = this._browser.finder;
            if (finder)
              finder.removeResultListener(this);
          }

          this._browser = val;
          if (this._browser) {
            this._browser.addEventListener("keypress", this, false);
            this._browser.addEventListener("mouseup", this, false);
            this._browser.finder.addResultListener(this);

            this._findField.value = this._browser._lastSearchString;
            this.toggleHighlight(this.browser._lastSearchHighlight);
          }
          return val;
        ]]></setter>
      </property>

      <field name="_observer"><![CDATA[({
        _self: this,

        QueryInterface: function(aIID) {
          if (aIID.equals(Components.interfaces.nsIObserver) ||
              aIID.equals(Components.interfaces.nsISupportsWeakReference) ||
              aIID.equals(Components.interfaces.nsISupports))
            return this;

          throw Components.results.NS_ERROR_NO_INTERFACE;
        },

        observe: function(aSubject, aTopic, aPrefName) {
          if (aTopic != "nsPref:changed")
            return;

          let prefsvc =
            aSubject.QueryInterface(Components.interfaces.nsIPrefBranch);

          switch (aPrefName) {
            case "accessibility.typeaheadfind":
              this._self._useTypeAheadFind = prefsvc.getBoolPref(aPrefName);
              break;
            case "accessibility.typeaheadfind.linksonly":
              this._self._typeAheadLinksOnly = prefsvc.getBoolPref(aPrefName);
              break;
            case "accessibility.typeaheadfind.casesensitive":
              this._self._typeAheadCaseSensitive = prefsvc.getIntPref(aPrefName);
              this._self._updateCaseSensitivity();
              if (this._self.getElement("highlight").checked)
                this._self._setHighlightTimeout();
              break;
          }
        }
      })]]></field>

      <field name="_destroyed">false</field>

      <constructor><![CDATA[
        // These elements are accessed frequently and are therefore cached
        this._findField = this.getElement("findbar-textbox");
        this._findStatusIcon = this.getElement("find-status-icon");
        this._findStatusDesc = this.getElement("find-status");

        this._foundURL = null;

        let prefsvc =
          Components.classes["@mozilla.org/preferences-service;1"]
                    .getService(Components.interfaces.nsIPrefBranch);

        this._quickFindTimeoutLength =
          prefsvc.getIntPref("accessibility.typeaheadfind.timeout");
        this._flashFindBar =
          prefsvc.getIntPref("accessibility.typeaheadfind.flashBar");

        prefsvc.addObserver("accessibility.typeaheadfind",
                            this._observer, false);
        prefsvc.addObserver("accessibility.typeaheadfind.linksonly",
                            this._observer, false);
        prefsvc.addObserver("accessibility.typeaheadfind.casesensitive",
                            this._observer, false);

        this._useTypeAheadFind =
          prefsvc.getBoolPref("accessibility.typeaheadfind");
        this._typeAheadLinksOnly =
          prefsvc.getBoolPref("accessibility.typeaheadfind.linksonly");
        this._typeAheadCaseSensitive =
          prefsvc.getIntPref("accessibility.typeaheadfind.casesensitive");

        // Convenience
        this.nsITypeAheadFind = Components.interfaces.nsITypeAheadFind;
        this.nsISelectionController = Components.interfaces.nsISelectionController;
        this._findSelection = this.nsISelectionController.SELECTION_FIND;

        this._findResetTimeout = -1;

        // Make sure the FAYT keypress listener is attached by initializing the
        // browser property
        if (this.getAttribute("browserid"))
          setTimeout(function(aSelf) { aSelf.browser = aSelf.browser; }, 0, this);
      ]]></constructor>

      <destructor><![CDATA[
        this.destroy();
      ]]></destructor>

      <!-- This is necessary because the destructor isn't called when
           we are removed from a document that is not destroyed. This
           needs to be explicitly called in this case -->
      <method name="destroy">
        <body><![CDATA[
          if (this._destroyed)
            return;
          this._destroyed = true;

          this.browser = null;

          let prefsvc =
            Components.classes["@mozilla.org/preferences-service;1"]
                      .getService(Components.interfaces.nsIPrefBranch);
          prefsvc.removeObserver("accessibility.typeaheadfind",
                                 this._observer);
          prefsvc.removeObserver("accessibility.typeaheadfind.linksonly",
                                 this._observer);
          prefsvc.removeObserver("accessibility.typeaheadfind.casesensitive",
                                 this._observer);

          // Clear all timers that might still be running.
          this._cancelTimers();
        ]]></body>
      </method>

      <method name="_cancelTimers">
        <body><![CDATA[
          if (this._flashFindBarTimeout) {
            clearInterval(this._flashFindBarTimeout);
            this._flashFindBarTimeout = null;
          }
          if (this._quickFindTimeout) {
            clearTimeout(this._quickFindTimeout);
            this._quickFindTimeout = null;
          }
          if (this._highlightTimeout) {
            clearTimeout(this._highlightTimeout);
            this._highlightTimeout = null;
          }
          if (this._findResetTimeout) {
            clearTimeout(this._findResetTimeout);
            this._findResetTimeout = null;
          }
        ]]></body>
      </method>

      <method name="_setFindCloseTimeout">
        <body><![CDATA[
          if (this._quickFindTimeout)
            clearTimeout(this._quickFindTimeout);

          // Don't close the find toolbar while IME is composing.
          if (this._isIMEComposing) {
            this._quickFindTimeout = null;
            return;
          }

          this._quickFindTimeout =
            setTimeout(function(aSelf) {
                         if (aSelf._findMode != aSelf.FIND_NORMAL)
                           aSelf.close();
                       }, this._quickFindTimeoutLength, this);
        ]]></body>
      </method>

      <!--
        - Turns highlight on or off.
        - @param aHighlight (boolean)
        -        Whether to turn the highlight on or off
        -->
      <method name="toggleHighlight">
        <parameter name="aHighlight"/>
        <body><![CDATA[
          if (!this._dispatchFindEvent("highlightallchange"))
            return;

          let word = this._findField.value;
          // Bug 429723. Don't attempt to highlight ""
          if (aHighlight && !word)
            return;

          this.browser._lastSearchHighlight = aHighlight;
          this.browser.finder.highlight(aHighlight, word);
        ]]></body>
      </method>

      <!--
        - Updates the case-sensitivity mode of the findbar and its UI.
        - @param [optional] aString
        -        The string for which case sensitivity might be turned on.
        -        This only used when case-sensitivity is in auto mode,
        -        @see _shouldBeCaseSensitive. The default value for this
        -        parameter is the find-field value.
        -->
      <method name="_updateCaseSensitivity">
        <parameter name="aString"/>
        <body><![CDATA[
          let val = aString || this._findField.value;

          let caseSensitive = this._shouldBeCaseSensitive(val);
          let checkbox = this.getElement("find-case-sensitive");
          let statusLabel = this.getElement("match-case-status");
          checkbox.checked = caseSensitive;

          statusLabel.value = caseSensitive ? this._caseSensitiveStr : "";

          // Show the checkbox on the full Find bar in non-auto mode.
          // Show the label in all other cases.
          let hideCheckbox = this._findMode != this.FIND_NORMAL ||
            (this._typeAheadCaseSensitive != 0 &&
             this._typeAheadCaseSensitive != 1);
          checkbox.hidden = hideCheckbox;
          statusLabel.hidden = !hideCheckbox;

          this.browser.finder.caseSensitive = caseSensitive;
        ]]></body>
      </method>

      <!--
        - Sets the findbar case-sensitivity mode
        - @param aCaseSensitive (boolean)
        -        Whether or not case-sensitivity should be turned on.
        -->
      <method name="_setCaseSensitivity">
        <parameter name="aCaseSensitive"/>
        <body><![CDATA[
          let prefsvc =
            Components.classes["@mozilla.org/preferences-service;1"]
                      .getService(Components.interfaces.nsIPrefBranch);

          // Just set the pref; our observer will change the find bar behavior
          prefsvc.setIntPref("accessibility.typeaheadfind.casesensitive",
                             aCaseSensitive ? 1 : 0);

          this._dispatchFindEvent("casesensitivitychange");
        ]]></body>
      </method>

      <!--
        - Opens and displays the find bar.
        -
        - @param aMode
        -        the find mode to be used, which is either FIND_NORMAL,
        -        FIND_TYPEAHEAD or FIND_LINKS. If not passed, the last
        -        find mode if any or FIND_NORMAL.
        - @returns true if the find bar wasn't previously open, false otherwise.
        -->
      <method name="open">
        <parameter name="aMode"/>
        <body><![CDATA[
          if (aMode != undefined)
            this._findMode = aMode;

          if (!this._notFoundStr) {
            let stringsBundle =
              Components.classes["@mozilla.org/intl/stringbundle;1"]
                        .getService(Components.interfaces.nsIStringBundleService)
                        .createBundle("chrome://global/locale/findbar.properties");
            this._notFoundStr = stringsBundle.GetStringFromName("NotFound");
            this._wrappedToTopStr =
              stringsBundle.GetStringFromName("WrappedToTop");
            this._wrappedToBottomStr =
              stringsBundle.GetStringFromName("WrappedToBottom");
            this._normalFindStr =
              stringsBundle.GetStringFromName("NormalFind");
            this._fastFindStr =
              stringsBundle.GetStringFromName("FastFind");
            this._fastFindLinksStr =
              stringsBundle.GetStringFromName("FastFindLinks");
            this._caseSensitiveStr =
              stringsBundle.GetStringFromName("CaseSensitive");
          }

          this._findFailedString = null;

          this._updateFindUI();
          if (this.hidden) {
            this.hidden = false;

            this._updateStatusUI(this.nsITypeAheadFind.FIND_FOUND);

            let event = document.createEvent("Events");
            event.initEvent("findbaropen", true, false);
            this.dispatchEvent(event);

            return true;
          }
          return false;
        ]]></body>
      </method>

      <!--
        - Closes the findbar.
        -->
      <method name="close">
        <body><![CDATA[
          if (this.hidden)
            return;

          this.hidden = true;

          this.browser.finder.focusContent();
          this.browser.finder.enableSelection();
          this._findField.blur();

          this._cancelTimers();

          this._findFailedString = null;
        ]]></body>
      </method>

      <method name="clear">
        <body><![CDATA[
          this.browser.finder.removeSelection();
          this._findField.reset();
          this.toggleHighlight(false);
          this._updateStatusUI();
          this._enableFindButtons(false);
        ]]></body>
      </method>

      <method name="_dispatchKeypressEvent">
        <parameter name="aTarget"/>
        <parameter name="aEvent"/>
        <body><![CDATA[
          if (!aTarget)
            return;

          let event = document.createEvent("KeyEvents");
          event.initKeyEvent(aEvent.type, aEvent.bubbles, aEvent.cancelable,
                             aEvent.view, aEvent.ctrlKey, aEvent.altKey,
                             aEvent.shiftKey, aEvent.metaKey, aEvent.keyCode,
                             aEvent.charCode);
          aTarget.dispatchEvent(event);
        ]]></body>
      </method>

      <field name="_xulBrowserWindow">null</field>
      <method name="_updateStatusUIBar">
        <parameter name="aFoundURL"/>
        <body><![CDATA[
          if (!this._xulBrowserWindow) {
            try {
              this._xulBrowserWindow =
                window.QueryInterface(Components.interfaces.nsIInterfaceRequestor)
                      .getInterface(Components.interfaces.nsIWebNavigation)
                      .QueryInterface(Components.interfaces.nsIDocShellTreeItem)
                      .treeOwner
                      .QueryInterface(Components.interfaces.nsIInterfaceRequestor)
                      .getInterface(Components.interfaces.nsIXULWindow)
                      .XULBrowserWindow;
            }
            catch(ex) { }
            if (!this._xulBrowserWindow)
              return false;
          }

          // Call this has the same effect like hovering over link,
          // the browser shows the URL as a tooltip.
          this._xulBrowserWindow.setOverLink(aFoundURL || "", null);
          return true;
        ]]></body>
      </method>

      <method name="_finishFAYT">
        <parameter name="aKeypressEvent"/>
        <body><![CDATA[
          this.browser.finder.focusContent();

          if (aKeypressEvent)
            aKeypressEvent.preventDefault();

          this.browser.finder.keyPress(aKeypressEvent);

          this.close();
          return true;
        ]]></body>
      </method>

      <!--
        - Returns true if |aMimeType| is text-based, or false otherwise.
        -
        - @param aMimeType
        -        The MIME type to check.
        -
        - if adding types to this function, please see the similar function
        - in browser/base/content/browser.js
        -->
      <method name="_mimeTypeIsTextBased">
        <parameter name="aMimeType"/>
        <body><![CDATA[
          return /^text\/|\+xml$/.test(aMimeType) ||
                 aMimeType == "application/x-javascript" ||
                 aMimeType == "application/javascript" ||
                 aMimeType == "application/json" ||
                 aMimeType == "application/xml";
        ]]></body>
      </method>

      <!--
        - Returns whether FAYT can be used for the given event in
        - the current content state.
        -->
      <method name="_shouldFastFind">
        <parameter name="aEvent"/>
        <body><![CDATA[
          if (aEvent.ctrlKey || aEvent.altKey || aEvent.metaKey ||
              aEvent.defaultPrevented)
            return false;

          let elt = document.commandDispatcher.focusedElement;
          let win = document.commandDispatcher.focusedWindow;

          // Temporary fix for e10s.
          const XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
          if (elt instanceof XULElement &&
              elt.localName == "browser" &&
              elt.namespaceURI == XUL_NS &&
              elt.getAttribute("remote")) {
            [elt, win] = elt.syncHandler.getFocusedElementAndWindow();
          }

          if (elt) {
            if (elt instanceof HTMLInputElement && elt.mozIsTextField(false))
              return false;

            if (elt instanceof HTMLTextAreaElement ||
                elt instanceof HTMLSelectElement ||
                elt instanceof HTMLObjectElement ||
                elt instanceof HTMLEmbedElement)
              return false;
          }

          if (win && !this._mimeTypeIsTextBased(win.document.contentType))
              return false;

          // disable FAYT in about:blank to prevent FAYT opening unexpectedly.
          let url = this.browser.currentURI;
          if (url.spec == "about:blank")
            return false;

          // disable FAYT in documents that ask for it to be disabled.
          if ((url.schemeIs("about") || url.schemeIs("chrome")) &&
              (win.document.documentElement &&
               win.document.documentElement.getAttribute("disablefastfind") == "true"))
            return false;

          if (win) {
            try {
              let editingSession = win.QueryInterface(Components.interfaces.nsIInterfaceRequestor)
                                   .getInterface(Components.interfaces.nsIWebNavigation)
                                   .QueryInterface(Components.interfaces.nsIInterfaceRequestor)
                                   .getInterface(Components.interfaces.nsIEditingSession);
              if (editingSession.windowIsEditable(win))
                return false;
            }
            catch (e) {
              // If someone built with composer disabled, we can't get an editing session.
            }
         }

          return true;
        ]]></body>
      </method>

      <method name="_shouldBeCaseSensitive">
        <parameter name="aString"/>
        <body><![CDATA[
          if (this._typeAheadCaseSensitive == 0)
            return false;
          if (this._typeAheadCaseSensitive == 1)
            return true;

          return aString != aString.toLowerCase();
        ]]></body>
      </method>

      <method name="_onBrowserKeypress">
        <parameter name="aEvent"/>
        <body><![CDATA[
          const TAF_LINKS_KEY = "'";
          const TAF_TEXT_KEY = "/";

          if (!this._shouldFastFind(aEvent))
            return;

          if (this._findMode != this.FIND_NORMAL && this._quickFindTimeout) {
            if (!aEvent.charCode)
              return;

            this._findField.select();
            this._findField.focus();
            this._dispatchKeypressEvent(this._findField.inputField, aEvent);
            aEvent.preventDefault();
            return;
          }

          let key = aEvent.charCode ? String.fromCharCode(aEvent.charCode) : null;
          let manualstartFAYT = (key == TAF_LINKS_KEY || key == TAF_TEXT_KEY);
          let autostartFAYT = !manualstartFAYT && this._useTypeAheadFind &&
                              key && key != " ";
          if (manualstartFAYT || autostartFAYT) {
            let mode = (key == TAF_LINKS_KEY ||
                        (autostartFAYT && this._typeAheadLinksOnly)) ?
              this.FIND_LINKS : this.FIND_TYPEAHEAD;

            // Clear bar first, so that when openFindBar() calls setCaseSensitivity()
            // it doesn't get confused by a lingering value
            this._findField.value = "";

            this.open(mode);
            this._setFindCloseTimeout();
            this._findField.select();
            this._findField.focus();

            if (autostartFAYT)
              this._dispatchKeypressEvent(this._findField.inputField, aEvent);
            else
              this._updateStatusUI(this.nsITypeAheadFind.FIND_FOUND);

            aEvent.preventDefault();
          }
        ]]></body>
      </method>

      <!-- See nsIDOMEventListener -->
      <method name="handleEvent">
        <parameter name="aEvent"/>
        <body><![CDATA[
          switch (aEvent.type) {
            case "mouseup":
              if (!this.hidden && this._findMode != this.FIND_NORMAL)
                this.close();

              break;
            case "keypress":
              this._onBrowserKeypress(aEvent);
              break;
          }
        ]]></body>
      </method>

      <method name="_enableFindButtons">
        <parameter name="aEnable"/>
        <body><![CDATA[
          this.getElement("find-next").disabled =
            this.getElement("find-previous").disabled = !aEnable;
        ]]></body>
      </method>

      <!--
        - Determines whether minimalist or general-purpose search UI is to be
        - displayed when the find bar is activated.
        -->
      <method name="_updateFindUI">
        <body><![CDATA[
          let showMinimalUI = this._findMode != this.FIND_NORMAL;

          let nodes = this.getElement("findbar-container").childNodes;
          let wrapper = this.getElement("findbar-textbox-wrapper");
          for (let node of nodes) {
            if (node == wrapper)
               continue;
            node.hidden = showMinimalUI;
          }
          this.getElement("find-next").hidden =
            this.getElement("find-previous").hidden = showMinimalUI;
          this._updateCaseSensitivity();

          if (showMinimalUI)
            this._findField.classList.add("minimal");
          else
            this._findField.classList.remove("minimal");

          if (this._findMode == this.FIND_TYPEAHEAD)
            this._findField.placeholder = this._fastFindStr;
          else if (this._findMode == this.FIND_LINKS)
            this._findField.placeholder = this._fastFindLinksStr;
          else
            this._findField.placeholder = this._normalFindStr;
        ]]></body>
      </method>

      <method name="_find">
        <parameter name="aValue"/>
        <body><![CDATA[
          if (!this._dispatchFindEvent(""))
            return;

          let val = aValue || this._findField.value;

          // We have to carry around an explicit version of this,
          // because finder.searchString doesn't update on failed
          // searches.
          this.browser._lastSearchString = val;

          // Only search on input if we don't have a last-failed string,
          // or if the current search string doesn't start with it.
          if (!this._findFailedString ||
              !val.startsWith(this._findFailedString))
          {
            this._enableFindButtons(val);
            if (this.getElement("highlight").checked)
              this._setHighlightTimeout();

            this._updateCaseSensitivity(val);

            this.browser.finder.fastFind(val, this._findMode == this.FIND_LINKS,
                                         this._findMode != this.FIND_NORMAL);
          }

          if (this._findMode != this.FIND_NORMAL)
            this._setFindCloseTimeout();

          if (this._findResetTimeout != -1)
            clearTimeout(this._findResetTimeout);

          // allow a search to happen on input again after a second has
          // expired since the previous input, to allow for dynamic
          // content and/or page loading
          this._findResetTimeout = setTimeout(() => {
            this._findFailedString = null;
            this._findResetTimeout = -1;
          }, 1000);
        ]]></body>
      </method>

      <method name="_flash">
        <body><![CDATA[
          if (this._flashFindBarCount === undefined)
            this._flashFindBarCount = this._initialFlashFindBarCount;

          if (this._flashFindBarCount-- == 0) {
            clearInterval(this._flashFindBarTimeout);
            this.removeAttribute("flash");
            this._flashFindBarCount = 6;
            return;
          }

          this.setAttribute("flash",
                            (this._flashFindBarCount % 2 == 0) ?
                            "false" : "true");
        ]]></body>
      </method>

      <method name="_setHighlightTimeout">
        <body><![CDATA[
          if (this._highlightTimeout)
            clearTimeout(this._highlightTimeout);
          this._highlightTimeout =
            setTimeout(function(aSelf) {
                         aSelf.toggleHighlight(false);
                         aSelf.toggleHighlight(true);
                       }, 500, this);
        ]]></body>
      </method>

      <method name="_findAgain">
        <parameter name="aFindPrevious"/>
        <body><![CDATA[
          this.browser.finder.findAgain(aFindPrevious,
                                        this._findMode == this.FIND_LINKS,
                                        this._findMode != this.FIND_NORMAL);
        ]]></body>
      </method>

      <method name="_updateStatusUI">
        <parameter name="res"/>
        <parameter name="aFindPrevious"/>
        <body><![CDATA[
          switch (res) {
            case this.nsITypeAheadFind.FIND_WRAPPED:
              this._findStatusIcon.setAttribute("status", "wrapped");
              this._findStatusDesc.textContent =
                aFindPrevious ? this._wrappedToBottomStr : this._wrappedToTopStr;
              this._findField.removeAttribute("status");
              break;
            case this.nsITypeAheadFind.FIND_NOTFOUND:
              this._findStatusIcon.setAttribute("status", "notfound");
              this._findStatusDesc.textContent = this._notFoundStr;
              this._findField.setAttribute("status", "notfound");
              break;
            case this.nsITypeAheadFind.FIND_PENDING:
              this._findStatusIcon.setAttribute("status", "pending");
              this._findStatusDesc.textContent = "";
              this._findField.removeAttribute("status");
              break;
            case this.nsITypeAheadFind.FIND_FOUND:
            default:
              this._findStatusIcon.removeAttribute("status");
              this._findStatusDesc.textContent = "";
              this._findField.removeAttribute("status");
              break;
          }
        ]]></body>
      </method>

      <method name="updateControlState">
        <parameter name="aResult"/>
        <parameter name="aFindPrevious"/>
        <body><![CDATA[
          this._updateStatusUI(aResult, aFindPrevious);
          this._enableFindButtons(aResult !== this.nsITypeAheadFind.FIND_NOTFOUND);
        ]]></body>
      </method>

      <method name="_getInitialSelection">
        <body><![CDATA[
          let focusedElement = document.commandDispatcher.focusedElement;
          let selText;

          if (focusedElement instanceof Components.interfaces.nsIDOMNSEditableElement &&
              focusedElement.editor &&
              focusedElement.ownerDocument.defaultView.top == this._browser.contentWindow)
          {
            // The user may have a selection in an input or textarea
            selText = focusedElement.editor.selectionController
              .getSelection(Components.interfaces.nsISelectionController.SELECTION_NORMAL)
              .toString();
          }
          else {
            // Look for any selected text on the actual page
            let focusedWindow = document.commandDispatcher.focusedWindow;
            if (focusedWindow.top == this._browser.contentWindow)
              selText = focusedWindow.getSelection().toString();
          }

          if (!selText)
            return "";

          // Process our text to get rid of unwanted characters
          if (selText.length > this._selectionMaxLen) {
            let pattern = new RegExp("^(?:\\s*.){0," + this._selectionMaxLen + "}");
            pattern.test(selText);
            selText = RegExp.lastMatch;
          }
          return selText.replace(/^\s+/, "")
                        .replace(/\s+$/, "")
                        .replace(/\s+/g, " ")
                        .substr(0, this._selectionMaxLen);
        ]]></body>
      </method>

      <method name="_dispatchFindEvent">
        <parameter name="aType"/>
        <parameter name="aFindPrevious"/>
        <body><![CDATA[
          let event = document.createEvent("CustomEvent");
          event.initCustomEvent("find" + aType, true, true, {
            query: this._findField.value,
            caseSensitive: !!this._typeAheadCaseSensitive,
            highlightAll: this.getElement("highlight").checked,
            findPrevious: aFindPrevious
          });
          return this.dispatchEvent(event);
        ]]></body>
      </method>


      <!--
        - Opens the findbar, focuses the findfield and selects its contents.
        - Also flashes the findbar the first time it's used.
        - @param aMode
        -        the find mode to be used, which is either FIND_NORMAL,
        -        FIND_TYPEAHEAD or FIND_LINKS. If not passed, the last
        -        find mode if any or FIND_NORMAL.
        -->
      <method name="startFind">
        <parameter name="aMode"/>
        <body><![CDATA[
          let prefsvc =
            Components.classes["@mozilla.org/preferences-service;1"]
                      .getService(Components.interfaces.nsIPrefBranch);
          let userWantsPrefill = true;
          this.open(aMode);

          if (this._flashFindBar) {
            this._flashFindBarTimeout = setInterval(() => this._flash(), 500);
            prefsvc.setIntPref("accessibility.typeaheadfind.flashBar",
                               --this._flashFindBar);
          }

          if (this.prefillWithSelection)
            userWantsPrefill =
              prefsvc.getBoolPref("accessibility.typeaheadfind.prefillwithselection");

          let initialString = (this.prefillWithSelection && userWantsPrefill) ?
                              this._getInitialSelection() : null;
          if (initialString)
            this._findField.value = initialString;

          this._enableFindButtons(!!this._findField.value);

          this._findField.select();
          this._findField.focus();
        ]]></body>
      </method>

      <!--
        - Convenient alias to startFind(gFindBar.FIND_NORMAL);
        -
        - You should generally map the window's find command to this method.
        -   e.g. <command name="cmd_find" oncommand="gFindBar.onFindCommand();"/>
        -->
      <method name="onFindCommand">
        <body><![CDATA[
          this.startFind(this.FIND_NORMAL);
        ]]></body>
      </method>

      <!--
        - Stub for find-next and find-previous commands
        - @param aFindPrevious
        -        true for find-previous, false otherwise.
        -->
      <method name="onFindAgainCommand">
        <parameter name="aFindPrevious"/>
        <body><![CDATA[
          let findString = this._browser.finder.searchString || this._findField.value;
          if (!findString) {
            this.startFind();
            return;
          }

          // We dispatch the findAgain event here instead of in _findAgain since
          // if there is a find event handler that prevents the default then
          // finder.searchString will never get updated which in turn means
          // there would never be findAgain events because of the logic below.
          if (!this._dispatchFindEvent("again", aFindPrevious))
            return;

          // user explicitly requested another search, so do it even if we think it'll fail
          this._findFailedString = null;

          // Ensure the stored SearchString is in sync with what we want to find
          if (this._findField.value != this._browser.finder.searchString)
            this._find(this._findField.value);
          else
            this._findAgain(aFindPrevious);

        ]]></body>
      </method>

      <!--
        - This handles all the result changes for both
        - type-ahead-find and highlighting.
        - @param aResult
        -   One of the nsITypeAheadFind.FIND_* constants
        -   indicating the result of a search operation.
        - @param aFindBackwards
        -   If the search was done from the bottom to
        -   the top. This is used for right error messages
        -   when reaching "the end of the page".
        - @param aLinkURL
        -   When a link matched then its URK. Always null
        -   when not in FIND_LINKS mode.
        -->
      <method name="onFindResult">
        <parameter name="aData"/>
        <body><![CDATA[
          this._updateStatusUI(aData.result, aData.findBackwards);
          this._updateStatusUIBar(aData.linkURL);

          if (aData.result == this.nsITypeAheadFind.FIND_NOTFOUND)
            this._findFailedString = aData.searchString;
          else
            this._findFailedString = null;

          if (this._findMode != this.FIND_NORMAL && !this.hidden)
            this._setFindCloseTimeout();
        ]]></body>
      </method>

      <!--
        - This handler may cancel a request to focus content by returning |false|
        - explicitly.
        -->
      <method name="shouldFocusContent">
        <body><![CDATA[
          const fm = Components.classes["@mozilla.org/focus-manager;1"]
                               .getService(Components.interfaces.nsIFocusManager);
          if (fm.focusedWindow != window)
            return false;

          let focusedElement = fm.focusedElement;
          if (!focusedElement)
            return false;

          let bindingParent = document.getBindingParent(focusedElement);
          if (bindingParent != this && bindingParent != this._findField)
            return false;

          return true;
        ]]></body>
      </method>

    </implementation>

    <handlers>
      <!--
        - We have to guard against `this.close` being |null| due to an unknown
        - issue, which is tracked in bug 957999.
        -->
      <handler event="keypress" keycode="VK_ESCAPE" phase="capturing"
               action="if (this.close) this.close();" preventdefault="true"/>
    </handlers>
  </binding>
</bindings>
