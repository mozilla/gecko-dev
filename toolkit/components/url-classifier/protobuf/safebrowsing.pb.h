// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: safebrowsing.proto

#ifndef PROTOBUF_safebrowsing_2eproto__INCLUDED
#define PROTOBUF_safebrowsing_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace mozilla {
namespace safebrowsing {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_safebrowsing_2eproto();
void protobuf_AssignDesc_safebrowsing_2eproto();
void protobuf_ShutdownFile_safebrowsing_2eproto();

class ThreatInfo;
class ThreatMatch;
class FindThreatMatchesRequest;
class FindThreatMatchesResponse;
class FetchThreatListUpdatesRequest;
class FetchThreatListUpdatesRequest_ListUpdateRequest;
class FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints;
class FetchThreatListUpdatesResponse;
class FetchThreatListUpdatesResponse_ListUpdateResponse;
class FindFullHashesRequest;
class FindFullHashesResponse;
class ThreatHit;
class ThreatHit_ThreatSource;
class ClientInfo;
class Checksum;
class ThreatEntry;
class ThreatEntrySet;
class RawIndices;
class RawHashes;
class RiceDeltaEncoding;
class ThreatEntryMetadata;
class ThreatEntryMetadata_MetadataEntry;
class ThreatListDescriptor;
class ListThreatListsResponse;
class Duration;

enum FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType {
  FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_RESPONSE_TYPE_UNSPECIFIED = 0,
  FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_PARTIAL_UPDATE = 1,
  FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_FULL_UPDATE = 2
};
bool FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_IsValid(int value);
const FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_ResponseType_MIN = FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_RESPONSE_TYPE_UNSPECIFIED;
const FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_ResponseType_MAX = FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_FULL_UPDATE;
const int FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_ResponseType_ARRAYSIZE = FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_ResponseType_MAX + 1;

enum ThreatHit_ThreatSourceType {
  ThreatHit_ThreatSourceType_THREAT_SOURCE_TYPE_UNSPECIFIED = 0,
  ThreatHit_ThreatSourceType_MATCHING_URL = 1,
  ThreatHit_ThreatSourceType_TAB_URL = 2,
  ThreatHit_ThreatSourceType_TAB_REDIRECT = 3
};
bool ThreatHit_ThreatSourceType_IsValid(int value);
const ThreatHit_ThreatSourceType ThreatHit_ThreatSourceType_ThreatSourceType_MIN = ThreatHit_ThreatSourceType_THREAT_SOURCE_TYPE_UNSPECIFIED;
const ThreatHit_ThreatSourceType ThreatHit_ThreatSourceType_ThreatSourceType_MAX = ThreatHit_ThreatSourceType_TAB_REDIRECT;
const int ThreatHit_ThreatSourceType_ThreatSourceType_ARRAYSIZE = ThreatHit_ThreatSourceType_ThreatSourceType_MAX + 1;

enum ThreatType {
  THREAT_TYPE_UNSPECIFIED = 0,
  MALWARE_THREAT = 1,
  SOCIAL_ENGINEERING_PUBLIC = 2,
  UNWANTED_SOFTWARE = 3,
  POTENTIALLY_HARMFUL_APPLICATION = 4,
  SOCIAL_ENGINEERING = 5,
  API_ABUSE = 6
};
bool ThreatType_IsValid(int value);
const ThreatType ThreatType_MIN = THREAT_TYPE_UNSPECIFIED;
const ThreatType ThreatType_MAX = API_ABUSE;
const int ThreatType_ARRAYSIZE = ThreatType_MAX + 1;

enum PlatformType {
  PLATFORM_TYPE_UNSPECIFIED = 0,
  WINDOWS_PLATFORM = 1,
  LINUX_PLATFORM = 2,
  ANDROID_PLATFORM = 3,
  OSX_PLATFORM = 4,
  IOS_PLATFORM = 5,
  ANY_PLATFORM = 6,
  ALL_PLATFORMS = 7,
  CHROME_PLATFORM = 8
};
bool PlatformType_IsValid(int value);
const PlatformType PlatformType_MIN = PLATFORM_TYPE_UNSPECIFIED;
const PlatformType PlatformType_MAX = CHROME_PLATFORM;
const int PlatformType_ARRAYSIZE = PlatformType_MAX + 1;

enum CompressionType {
  COMPRESSION_TYPE_UNSPECIFIED = 0,
  RAW = 1,
  RICE = 2
};
bool CompressionType_IsValid(int value);
const CompressionType CompressionType_MIN = COMPRESSION_TYPE_UNSPECIFIED;
const CompressionType CompressionType_MAX = RICE;
const int CompressionType_ARRAYSIZE = CompressionType_MAX + 1;

enum ThreatEntryType {
  THREAT_ENTRY_TYPE_UNSPECIFIED = 0,
  URL = 1,
  EXECUTABLE = 2,
  IP_RANGE = 3
};
bool ThreatEntryType_IsValid(int value);
const ThreatEntryType ThreatEntryType_MIN = THREAT_ENTRY_TYPE_UNSPECIFIED;
const ThreatEntryType ThreatEntryType_MAX = IP_RANGE;
const int ThreatEntryType_ARRAYSIZE = ThreatEntryType_MAX + 1;

// ===================================================================

class ThreatInfo : public ::google::protobuf::MessageLite {
 public:
  ThreatInfo();
  virtual ~ThreatInfo();

  ThreatInfo(const ThreatInfo& from);

  inline ThreatInfo& operator=(const ThreatInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ThreatInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ThreatInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ThreatInfo* other);

  // implements Message ----------------------------------------------

  ThreatInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ThreatInfo& from);
  void MergeFrom(const ThreatInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mozilla.safebrowsing.ThreatType threat_types = 1;
  inline int threat_types_size() const;
  inline void clear_threat_types();
  static const int kThreatTypesFieldNumber = 1;
  inline ::mozilla::safebrowsing::ThreatType threat_types(int index) const;
  inline void set_threat_types(int index, ::mozilla::safebrowsing::ThreatType value);
  inline void add_threat_types(::mozilla::safebrowsing::ThreatType value);
  inline const ::google::protobuf::RepeatedField<int>& threat_types() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_threat_types();

  // repeated .mozilla.safebrowsing.PlatformType platform_types = 2;
  inline int platform_types_size() const;
  inline void clear_platform_types();
  static const int kPlatformTypesFieldNumber = 2;
  inline ::mozilla::safebrowsing::PlatformType platform_types(int index) const;
  inline void set_platform_types(int index, ::mozilla::safebrowsing::PlatformType value);
  inline void add_platform_types(::mozilla::safebrowsing::PlatformType value);
  inline const ::google::protobuf::RepeatedField<int>& platform_types() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_platform_types();

  // repeated .mozilla.safebrowsing.ThreatEntryType threat_entry_types = 4;
  inline int threat_entry_types_size() const;
  inline void clear_threat_entry_types();
  static const int kThreatEntryTypesFieldNumber = 4;
  inline ::mozilla::safebrowsing::ThreatEntryType threat_entry_types(int index) const;
  inline void set_threat_entry_types(int index, ::mozilla::safebrowsing::ThreatEntryType value);
  inline void add_threat_entry_types(::mozilla::safebrowsing::ThreatEntryType value);
  inline const ::google::protobuf::RepeatedField<int>& threat_entry_types() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_threat_entry_types();

  // repeated .mozilla.safebrowsing.ThreatEntry threat_entries = 3;
  inline int threat_entries_size() const;
  inline void clear_threat_entries();
  static const int kThreatEntriesFieldNumber = 3;
  inline const ::mozilla::safebrowsing::ThreatEntry& threat_entries(int index) const;
  inline ::mozilla::safebrowsing::ThreatEntry* mutable_threat_entries(int index);
  inline ::mozilla::safebrowsing::ThreatEntry* add_threat_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntry >&
      threat_entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntry >*
      mutable_threat_entries();

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.ThreatInfo)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField<int> threat_types_;
  ::google::protobuf::RepeatedField<int> platform_types_;
  ::google::protobuf::RepeatedField<int> threat_entry_types_;
  ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntry > threat_entries_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_safebrowsing_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_safebrowsing_2eproto();
  #endif
  friend void protobuf_AssignDesc_safebrowsing_2eproto();
  friend void protobuf_ShutdownFile_safebrowsing_2eproto();

  void InitAsDefaultInstance();
  static ThreatInfo* default_instance_;
};
// -------------------------------------------------------------------

class ThreatMatch : public ::google::protobuf::MessageLite {
 public:
  ThreatMatch();
  virtual ~ThreatMatch();

  ThreatMatch(const ThreatMatch& from);

  inline ThreatMatch& operator=(const ThreatMatch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ThreatMatch& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ThreatMatch* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ThreatMatch* other);

  // implements Message ----------------------------------------------

  ThreatMatch* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ThreatMatch& from);
  void MergeFrom(const ThreatMatch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
  inline bool has_threat_type() const;
  inline void clear_threat_type();
  static const int kThreatTypeFieldNumber = 1;
  inline ::mozilla::safebrowsing::ThreatType threat_type() const;
  inline void set_threat_type(::mozilla::safebrowsing::ThreatType value);

  // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
  inline bool has_platform_type() const;
  inline void clear_platform_type();
  static const int kPlatformTypeFieldNumber = 2;
  inline ::mozilla::safebrowsing::PlatformType platform_type() const;
  inline void set_platform_type(::mozilla::safebrowsing::PlatformType value);

  // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 6;
  inline bool has_threat_entry_type() const;
  inline void clear_threat_entry_type();
  static const int kThreatEntryTypeFieldNumber = 6;
  inline ::mozilla::safebrowsing::ThreatEntryType threat_entry_type() const;
  inline void set_threat_entry_type(::mozilla::safebrowsing::ThreatEntryType value);

  // optional .mozilla.safebrowsing.ThreatEntry threat = 3;
  inline bool has_threat() const;
  inline void clear_threat();
  static const int kThreatFieldNumber = 3;
  inline const ::mozilla::safebrowsing::ThreatEntry& threat() const;
  inline ::mozilla::safebrowsing::ThreatEntry* mutable_threat();
  inline ::mozilla::safebrowsing::ThreatEntry* release_threat();
  inline void set_allocated_threat(::mozilla::safebrowsing::ThreatEntry* threat);

  // optional .mozilla.safebrowsing.ThreatEntryMetadata threat_entry_metadata = 4;
  inline bool has_threat_entry_metadata() const;
  inline void clear_threat_entry_metadata();
  static const int kThreatEntryMetadataFieldNumber = 4;
  inline const ::mozilla::safebrowsing::ThreatEntryMetadata& threat_entry_metadata() const;
  inline ::mozilla::safebrowsing::ThreatEntryMetadata* mutable_threat_entry_metadata();
  inline ::mozilla::safebrowsing::ThreatEntryMetadata* release_threat_entry_metadata();
  inline void set_allocated_threat_entry_metadata(::mozilla::safebrowsing::ThreatEntryMetadata* threat_entry_metadata);

  // optional .mozilla.safebrowsing.Duration cache_duration = 5;
  inline bool has_cache_duration() const;
  inline void clear_cache_duration();
  static const int kCacheDurationFieldNumber = 5;
  inline const ::mozilla::safebrowsing::Duration& cache_duration() const;
  inline ::mozilla::safebrowsing::Duration* mutable_cache_duration();
  inline ::mozilla::safebrowsing::Duration* release_cache_duration();
  inline void set_allocated_cache_duration(::mozilla::safebrowsing::Duration* cache_duration);

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.ThreatMatch)
 private:
  inline void set_has_threat_type();
  inline void clear_has_threat_type();
  inline void set_has_platform_type();
  inline void clear_has_platform_type();
  inline void set_has_threat_entry_type();
  inline void clear_has_threat_entry_type();
  inline void set_has_threat();
  inline void clear_has_threat();
  inline void set_has_threat_entry_metadata();
  inline void clear_has_threat_entry_metadata();
  inline void set_has_cache_duration();
  inline void clear_has_cache_duration();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int threat_type_;
  int platform_type_;
  ::mozilla::safebrowsing::ThreatEntry* threat_;
  ::mozilla::safebrowsing::ThreatEntryMetadata* threat_entry_metadata_;
  ::mozilla::safebrowsing::Duration* cache_duration_;
  int threat_entry_type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_safebrowsing_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_safebrowsing_2eproto();
  #endif
  friend void protobuf_AssignDesc_safebrowsing_2eproto();
  friend void protobuf_ShutdownFile_safebrowsing_2eproto();

  void InitAsDefaultInstance();
  static ThreatMatch* default_instance_;
};
// -------------------------------------------------------------------

class FindThreatMatchesRequest : public ::google::protobuf::MessageLite {
 public:
  FindThreatMatchesRequest();
  virtual ~FindThreatMatchesRequest();

  FindThreatMatchesRequest(const FindThreatMatchesRequest& from);

  inline FindThreatMatchesRequest& operator=(const FindThreatMatchesRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const FindThreatMatchesRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FindThreatMatchesRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FindThreatMatchesRequest* other);

  // implements Message ----------------------------------------------

  FindThreatMatchesRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FindThreatMatchesRequest& from);
  void MergeFrom(const FindThreatMatchesRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mozilla.safebrowsing.ClientInfo client = 1;
  inline bool has_client() const;
  inline void clear_client();
  static const int kClientFieldNumber = 1;
  inline const ::mozilla::safebrowsing::ClientInfo& client() const;
  inline ::mozilla::safebrowsing::ClientInfo* mutable_client();
  inline ::mozilla::safebrowsing::ClientInfo* release_client();
  inline void set_allocated_client(::mozilla::safebrowsing::ClientInfo* client);

  // optional .mozilla.safebrowsing.ThreatInfo threat_info = 2;
  inline bool has_threat_info() const;
  inline void clear_threat_info();
  static const int kThreatInfoFieldNumber = 2;
  inline const ::mozilla::safebrowsing::ThreatInfo& threat_info() const;
  inline ::mozilla::safebrowsing::ThreatInfo* mutable_threat_info();
  inline ::mozilla::safebrowsing::ThreatInfo* release_threat_info();
  inline void set_allocated_threat_info(::mozilla::safebrowsing::ThreatInfo* threat_info);

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.FindThreatMatchesRequest)
 private:
  inline void set_has_client();
  inline void clear_has_client();
  inline void set_has_threat_info();
  inline void clear_has_threat_info();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mozilla::safebrowsing::ClientInfo* client_;
  ::mozilla::safebrowsing::ThreatInfo* threat_info_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_safebrowsing_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_safebrowsing_2eproto();
  #endif
  friend void protobuf_AssignDesc_safebrowsing_2eproto();
  friend void protobuf_ShutdownFile_safebrowsing_2eproto();

  void InitAsDefaultInstance();
  static FindThreatMatchesRequest* default_instance_;
};
// -------------------------------------------------------------------

class FindThreatMatchesResponse : public ::google::protobuf::MessageLite {
 public:
  FindThreatMatchesResponse();
  virtual ~FindThreatMatchesResponse();

  FindThreatMatchesResponse(const FindThreatMatchesResponse& from);

  inline FindThreatMatchesResponse& operator=(const FindThreatMatchesResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const FindThreatMatchesResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FindThreatMatchesResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FindThreatMatchesResponse* other);

  // implements Message ----------------------------------------------

  FindThreatMatchesResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FindThreatMatchesResponse& from);
  void MergeFrom(const FindThreatMatchesResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mozilla.safebrowsing.ThreatMatch matches = 1;
  inline int matches_size() const;
  inline void clear_matches();
  static const int kMatchesFieldNumber = 1;
  inline const ::mozilla::safebrowsing::ThreatMatch& matches(int index) const;
  inline ::mozilla::safebrowsing::ThreatMatch* mutable_matches(int index);
  inline ::mozilla::safebrowsing::ThreatMatch* add_matches();
  inline const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatMatch >&
      matches() const;
  inline ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatMatch >*
      mutable_matches();

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.FindThreatMatchesResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatMatch > matches_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_safebrowsing_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_safebrowsing_2eproto();
  #endif
  friend void protobuf_AssignDesc_safebrowsing_2eproto();
  friend void protobuf_ShutdownFile_safebrowsing_2eproto();

  void InitAsDefaultInstance();
  static FindThreatMatchesResponse* default_instance_;
};
// -------------------------------------------------------------------

class FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints : public ::google::protobuf::MessageLite {
 public:
  FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints();
  virtual ~FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints();

  FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints(const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& from);

  inline FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& operator=(const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* other);

  // implements Message ----------------------------------------------

  FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& from);
  void MergeFrom(const FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 max_update_entries = 1;
  inline bool has_max_update_entries() const;
  inline void clear_max_update_entries();
  static const int kMaxUpdateEntriesFieldNumber = 1;
  inline ::google::protobuf::int32 max_update_entries() const;
  inline void set_max_update_entries(::google::protobuf::int32 value);

  // optional int32 max_database_entries = 2;
  inline bool has_max_database_entries() const;
  inline void clear_max_database_entries();
  static const int kMaxDatabaseEntriesFieldNumber = 2;
  inline ::google::protobuf::int32 max_database_entries() const;
  inline void set_max_database_entries(::google::protobuf::int32 value);

  // optional string region = 3;
  inline bool has_region() const;
  inline void clear_region();
  static const int kRegionFieldNumber = 3;
  inline const ::std::string& region() const;
  inline void set_region(const ::std::string& value);
  inline void set_region(const char* value);
  inline void set_region(const char* value, size_t size);
  inline ::std::string* mutable_region();
  inline ::std::string* release_region();
  inline void set_allocated_region(::std::string* region);

  // repeated .mozilla.safebrowsing.CompressionType supported_compressions = 4;
  inline int supported_compressions_size() const;
  inline void clear_supported_compressions();
  static const int kSupportedCompressionsFieldNumber = 4;
  inline ::mozilla::safebrowsing::CompressionType supported_compressions(int index) const;
  inline void set_supported_compressions(int index, ::mozilla::safebrowsing::CompressionType value);
  inline void add_supported_compressions(::mozilla::safebrowsing::CompressionType value);
  inline const ::google::protobuf::RepeatedField<int>& supported_compressions() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_supported_compressions();

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints)
 private:
  inline void set_has_max_update_entries();
  inline void clear_has_max_update_entries();
  inline void set_has_max_database_entries();
  inline void clear_has_max_database_entries();
  inline void set_has_region();
  inline void clear_has_region();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 max_update_entries_;
  ::google::protobuf::int32 max_database_entries_;
  ::std::string* region_;
  ::google::protobuf::RepeatedField<int> supported_compressions_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_safebrowsing_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_safebrowsing_2eproto();
  #endif
  friend void protobuf_AssignDesc_safebrowsing_2eproto();
  friend void protobuf_ShutdownFile_safebrowsing_2eproto();

  void InitAsDefaultInstance();
  static FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* default_instance_;
};
// -------------------------------------------------------------------

class FetchThreatListUpdatesRequest_ListUpdateRequest : public ::google::protobuf::MessageLite {
 public:
  FetchThreatListUpdatesRequest_ListUpdateRequest();
  virtual ~FetchThreatListUpdatesRequest_ListUpdateRequest();

  FetchThreatListUpdatesRequest_ListUpdateRequest(const FetchThreatListUpdatesRequest_ListUpdateRequest& from);

  inline FetchThreatListUpdatesRequest_ListUpdateRequest& operator=(const FetchThreatListUpdatesRequest_ListUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const FetchThreatListUpdatesRequest_ListUpdateRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FetchThreatListUpdatesRequest_ListUpdateRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FetchThreatListUpdatesRequest_ListUpdateRequest* other);

  // implements Message ----------------------------------------------

  FetchThreatListUpdatesRequest_ListUpdateRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FetchThreatListUpdatesRequest_ListUpdateRequest& from);
  void MergeFrom(const FetchThreatListUpdatesRequest_ListUpdateRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints Constraints;

  // accessors -------------------------------------------------------

  // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
  inline bool has_threat_type() const;
  inline void clear_threat_type();
  static const int kThreatTypeFieldNumber = 1;
  inline ::mozilla::safebrowsing::ThreatType threat_type() const;
  inline void set_threat_type(::mozilla::safebrowsing::ThreatType value);

  // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
  inline bool has_platform_type() const;
  inline void clear_platform_type();
  static const int kPlatformTypeFieldNumber = 2;
  inline ::mozilla::safebrowsing::PlatformType platform_type() const;
  inline void set_platform_type(::mozilla::safebrowsing::PlatformType value);

  // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 5;
  inline bool has_threat_entry_type() const;
  inline void clear_threat_entry_type();
  static const int kThreatEntryTypeFieldNumber = 5;
  inline ::mozilla::safebrowsing::ThreatEntryType threat_entry_type() const;
  inline void set_threat_entry_type(::mozilla::safebrowsing::ThreatEntryType value);

  // optional bytes state = 3;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 3;
  inline const ::std::string& state() const;
  inline void set_state(const ::std::string& value);
  inline void set_state(const char* value);
  inline void set_state(const void* value, size_t size);
  inline ::std::string* mutable_state();
  inline ::std::string* release_state();
  inline void set_allocated_state(::std::string* state);

  // optional .mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints constraints = 4;
  inline bool has_constraints() const;
  inline void clear_constraints();
  static const int kConstraintsFieldNumber = 4;
  inline const ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& constraints() const;
  inline ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* mutable_constraints();
  inline ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* release_constraints();
  inline void set_allocated_constraints(::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* constraints);

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest)
 private:
  inline void set_has_threat_type();
  inline void clear_has_threat_type();
  inline void set_has_platform_type();
  inline void clear_has_platform_type();
  inline void set_has_threat_entry_type();
  inline void clear_has_threat_entry_type();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_constraints();
  inline void clear_has_constraints();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int threat_type_;
  int platform_type_;
  ::std::string* state_;
  ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* constraints_;
  int threat_entry_type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_safebrowsing_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_safebrowsing_2eproto();
  #endif
  friend void protobuf_AssignDesc_safebrowsing_2eproto();
  friend void protobuf_ShutdownFile_safebrowsing_2eproto();

  void InitAsDefaultInstance();
  static FetchThreatListUpdatesRequest_ListUpdateRequest* default_instance_;
};
// -------------------------------------------------------------------

class FetchThreatListUpdatesRequest : public ::google::protobuf::MessageLite {
 public:
  FetchThreatListUpdatesRequest();
  virtual ~FetchThreatListUpdatesRequest();

  FetchThreatListUpdatesRequest(const FetchThreatListUpdatesRequest& from);

  inline FetchThreatListUpdatesRequest& operator=(const FetchThreatListUpdatesRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const FetchThreatListUpdatesRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FetchThreatListUpdatesRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FetchThreatListUpdatesRequest* other);

  // implements Message ----------------------------------------------

  FetchThreatListUpdatesRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FetchThreatListUpdatesRequest& from);
  void MergeFrom(const FetchThreatListUpdatesRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef FetchThreatListUpdatesRequest_ListUpdateRequest ListUpdateRequest;

  // accessors -------------------------------------------------------

  // optional .mozilla.safebrowsing.ClientInfo client = 1;
  inline bool has_client() const;
  inline void clear_client();
  static const int kClientFieldNumber = 1;
  inline const ::mozilla::safebrowsing::ClientInfo& client() const;
  inline ::mozilla::safebrowsing::ClientInfo* mutable_client();
  inline ::mozilla::safebrowsing::ClientInfo* release_client();
  inline void set_allocated_client(::mozilla::safebrowsing::ClientInfo* client);

  // repeated .mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest list_update_requests = 3;
  inline int list_update_requests_size() const;
  inline void clear_list_update_requests();
  static const int kListUpdateRequestsFieldNumber = 3;
  inline const ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest& list_update_requests(int index) const;
  inline ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest* mutable_list_update_requests(int index);
  inline ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest* add_list_update_requests();
  inline const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest >&
      list_update_requests() const;
  inline ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest >*
      mutable_list_update_requests();

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.FetchThreatListUpdatesRequest)
 private:
  inline void set_has_client();
  inline void clear_has_client();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mozilla::safebrowsing::ClientInfo* client_;
  ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest > list_update_requests_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_safebrowsing_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_safebrowsing_2eproto();
  #endif
  friend void protobuf_AssignDesc_safebrowsing_2eproto();
  friend void protobuf_ShutdownFile_safebrowsing_2eproto();

  void InitAsDefaultInstance();
  static FetchThreatListUpdatesRequest* default_instance_;
};
// -------------------------------------------------------------------

class FetchThreatListUpdatesResponse_ListUpdateResponse : public ::google::protobuf::MessageLite {
 public:
  FetchThreatListUpdatesResponse_ListUpdateResponse();
  virtual ~FetchThreatListUpdatesResponse_ListUpdateResponse();

  FetchThreatListUpdatesResponse_ListUpdateResponse(const FetchThreatListUpdatesResponse_ListUpdateResponse& from);

  inline FetchThreatListUpdatesResponse_ListUpdateResponse& operator=(const FetchThreatListUpdatesResponse_ListUpdateResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const FetchThreatListUpdatesResponse_ListUpdateResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FetchThreatListUpdatesResponse_ListUpdateResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FetchThreatListUpdatesResponse_ListUpdateResponse* other);

  // implements Message ----------------------------------------------

  FetchThreatListUpdatesResponse_ListUpdateResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FetchThreatListUpdatesResponse_ListUpdateResponse& from);
  void MergeFrom(const FetchThreatListUpdatesResponse_ListUpdateResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType ResponseType;
  static const ResponseType RESPONSE_TYPE_UNSPECIFIED = FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_RESPONSE_TYPE_UNSPECIFIED;
  static const ResponseType PARTIAL_UPDATE = FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_PARTIAL_UPDATE;
  static const ResponseType FULL_UPDATE = FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_FULL_UPDATE;
  static inline bool ResponseType_IsValid(int value) {
    return FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_IsValid(value);
  }
  static const ResponseType ResponseType_MIN =
    FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_ResponseType_MIN;
  static const ResponseType ResponseType_MAX =
    FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_ResponseType_MAX;
  static const int ResponseType_ARRAYSIZE =
    FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_ResponseType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
  inline bool has_threat_type() const;
  inline void clear_threat_type();
  static const int kThreatTypeFieldNumber = 1;
  inline ::mozilla::safebrowsing::ThreatType threat_type() const;
  inline void set_threat_type(::mozilla::safebrowsing::ThreatType value);

  // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 2;
  inline bool has_threat_entry_type() const;
  inline void clear_threat_entry_type();
  static const int kThreatEntryTypeFieldNumber = 2;
  inline ::mozilla::safebrowsing::ThreatEntryType threat_entry_type() const;
  inline void set_threat_entry_type(::mozilla::safebrowsing::ThreatEntryType value);

  // optional .mozilla.safebrowsing.PlatformType platform_type = 3;
  inline bool has_platform_type() const;
  inline void clear_platform_type();
  static const int kPlatformTypeFieldNumber = 3;
  inline ::mozilla::safebrowsing::PlatformType platform_type() const;
  inline void set_platform_type(::mozilla::safebrowsing::PlatformType value);

  // optional .mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.ResponseType response_type = 4;
  inline bool has_response_type() const;
  inline void clear_response_type();
  static const int kResponseTypeFieldNumber = 4;
  inline ::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType response_type() const;
  inline void set_response_type(::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType value);

  // repeated .mozilla.safebrowsing.ThreatEntrySet additions = 5;
  inline int additions_size() const;
  inline void clear_additions();
  static const int kAdditionsFieldNumber = 5;
  inline const ::mozilla::safebrowsing::ThreatEntrySet& additions(int index) const;
  inline ::mozilla::safebrowsing::ThreatEntrySet* mutable_additions(int index);
  inline ::mozilla::safebrowsing::ThreatEntrySet* add_additions();
  inline const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntrySet >&
      additions() const;
  inline ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntrySet >*
      mutable_additions();

  // repeated .mozilla.safebrowsing.ThreatEntrySet removals = 6;
  inline int removals_size() const;
  inline void clear_removals();
  static const int kRemovalsFieldNumber = 6;
  inline const ::mozilla::safebrowsing::ThreatEntrySet& removals(int index) const;
  inline ::mozilla::safebrowsing::ThreatEntrySet* mutable_removals(int index);
  inline ::mozilla::safebrowsing::ThreatEntrySet* add_removals();
  inline const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntrySet >&
      removals() const;
  inline ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntrySet >*
      mutable_removals();

  // optional bytes new_client_state = 7;
  inline bool has_new_client_state() const;
  inline void clear_new_client_state();
  static const int kNewClientStateFieldNumber = 7;
  inline const ::std::string& new_client_state() const;
  inline void set_new_client_state(const ::std::string& value);
  inline void set_new_client_state(const char* value);
  inline void set_new_client_state(const void* value, size_t size);
  inline ::std::string* mutable_new_client_state();
  inline ::std::string* release_new_client_state();
  inline void set_allocated_new_client_state(::std::string* new_client_state);

  // optional .mozilla.safebrowsing.Checksum checksum = 8;
  inline bool has_checksum() const;
  inline void clear_checksum();
  static const int kChecksumFieldNumber = 8;
  inline const ::mozilla::safebrowsing::Checksum& checksum() const;
  inline ::mozilla::safebrowsing::Checksum* mutable_checksum();
  inline ::mozilla::safebrowsing::Checksum* release_checksum();
  inline void set_allocated_checksum(::mozilla::safebrowsing::Checksum* checksum);

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse)
 private:
  inline void set_has_threat_type();
  inline void clear_has_threat_type();
  inline void set_has_threat_entry_type();
  inline void clear_has_threat_entry_type();
  inline void set_has_platform_type();
  inline void clear_has_platform_type();
  inline void set_has_response_type();
  inline void clear_has_response_type();
  inline void set_has_new_client_state();
  inline void clear_has_new_client_state();
  inline void set_has_checksum();
  inline void clear_has_checksum();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int threat_type_;
  int threat_entry_type_;
  int platform_type_;
  int response_type_;
  ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntrySet > additions_;
  ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntrySet > removals_;
  ::std::string* new_client_state_;
  ::mozilla::safebrowsing::Checksum* checksum_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_safebrowsing_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_safebrowsing_2eproto();
  #endif
  friend void protobuf_AssignDesc_safebrowsing_2eproto();
  friend void protobuf_ShutdownFile_safebrowsing_2eproto();

  void InitAsDefaultInstance();
  static FetchThreatListUpdatesResponse_ListUpdateResponse* default_instance_;
};
// -------------------------------------------------------------------

class FetchThreatListUpdatesResponse : public ::google::protobuf::MessageLite {
 public:
  FetchThreatListUpdatesResponse();
  virtual ~FetchThreatListUpdatesResponse();

  FetchThreatListUpdatesResponse(const FetchThreatListUpdatesResponse& from);

  inline FetchThreatListUpdatesResponse& operator=(const FetchThreatListUpdatesResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const FetchThreatListUpdatesResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FetchThreatListUpdatesResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FetchThreatListUpdatesResponse* other);

  // implements Message ----------------------------------------------

  FetchThreatListUpdatesResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FetchThreatListUpdatesResponse& from);
  void MergeFrom(const FetchThreatListUpdatesResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef FetchThreatListUpdatesResponse_ListUpdateResponse ListUpdateResponse;

  // accessors -------------------------------------------------------

  // repeated .mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse list_update_responses = 1;
  inline int list_update_responses_size() const;
  inline void clear_list_update_responses();
  static const int kListUpdateResponsesFieldNumber = 1;
  inline const ::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse& list_update_responses(int index) const;
  inline ::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse* mutable_list_update_responses(int index);
  inline ::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse* add_list_update_responses();
  inline const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse >&
      list_update_responses() const;
  inline ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse >*
      mutable_list_update_responses();

  // optional .mozilla.safebrowsing.Duration minimum_wait_duration = 2;
  inline bool has_minimum_wait_duration() const;
  inline void clear_minimum_wait_duration();
  static const int kMinimumWaitDurationFieldNumber = 2;
  inline const ::mozilla::safebrowsing::Duration& minimum_wait_duration() const;
  inline ::mozilla::safebrowsing::Duration* mutable_minimum_wait_duration();
  inline ::mozilla::safebrowsing::Duration* release_minimum_wait_duration();
  inline void set_allocated_minimum_wait_duration(::mozilla::safebrowsing::Duration* minimum_wait_duration);

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.FetchThreatListUpdatesResponse)
 private:
  inline void set_has_minimum_wait_duration();
  inline void clear_has_minimum_wait_duration();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse > list_update_responses_;
  ::mozilla::safebrowsing::Duration* minimum_wait_duration_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_safebrowsing_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_safebrowsing_2eproto();
  #endif
  friend void protobuf_AssignDesc_safebrowsing_2eproto();
  friend void protobuf_ShutdownFile_safebrowsing_2eproto();

  void InitAsDefaultInstance();
  static FetchThreatListUpdatesResponse* default_instance_;
};
// -------------------------------------------------------------------

class FindFullHashesRequest : public ::google::protobuf::MessageLite {
 public:
  FindFullHashesRequest();
  virtual ~FindFullHashesRequest();

  FindFullHashesRequest(const FindFullHashesRequest& from);

  inline FindFullHashesRequest& operator=(const FindFullHashesRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const FindFullHashesRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FindFullHashesRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FindFullHashesRequest* other);

  // implements Message ----------------------------------------------

  FindFullHashesRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FindFullHashesRequest& from);
  void MergeFrom(const FindFullHashesRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mozilla.safebrowsing.ClientInfo client = 1;
  inline bool has_client() const;
  inline void clear_client();
  static const int kClientFieldNumber = 1;
  inline const ::mozilla::safebrowsing::ClientInfo& client() const;
  inline ::mozilla::safebrowsing::ClientInfo* mutable_client();
  inline ::mozilla::safebrowsing::ClientInfo* release_client();
  inline void set_allocated_client(::mozilla::safebrowsing::ClientInfo* client);

  // repeated bytes client_states = 2;
  inline int client_states_size() const;
  inline void clear_client_states();
  static const int kClientStatesFieldNumber = 2;
  inline const ::std::string& client_states(int index) const;
  inline ::std::string* mutable_client_states(int index);
  inline void set_client_states(int index, const ::std::string& value);
  inline void set_client_states(int index, const char* value);
  inline void set_client_states(int index, const void* value, size_t size);
  inline ::std::string* add_client_states();
  inline void add_client_states(const ::std::string& value);
  inline void add_client_states(const char* value);
  inline void add_client_states(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& client_states() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_client_states();

  // optional .mozilla.safebrowsing.ThreatInfo threat_info = 3;
  inline bool has_threat_info() const;
  inline void clear_threat_info();
  static const int kThreatInfoFieldNumber = 3;
  inline const ::mozilla::safebrowsing::ThreatInfo& threat_info() const;
  inline ::mozilla::safebrowsing::ThreatInfo* mutable_threat_info();
  inline ::mozilla::safebrowsing::ThreatInfo* release_threat_info();
  inline void set_allocated_threat_info(::mozilla::safebrowsing::ThreatInfo* threat_info);

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.FindFullHashesRequest)
 private:
  inline void set_has_client();
  inline void clear_has_client();
  inline void set_has_threat_info();
  inline void clear_has_threat_info();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mozilla::safebrowsing::ClientInfo* client_;
  ::google::protobuf::RepeatedPtrField< ::std::string> client_states_;
  ::mozilla::safebrowsing::ThreatInfo* threat_info_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_safebrowsing_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_safebrowsing_2eproto();
  #endif
  friend void protobuf_AssignDesc_safebrowsing_2eproto();
  friend void protobuf_ShutdownFile_safebrowsing_2eproto();

  void InitAsDefaultInstance();
  static FindFullHashesRequest* default_instance_;
};
// -------------------------------------------------------------------

class FindFullHashesResponse : public ::google::protobuf::MessageLite {
 public:
  FindFullHashesResponse();
  virtual ~FindFullHashesResponse();

  FindFullHashesResponse(const FindFullHashesResponse& from);

  inline FindFullHashesResponse& operator=(const FindFullHashesResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const FindFullHashesResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FindFullHashesResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FindFullHashesResponse* other);

  // implements Message ----------------------------------------------

  FindFullHashesResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FindFullHashesResponse& from);
  void MergeFrom(const FindFullHashesResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mozilla.safebrowsing.ThreatMatch matches = 1;
  inline int matches_size() const;
  inline void clear_matches();
  static const int kMatchesFieldNumber = 1;
  inline const ::mozilla::safebrowsing::ThreatMatch& matches(int index) const;
  inline ::mozilla::safebrowsing::ThreatMatch* mutable_matches(int index);
  inline ::mozilla::safebrowsing::ThreatMatch* add_matches();
  inline const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatMatch >&
      matches() const;
  inline ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatMatch >*
      mutable_matches();

  // optional .mozilla.safebrowsing.Duration minimum_wait_duration = 2;
  inline bool has_minimum_wait_duration() const;
  inline void clear_minimum_wait_duration();
  static const int kMinimumWaitDurationFieldNumber = 2;
  inline const ::mozilla::safebrowsing::Duration& minimum_wait_duration() const;
  inline ::mozilla::safebrowsing::Duration* mutable_minimum_wait_duration();
  inline ::mozilla::safebrowsing::Duration* release_minimum_wait_duration();
  inline void set_allocated_minimum_wait_duration(::mozilla::safebrowsing::Duration* minimum_wait_duration);

  // optional .mozilla.safebrowsing.Duration negative_cache_duration = 3;
  inline bool has_negative_cache_duration() const;
  inline void clear_negative_cache_duration();
  static const int kNegativeCacheDurationFieldNumber = 3;
  inline const ::mozilla::safebrowsing::Duration& negative_cache_duration() const;
  inline ::mozilla::safebrowsing::Duration* mutable_negative_cache_duration();
  inline ::mozilla::safebrowsing::Duration* release_negative_cache_duration();
  inline void set_allocated_negative_cache_duration(::mozilla::safebrowsing::Duration* negative_cache_duration);

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.FindFullHashesResponse)
 private:
  inline void set_has_minimum_wait_duration();
  inline void clear_has_minimum_wait_duration();
  inline void set_has_negative_cache_duration();
  inline void clear_has_negative_cache_duration();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatMatch > matches_;
  ::mozilla::safebrowsing::Duration* minimum_wait_duration_;
  ::mozilla::safebrowsing::Duration* negative_cache_duration_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_safebrowsing_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_safebrowsing_2eproto();
  #endif
  friend void protobuf_AssignDesc_safebrowsing_2eproto();
  friend void protobuf_ShutdownFile_safebrowsing_2eproto();

  void InitAsDefaultInstance();
  static FindFullHashesResponse* default_instance_;
};
// -------------------------------------------------------------------

class ThreatHit_ThreatSource : public ::google::protobuf::MessageLite {
 public:
  ThreatHit_ThreatSource();
  virtual ~ThreatHit_ThreatSource();

  ThreatHit_ThreatSource(const ThreatHit_ThreatSource& from);

  inline ThreatHit_ThreatSource& operator=(const ThreatHit_ThreatSource& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ThreatHit_ThreatSource& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ThreatHit_ThreatSource* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ThreatHit_ThreatSource* other);

  // implements Message ----------------------------------------------

  ThreatHit_ThreatSource* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ThreatHit_ThreatSource& from);
  void MergeFrom(const ThreatHit_ThreatSource& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string url = 1;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 1;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // optional .mozilla.safebrowsing.ThreatHit.ThreatSourceType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::mozilla::safebrowsing::ThreatHit_ThreatSourceType type() const;
  inline void set_type(::mozilla::safebrowsing::ThreatHit_ThreatSourceType value);

  // optional string remote_ip = 3;
  inline bool has_remote_ip() const;
  inline void clear_remote_ip();
  static const int kRemoteIpFieldNumber = 3;
  inline const ::std::string& remote_ip() const;
  inline void set_remote_ip(const ::std::string& value);
  inline void set_remote_ip(const char* value);
  inline void set_remote_ip(const char* value, size_t size);
  inline ::std::string* mutable_remote_ip();
  inline ::std::string* release_remote_ip();
  inline void set_allocated_remote_ip(::std::string* remote_ip);

  // optional string referrer = 4;
  inline bool has_referrer() const;
  inline void clear_referrer();
  static const int kReferrerFieldNumber = 4;
  inline const ::std::string& referrer() const;
  inline void set_referrer(const ::std::string& value);
  inline void set_referrer(const char* value);
  inline void set_referrer(const char* value, size_t size);
  inline ::std::string* mutable_referrer();
  inline ::std::string* release_referrer();
  inline void set_allocated_referrer(::std::string* referrer);

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.ThreatHit.ThreatSource)
 private:
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_remote_ip();
  inline void clear_has_remote_ip();
  inline void set_has_referrer();
  inline void clear_has_referrer();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* url_;
  ::std::string* remote_ip_;
  ::std::string* referrer_;
  int type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_safebrowsing_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_safebrowsing_2eproto();
  #endif
  friend void protobuf_AssignDesc_safebrowsing_2eproto();
  friend void protobuf_ShutdownFile_safebrowsing_2eproto();

  void InitAsDefaultInstance();
  static ThreatHit_ThreatSource* default_instance_;
};
// -------------------------------------------------------------------

class ThreatHit : public ::google::protobuf::MessageLite {
 public:
  ThreatHit();
  virtual ~ThreatHit();

  ThreatHit(const ThreatHit& from);

  inline ThreatHit& operator=(const ThreatHit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ThreatHit& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ThreatHit* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ThreatHit* other);

  // implements Message ----------------------------------------------

  ThreatHit* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ThreatHit& from);
  void MergeFrom(const ThreatHit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ThreatHit_ThreatSource ThreatSource;

  typedef ThreatHit_ThreatSourceType ThreatSourceType;
  static const ThreatSourceType THREAT_SOURCE_TYPE_UNSPECIFIED = ThreatHit_ThreatSourceType_THREAT_SOURCE_TYPE_UNSPECIFIED;
  static const ThreatSourceType MATCHING_URL = ThreatHit_ThreatSourceType_MATCHING_URL;
  static const ThreatSourceType TAB_URL = ThreatHit_ThreatSourceType_TAB_URL;
  static const ThreatSourceType TAB_REDIRECT = ThreatHit_ThreatSourceType_TAB_REDIRECT;
  static inline bool ThreatSourceType_IsValid(int value) {
    return ThreatHit_ThreatSourceType_IsValid(value);
  }
  static const ThreatSourceType ThreatSourceType_MIN =
    ThreatHit_ThreatSourceType_ThreatSourceType_MIN;
  static const ThreatSourceType ThreatSourceType_MAX =
    ThreatHit_ThreatSourceType_ThreatSourceType_MAX;
  static const int ThreatSourceType_ARRAYSIZE =
    ThreatHit_ThreatSourceType_ThreatSourceType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
  inline bool has_threat_type() const;
  inline void clear_threat_type();
  static const int kThreatTypeFieldNumber = 1;
  inline ::mozilla::safebrowsing::ThreatType threat_type() const;
  inline void set_threat_type(::mozilla::safebrowsing::ThreatType value);

  // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
  inline bool has_platform_type() const;
  inline void clear_platform_type();
  static const int kPlatformTypeFieldNumber = 2;
  inline ::mozilla::safebrowsing::PlatformType platform_type() const;
  inline void set_platform_type(::mozilla::safebrowsing::PlatformType value);

  // optional .mozilla.safebrowsing.ThreatEntry entry = 3;
  inline bool has_entry() const;
  inline void clear_entry();
  static const int kEntryFieldNumber = 3;
  inline const ::mozilla::safebrowsing::ThreatEntry& entry() const;
  inline ::mozilla::safebrowsing::ThreatEntry* mutable_entry();
  inline ::mozilla::safebrowsing::ThreatEntry* release_entry();
  inline void set_allocated_entry(::mozilla::safebrowsing::ThreatEntry* entry);

  // repeated .mozilla.safebrowsing.ThreatHit.ThreatSource resources = 4;
  inline int resources_size() const;
  inline void clear_resources();
  static const int kResourcesFieldNumber = 4;
  inline const ::mozilla::safebrowsing::ThreatHit_ThreatSource& resources(int index) const;
  inline ::mozilla::safebrowsing::ThreatHit_ThreatSource* mutable_resources(int index);
  inline ::mozilla::safebrowsing::ThreatHit_ThreatSource* add_resources();
  inline const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatHit_ThreatSource >&
      resources() const;
  inline ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatHit_ThreatSource >*
      mutable_resources();

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.ThreatHit)
 private:
  inline void set_has_threat_type();
  inline void clear_has_threat_type();
  inline void set_has_platform_type();
  inline void clear_has_platform_type();
  inline void set_has_entry();
  inline void clear_has_entry();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int threat_type_;
  int platform_type_;
  ::mozilla::safebrowsing::ThreatEntry* entry_;
  ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatHit_ThreatSource > resources_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_safebrowsing_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_safebrowsing_2eproto();
  #endif
  friend void protobuf_AssignDesc_safebrowsing_2eproto();
  friend void protobuf_ShutdownFile_safebrowsing_2eproto();

  void InitAsDefaultInstance();
  static ThreatHit* default_instance_;
};
// -------------------------------------------------------------------

class ClientInfo : public ::google::protobuf::MessageLite {
 public:
  ClientInfo();
  virtual ~ClientInfo();

  ClientInfo(const ClientInfo& from);

  inline ClientInfo& operator=(const ClientInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ClientInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClientInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClientInfo* other);

  // implements Message ----------------------------------------------

  ClientInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientInfo& from);
  void MergeFrom(const ClientInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string client_id = 1;
  inline bool has_client_id() const;
  inline void clear_client_id();
  static const int kClientIdFieldNumber = 1;
  inline const ::std::string& client_id() const;
  inline void set_client_id(const ::std::string& value);
  inline void set_client_id(const char* value);
  inline void set_client_id(const char* value, size_t size);
  inline ::std::string* mutable_client_id();
  inline ::std::string* release_client_id();
  inline void set_allocated_client_id(::std::string* client_id);

  // optional string client_version = 2;
  inline bool has_client_version() const;
  inline void clear_client_version();
  static const int kClientVersionFieldNumber = 2;
  inline const ::std::string& client_version() const;
  inline void set_client_version(const ::std::string& value);
  inline void set_client_version(const char* value);
  inline void set_client_version(const char* value, size_t size);
  inline ::std::string* mutable_client_version();
  inline ::std::string* release_client_version();
  inline void set_allocated_client_version(::std::string* client_version);

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.ClientInfo)
 private:
  inline void set_has_client_id();
  inline void clear_has_client_id();
  inline void set_has_client_version();
  inline void clear_has_client_version();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* client_id_;
  ::std::string* client_version_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_safebrowsing_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_safebrowsing_2eproto();
  #endif
  friend void protobuf_AssignDesc_safebrowsing_2eproto();
  friend void protobuf_ShutdownFile_safebrowsing_2eproto();

  void InitAsDefaultInstance();
  static ClientInfo* default_instance_;
};
// -------------------------------------------------------------------

class Checksum : public ::google::protobuf::MessageLite {
 public:
  Checksum();
  virtual ~Checksum();

  Checksum(const Checksum& from);

  inline Checksum& operator=(const Checksum& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Checksum& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Checksum* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Checksum* other);

  // implements Message ----------------------------------------------

  Checksum* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Checksum& from);
  void MergeFrom(const Checksum& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes sha256 = 1;
  inline bool has_sha256() const;
  inline void clear_sha256();
  static const int kSha256FieldNumber = 1;
  inline const ::std::string& sha256() const;
  inline void set_sha256(const ::std::string& value);
  inline void set_sha256(const char* value);
  inline void set_sha256(const void* value, size_t size);
  inline ::std::string* mutable_sha256();
  inline ::std::string* release_sha256();
  inline void set_allocated_sha256(::std::string* sha256);

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.Checksum)
 private:
  inline void set_has_sha256();
  inline void clear_has_sha256();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* sha256_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_safebrowsing_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_safebrowsing_2eproto();
  #endif
  friend void protobuf_AssignDesc_safebrowsing_2eproto();
  friend void protobuf_ShutdownFile_safebrowsing_2eproto();

  void InitAsDefaultInstance();
  static Checksum* default_instance_;
};
// -------------------------------------------------------------------

class ThreatEntry : public ::google::protobuf::MessageLite {
 public:
  ThreatEntry();
  virtual ~ThreatEntry();

  ThreatEntry(const ThreatEntry& from);

  inline ThreatEntry& operator=(const ThreatEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ThreatEntry& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ThreatEntry* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ThreatEntry* other);

  // implements Message ----------------------------------------------

  ThreatEntry* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ThreatEntry& from);
  void MergeFrom(const ThreatEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes hash = 1;
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 1;
  inline const ::std::string& hash() const;
  inline void set_hash(const ::std::string& value);
  inline void set_hash(const char* value);
  inline void set_hash(const void* value, size_t size);
  inline ::std::string* mutable_hash();
  inline ::std::string* release_hash();
  inline void set_allocated_hash(::std::string* hash);

  // optional string url = 2;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 2;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.ThreatEntry)
 private:
  inline void set_has_hash();
  inline void clear_has_hash();
  inline void set_has_url();
  inline void clear_has_url();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* hash_;
  ::std::string* url_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_safebrowsing_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_safebrowsing_2eproto();
  #endif
  friend void protobuf_AssignDesc_safebrowsing_2eproto();
  friend void protobuf_ShutdownFile_safebrowsing_2eproto();

  void InitAsDefaultInstance();
  static ThreatEntry* default_instance_;
};
// -------------------------------------------------------------------

class ThreatEntrySet : public ::google::protobuf::MessageLite {
 public:
  ThreatEntrySet();
  virtual ~ThreatEntrySet();

  ThreatEntrySet(const ThreatEntrySet& from);

  inline ThreatEntrySet& operator=(const ThreatEntrySet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ThreatEntrySet& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ThreatEntrySet* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ThreatEntrySet* other);

  // implements Message ----------------------------------------------

  ThreatEntrySet* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ThreatEntrySet& from);
  void MergeFrom(const ThreatEntrySet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mozilla.safebrowsing.CompressionType compression_type = 1;
  inline bool has_compression_type() const;
  inline void clear_compression_type();
  static const int kCompressionTypeFieldNumber = 1;
  inline ::mozilla::safebrowsing::CompressionType compression_type() const;
  inline void set_compression_type(::mozilla::safebrowsing::CompressionType value);

  // optional .mozilla.safebrowsing.RawHashes raw_hashes = 2;
  inline bool has_raw_hashes() const;
  inline void clear_raw_hashes();
  static const int kRawHashesFieldNumber = 2;
  inline const ::mozilla::safebrowsing::RawHashes& raw_hashes() const;
  inline ::mozilla::safebrowsing::RawHashes* mutable_raw_hashes();
  inline ::mozilla::safebrowsing::RawHashes* release_raw_hashes();
  inline void set_allocated_raw_hashes(::mozilla::safebrowsing::RawHashes* raw_hashes);

  // optional .mozilla.safebrowsing.RawIndices raw_indices = 3;
  inline bool has_raw_indices() const;
  inline void clear_raw_indices();
  static const int kRawIndicesFieldNumber = 3;
  inline const ::mozilla::safebrowsing::RawIndices& raw_indices() const;
  inline ::mozilla::safebrowsing::RawIndices* mutable_raw_indices();
  inline ::mozilla::safebrowsing::RawIndices* release_raw_indices();
  inline void set_allocated_raw_indices(::mozilla::safebrowsing::RawIndices* raw_indices);

  // optional .mozilla.safebrowsing.RiceDeltaEncoding rice_hashes = 4;
  inline bool has_rice_hashes() const;
  inline void clear_rice_hashes();
  static const int kRiceHashesFieldNumber = 4;
  inline const ::mozilla::safebrowsing::RiceDeltaEncoding& rice_hashes() const;
  inline ::mozilla::safebrowsing::RiceDeltaEncoding* mutable_rice_hashes();
  inline ::mozilla::safebrowsing::RiceDeltaEncoding* release_rice_hashes();
  inline void set_allocated_rice_hashes(::mozilla::safebrowsing::RiceDeltaEncoding* rice_hashes);

  // optional .mozilla.safebrowsing.RiceDeltaEncoding rice_indices = 5;
  inline bool has_rice_indices() const;
  inline void clear_rice_indices();
  static const int kRiceIndicesFieldNumber = 5;
  inline const ::mozilla::safebrowsing::RiceDeltaEncoding& rice_indices() const;
  inline ::mozilla::safebrowsing::RiceDeltaEncoding* mutable_rice_indices();
  inline ::mozilla::safebrowsing::RiceDeltaEncoding* release_rice_indices();
  inline void set_allocated_rice_indices(::mozilla::safebrowsing::RiceDeltaEncoding* rice_indices);

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.ThreatEntrySet)
 private:
  inline void set_has_compression_type();
  inline void clear_has_compression_type();
  inline void set_has_raw_hashes();
  inline void clear_has_raw_hashes();
  inline void set_has_raw_indices();
  inline void clear_has_raw_indices();
  inline void set_has_rice_hashes();
  inline void clear_has_rice_hashes();
  inline void set_has_rice_indices();
  inline void clear_has_rice_indices();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::mozilla::safebrowsing::RawHashes* raw_hashes_;
  ::mozilla::safebrowsing::RawIndices* raw_indices_;
  ::mozilla::safebrowsing::RiceDeltaEncoding* rice_hashes_;
  ::mozilla::safebrowsing::RiceDeltaEncoding* rice_indices_;
  int compression_type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_safebrowsing_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_safebrowsing_2eproto();
  #endif
  friend void protobuf_AssignDesc_safebrowsing_2eproto();
  friend void protobuf_ShutdownFile_safebrowsing_2eproto();

  void InitAsDefaultInstance();
  static ThreatEntrySet* default_instance_;
};
// -------------------------------------------------------------------

class RawIndices : public ::google::protobuf::MessageLite {
 public:
  RawIndices();
  virtual ~RawIndices();

  RawIndices(const RawIndices& from);

  inline RawIndices& operator=(const RawIndices& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RawIndices& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RawIndices* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RawIndices* other);

  // implements Message ----------------------------------------------

  RawIndices* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RawIndices& from);
  void MergeFrom(const RawIndices& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 indices = 1;
  inline int indices_size() const;
  inline void clear_indices();
  static const int kIndicesFieldNumber = 1;
  inline ::google::protobuf::int32 indices(int index) const;
  inline void set_indices(int index, ::google::protobuf::int32 value);
  inline void add_indices(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      indices() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_indices();

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.RawIndices)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > indices_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_safebrowsing_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_safebrowsing_2eproto();
  #endif
  friend void protobuf_AssignDesc_safebrowsing_2eproto();
  friend void protobuf_ShutdownFile_safebrowsing_2eproto();

  void InitAsDefaultInstance();
  static RawIndices* default_instance_;
};
// -------------------------------------------------------------------

class RawHashes : public ::google::protobuf::MessageLite {
 public:
  RawHashes();
  virtual ~RawHashes();

  RawHashes(const RawHashes& from);

  inline RawHashes& operator=(const RawHashes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RawHashes& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RawHashes* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RawHashes* other);

  // implements Message ----------------------------------------------

  RawHashes* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RawHashes& from);
  void MergeFrom(const RawHashes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 prefix_size = 1;
  inline bool has_prefix_size() const;
  inline void clear_prefix_size();
  static const int kPrefixSizeFieldNumber = 1;
  inline ::google::protobuf::int32 prefix_size() const;
  inline void set_prefix_size(::google::protobuf::int32 value);

  // optional bytes raw_hashes = 2;
  inline bool has_raw_hashes() const;
  inline void clear_raw_hashes();
  static const int kRawHashesFieldNumber = 2;
  inline const ::std::string& raw_hashes() const;
  inline void set_raw_hashes(const ::std::string& value);
  inline void set_raw_hashes(const char* value);
  inline void set_raw_hashes(const void* value, size_t size);
  inline ::std::string* mutable_raw_hashes();
  inline ::std::string* release_raw_hashes();
  inline void set_allocated_raw_hashes(::std::string* raw_hashes);

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.RawHashes)
 private:
  inline void set_has_prefix_size();
  inline void clear_has_prefix_size();
  inline void set_has_raw_hashes();
  inline void clear_has_raw_hashes();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* raw_hashes_;
  ::google::protobuf::int32 prefix_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_safebrowsing_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_safebrowsing_2eproto();
  #endif
  friend void protobuf_AssignDesc_safebrowsing_2eproto();
  friend void protobuf_ShutdownFile_safebrowsing_2eproto();

  void InitAsDefaultInstance();
  static RawHashes* default_instance_;
};
// -------------------------------------------------------------------

class RiceDeltaEncoding : public ::google::protobuf::MessageLite {
 public:
  RiceDeltaEncoding();
  virtual ~RiceDeltaEncoding();

  RiceDeltaEncoding(const RiceDeltaEncoding& from);

  inline RiceDeltaEncoding& operator=(const RiceDeltaEncoding& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const RiceDeltaEncoding& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RiceDeltaEncoding* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RiceDeltaEncoding* other);

  // implements Message ----------------------------------------------

  RiceDeltaEncoding* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RiceDeltaEncoding& from);
  void MergeFrom(const RiceDeltaEncoding& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 first_value = 1;
  inline bool has_first_value() const;
  inline void clear_first_value();
  static const int kFirstValueFieldNumber = 1;
  inline ::google::protobuf::int64 first_value() const;
  inline void set_first_value(::google::protobuf::int64 value);

  // optional int32 rice_parameter = 2;
  inline bool has_rice_parameter() const;
  inline void clear_rice_parameter();
  static const int kRiceParameterFieldNumber = 2;
  inline ::google::protobuf::int32 rice_parameter() const;
  inline void set_rice_parameter(::google::protobuf::int32 value);

  // optional int32 num_entries = 3;
  inline bool has_num_entries() const;
  inline void clear_num_entries();
  static const int kNumEntriesFieldNumber = 3;
  inline ::google::protobuf::int32 num_entries() const;
  inline void set_num_entries(::google::protobuf::int32 value);

  // optional bytes encoded_data = 4;
  inline bool has_encoded_data() const;
  inline void clear_encoded_data();
  static const int kEncodedDataFieldNumber = 4;
  inline const ::std::string& encoded_data() const;
  inline void set_encoded_data(const ::std::string& value);
  inline void set_encoded_data(const char* value);
  inline void set_encoded_data(const void* value, size_t size);
  inline ::std::string* mutable_encoded_data();
  inline ::std::string* release_encoded_data();
  inline void set_allocated_encoded_data(::std::string* encoded_data);

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.RiceDeltaEncoding)
 private:
  inline void set_has_first_value();
  inline void clear_has_first_value();
  inline void set_has_rice_parameter();
  inline void clear_has_rice_parameter();
  inline void set_has_num_entries();
  inline void clear_has_num_entries();
  inline void set_has_encoded_data();
  inline void clear_has_encoded_data();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 first_value_;
  ::google::protobuf::int32 rice_parameter_;
  ::google::protobuf::int32 num_entries_;
  ::std::string* encoded_data_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_safebrowsing_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_safebrowsing_2eproto();
  #endif
  friend void protobuf_AssignDesc_safebrowsing_2eproto();
  friend void protobuf_ShutdownFile_safebrowsing_2eproto();

  void InitAsDefaultInstance();
  static RiceDeltaEncoding* default_instance_;
};
// -------------------------------------------------------------------

class ThreatEntryMetadata_MetadataEntry : public ::google::protobuf::MessageLite {
 public:
  ThreatEntryMetadata_MetadataEntry();
  virtual ~ThreatEntryMetadata_MetadataEntry();

  ThreatEntryMetadata_MetadataEntry(const ThreatEntryMetadata_MetadataEntry& from);

  inline ThreatEntryMetadata_MetadataEntry& operator=(const ThreatEntryMetadata_MetadataEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ThreatEntryMetadata_MetadataEntry& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ThreatEntryMetadata_MetadataEntry* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ThreatEntryMetadata_MetadataEntry* other);

  // implements Message ----------------------------------------------

  ThreatEntryMetadata_MetadataEntry* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ThreatEntryMetadata_MetadataEntry& from);
  void MergeFrom(const ThreatEntryMetadata_MetadataEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const void* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional bytes value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const void* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* key_;
  ::std::string* value_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_safebrowsing_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_safebrowsing_2eproto();
  #endif
  friend void protobuf_AssignDesc_safebrowsing_2eproto();
  friend void protobuf_ShutdownFile_safebrowsing_2eproto();

  void InitAsDefaultInstance();
  static ThreatEntryMetadata_MetadataEntry* default_instance_;
};
// -------------------------------------------------------------------

class ThreatEntryMetadata : public ::google::protobuf::MessageLite {
 public:
  ThreatEntryMetadata();
  virtual ~ThreatEntryMetadata();

  ThreatEntryMetadata(const ThreatEntryMetadata& from);

  inline ThreatEntryMetadata& operator=(const ThreatEntryMetadata& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ThreatEntryMetadata& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ThreatEntryMetadata* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ThreatEntryMetadata* other);

  // implements Message ----------------------------------------------

  ThreatEntryMetadata* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ThreatEntryMetadata& from);
  void MergeFrom(const ThreatEntryMetadata& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ThreatEntryMetadata_MetadataEntry MetadataEntry;

  // accessors -------------------------------------------------------

  // repeated .mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry entries = 1;
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 1;
  inline const ::mozilla::safebrowsing::ThreatEntryMetadata_MetadataEntry& entries(int index) const;
  inline ::mozilla::safebrowsing::ThreatEntryMetadata_MetadataEntry* mutable_entries(int index);
  inline ::mozilla::safebrowsing::ThreatEntryMetadata_MetadataEntry* add_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntryMetadata_MetadataEntry >&
      entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntryMetadata_MetadataEntry >*
      mutable_entries();

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.ThreatEntryMetadata)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntryMetadata_MetadataEntry > entries_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_safebrowsing_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_safebrowsing_2eproto();
  #endif
  friend void protobuf_AssignDesc_safebrowsing_2eproto();
  friend void protobuf_ShutdownFile_safebrowsing_2eproto();

  void InitAsDefaultInstance();
  static ThreatEntryMetadata* default_instance_;
};
// -------------------------------------------------------------------

class ThreatListDescriptor : public ::google::protobuf::MessageLite {
 public:
  ThreatListDescriptor();
  virtual ~ThreatListDescriptor();

  ThreatListDescriptor(const ThreatListDescriptor& from);

  inline ThreatListDescriptor& operator=(const ThreatListDescriptor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ThreatListDescriptor& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ThreatListDescriptor* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ThreatListDescriptor* other);

  // implements Message ----------------------------------------------

  ThreatListDescriptor* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ThreatListDescriptor& from);
  void MergeFrom(const ThreatListDescriptor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mozilla.safebrowsing.ThreatType threat_type = 1;
  inline bool has_threat_type() const;
  inline void clear_threat_type();
  static const int kThreatTypeFieldNumber = 1;
  inline ::mozilla::safebrowsing::ThreatType threat_type() const;
  inline void set_threat_type(::mozilla::safebrowsing::ThreatType value);

  // optional .mozilla.safebrowsing.PlatformType platform_type = 2;
  inline bool has_platform_type() const;
  inline void clear_platform_type();
  static const int kPlatformTypeFieldNumber = 2;
  inline ::mozilla::safebrowsing::PlatformType platform_type() const;
  inline void set_platform_type(::mozilla::safebrowsing::PlatformType value);

  // optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 3;
  inline bool has_threat_entry_type() const;
  inline void clear_threat_entry_type();
  static const int kThreatEntryTypeFieldNumber = 3;
  inline ::mozilla::safebrowsing::ThreatEntryType threat_entry_type() const;
  inline void set_threat_entry_type(::mozilla::safebrowsing::ThreatEntryType value);

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.ThreatListDescriptor)
 private:
  inline void set_has_threat_type();
  inline void clear_has_threat_type();
  inline void set_has_platform_type();
  inline void clear_has_platform_type();
  inline void set_has_threat_entry_type();
  inline void clear_has_threat_entry_type();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int threat_type_;
  int platform_type_;
  int threat_entry_type_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_safebrowsing_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_safebrowsing_2eproto();
  #endif
  friend void protobuf_AssignDesc_safebrowsing_2eproto();
  friend void protobuf_ShutdownFile_safebrowsing_2eproto();

  void InitAsDefaultInstance();
  static ThreatListDescriptor* default_instance_;
};
// -------------------------------------------------------------------

class ListThreatListsResponse : public ::google::protobuf::MessageLite {
 public:
  ListThreatListsResponse();
  virtual ~ListThreatListsResponse();

  ListThreatListsResponse(const ListThreatListsResponse& from);

  inline ListThreatListsResponse& operator=(const ListThreatListsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ListThreatListsResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ListThreatListsResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ListThreatListsResponse* other);

  // implements Message ----------------------------------------------

  ListThreatListsResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ListThreatListsResponse& from);
  void MergeFrom(const ListThreatListsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mozilla.safebrowsing.ThreatListDescriptor threat_lists = 1;
  inline int threat_lists_size() const;
  inline void clear_threat_lists();
  static const int kThreatListsFieldNumber = 1;
  inline const ::mozilla::safebrowsing::ThreatListDescriptor& threat_lists(int index) const;
  inline ::mozilla::safebrowsing::ThreatListDescriptor* mutable_threat_lists(int index);
  inline ::mozilla::safebrowsing::ThreatListDescriptor* add_threat_lists();
  inline const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatListDescriptor >&
      threat_lists() const;
  inline ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatListDescriptor >*
      mutable_threat_lists();

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.ListThreatListsResponse)
 private:

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatListDescriptor > threat_lists_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_safebrowsing_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_safebrowsing_2eproto();
  #endif
  friend void protobuf_AssignDesc_safebrowsing_2eproto();
  friend void protobuf_ShutdownFile_safebrowsing_2eproto();

  void InitAsDefaultInstance();
  static ListThreatListsResponse* default_instance_;
};
// -------------------------------------------------------------------

class Duration : public ::google::protobuf::MessageLite {
 public:
  Duration();
  virtual ~Duration();

  Duration(const Duration& from);

  inline Duration& operator=(const Duration& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::std::string& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::std::string* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Duration& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Duration* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Duration* other);

  // implements Message ----------------------------------------------

  Duration* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Duration& from);
  void MergeFrom(const Duration& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 seconds = 1;
  inline bool has_seconds() const;
  inline void clear_seconds();
  static const int kSecondsFieldNumber = 1;
  inline ::google::protobuf::int64 seconds() const;
  inline void set_seconds(::google::protobuf::int64 value);

  // optional int32 nanos = 2;
  inline bool has_nanos() const;
  inline void clear_nanos();
  static const int kNanosFieldNumber = 2;
  inline ::google::protobuf::int32 nanos() const;
  inline void set_nanos(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mozilla.safebrowsing.Duration)
 private:
  inline void set_has_seconds();
  inline void clear_has_seconds();
  inline void set_has_nanos();
  inline void clear_has_nanos();

  ::std::string _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 seconds_;
  ::google::protobuf::int32 nanos_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_safebrowsing_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_safebrowsing_2eproto();
  #endif
  friend void protobuf_AssignDesc_safebrowsing_2eproto();
  friend void protobuf_ShutdownFile_safebrowsing_2eproto();

  void InitAsDefaultInstance();
  static Duration* default_instance_;
};
// ===================================================================


// ===================================================================

// ThreatInfo

// repeated .mozilla.safebrowsing.ThreatType threat_types = 1;
inline int ThreatInfo::threat_types_size() const {
  return threat_types_.size();
}
inline void ThreatInfo::clear_threat_types() {
  threat_types_.Clear();
}
inline ::mozilla::safebrowsing::ThreatType ThreatInfo::threat_types(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatInfo.threat_types)
  return static_cast< ::mozilla::safebrowsing::ThreatType >(threat_types_.Get(index));
}
inline void ThreatInfo::set_threat_types(int index, ::mozilla::safebrowsing::ThreatType value) {
  assert(::mozilla::safebrowsing::ThreatType_IsValid(value));
  threat_types_.Set(index, value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatInfo.threat_types)
}
inline void ThreatInfo::add_threat_types(::mozilla::safebrowsing::ThreatType value) {
  assert(::mozilla::safebrowsing::ThreatType_IsValid(value));
  threat_types_.Add(value);
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.ThreatInfo.threat_types)
}
inline const ::google::protobuf::RepeatedField<int>&
ThreatInfo::threat_types() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.ThreatInfo.threat_types)
  return threat_types_;
}
inline ::google::protobuf::RepeatedField<int>*
ThreatInfo::mutable_threat_types() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.ThreatInfo.threat_types)
  return &threat_types_;
}

// repeated .mozilla.safebrowsing.PlatformType platform_types = 2;
inline int ThreatInfo::platform_types_size() const {
  return platform_types_.size();
}
inline void ThreatInfo::clear_platform_types() {
  platform_types_.Clear();
}
inline ::mozilla::safebrowsing::PlatformType ThreatInfo::platform_types(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatInfo.platform_types)
  return static_cast< ::mozilla::safebrowsing::PlatformType >(platform_types_.Get(index));
}
inline void ThreatInfo::set_platform_types(int index, ::mozilla::safebrowsing::PlatformType value) {
  assert(::mozilla::safebrowsing::PlatformType_IsValid(value));
  platform_types_.Set(index, value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatInfo.platform_types)
}
inline void ThreatInfo::add_platform_types(::mozilla::safebrowsing::PlatformType value) {
  assert(::mozilla::safebrowsing::PlatformType_IsValid(value));
  platform_types_.Add(value);
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.ThreatInfo.platform_types)
}
inline const ::google::protobuf::RepeatedField<int>&
ThreatInfo::platform_types() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.ThreatInfo.platform_types)
  return platform_types_;
}
inline ::google::protobuf::RepeatedField<int>*
ThreatInfo::mutable_platform_types() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.ThreatInfo.platform_types)
  return &platform_types_;
}

// repeated .mozilla.safebrowsing.ThreatEntryType threat_entry_types = 4;
inline int ThreatInfo::threat_entry_types_size() const {
  return threat_entry_types_.size();
}
inline void ThreatInfo::clear_threat_entry_types() {
  threat_entry_types_.Clear();
}
inline ::mozilla::safebrowsing::ThreatEntryType ThreatInfo::threat_entry_types(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatInfo.threat_entry_types)
  return static_cast< ::mozilla::safebrowsing::ThreatEntryType >(threat_entry_types_.Get(index));
}
inline void ThreatInfo::set_threat_entry_types(int index, ::mozilla::safebrowsing::ThreatEntryType value) {
  assert(::mozilla::safebrowsing::ThreatEntryType_IsValid(value));
  threat_entry_types_.Set(index, value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatInfo.threat_entry_types)
}
inline void ThreatInfo::add_threat_entry_types(::mozilla::safebrowsing::ThreatEntryType value) {
  assert(::mozilla::safebrowsing::ThreatEntryType_IsValid(value));
  threat_entry_types_.Add(value);
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.ThreatInfo.threat_entry_types)
}
inline const ::google::protobuf::RepeatedField<int>&
ThreatInfo::threat_entry_types() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.ThreatInfo.threat_entry_types)
  return threat_entry_types_;
}
inline ::google::protobuf::RepeatedField<int>*
ThreatInfo::mutable_threat_entry_types() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.ThreatInfo.threat_entry_types)
  return &threat_entry_types_;
}

// repeated .mozilla.safebrowsing.ThreatEntry threat_entries = 3;
inline int ThreatInfo::threat_entries_size() const {
  return threat_entries_.size();
}
inline void ThreatInfo::clear_threat_entries() {
  threat_entries_.Clear();
}
inline const ::mozilla::safebrowsing::ThreatEntry& ThreatInfo::threat_entries(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatInfo.threat_entries)
  return threat_entries_.Get(index);
}
inline ::mozilla::safebrowsing::ThreatEntry* ThreatInfo::mutable_threat_entries(int index) {
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatInfo.threat_entries)
  return threat_entries_.Mutable(index);
}
inline ::mozilla::safebrowsing::ThreatEntry* ThreatInfo::add_threat_entries() {
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.ThreatInfo.threat_entries)
  return threat_entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntry >&
ThreatInfo::threat_entries() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.ThreatInfo.threat_entries)
  return threat_entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntry >*
ThreatInfo::mutable_threat_entries() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.ThreatInfo.threat_entries)
  return &threat_entries_;
}

// -------------------------------------------------------------------

// ThreatMatch

// optional .mozilla.safebrowsing.ThreatType threat_type = 1;
inline bool ThreatMatch::has_threat_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ThreatMatch::set_has_threat_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ThreatMatch::clear_has_threat_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ThreatMatch::clear_threat_type() {
  threat_type_ = 0;
  clear_has_threat_type();
}
inline ::mozilla::safebrowsing::ThreatType ThreatMatch::threat_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatMatch.threat_type)
  return static_cast< ::mozilla::safebrowsing::ThreatType >(threat_type_);
}
inline void ThreatMatch::set_threat_type(::mozilla::safebrowsing::ThreatType value) {
  assert(::mozilla::safebrowsing::ThreatType_IsValid(value));
  set_has_threat_type();
  threat_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatMatch.threat_type)
}

// optional .mozilla.safebrowsing.PlatformType platform_type = 2;
inline bool ThreatMatch::has_platform_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ThreatMatch::set_has_platform_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ThreatMatch::clear_has_platform_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ThreatMatch::clear_platform_type() {
  platform_type_ = 0;
  clear_has_platform_type();
}
inline ::mozilla::safebrowsing::PlatformType ThreatMatch::platform_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatMatch.platform_type)
  return static_cast< ::mozilla::safebrowsing::PlatformType >(platform_type_);
}
inline void ThreatMatch::set_platform_type(::mozilla::safebrowsing::PlatformType value) {
  assert(::mozilla::safebrowsing::PlatformType_IsValid(value));
  set_has_platform_type();
  platform_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatMatch.platform_type)
}

// optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 6;
inline bool ThreatMatch::has_threat_entry_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ThreatMatch::set_has_threat_entry_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ThreatMatch::clear_has_threat_entry_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ThreatMatch::clear_threat_entry_type() {
  threat_entry_type_ = 0;
  clear_has_threat_entry_type();
}
inline ::mozilla::safebrowsing::ThreatEntryType ThreatMatch::threat_entry_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatMatch.threat_entry_type)
  return static_cast< ::mozilla::safebrowsing::ThreatEntryType >(threat_entry_type_);
}
inline void ThreatMatch::set_threat_entry_type(::mozilla::safebrowsing::ThreatEntryType value) {
  assert(::mozilla::safebrowsing::ThreatEntryType_IsValid(value));
  set_has_threat_entry_type();
  threat_entry_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatMatch.threat_entry_type)
}

// optional .mozilla.safebrowsing.ThreatEntry threat = 3;
inline bool ThreatMatch::has_threat() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ThreatMatch::set_has_threat() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ThreatMatch::clear_has_threat() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ThreatMatch::clear_threat() {
  if (threat_ != NULL) threat_->::mozilla::safebrowsing::ThreatEntry::Clear();
  clear_has_threat();
}
inline const ::mozilla::safebrowsing::ThreatEntry& ThreatMatch::threat() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatMatch.threat)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return threat_ != NULL ? *threat_ : *default_instance().threat_;
#else
  return threat_ != NULL ? *threat_ : *default_instance_->threat_;
#endif
}
inline ::mozilla::safebrowsing::ThreatEntry* ThreatMatch::mutable_threat() {
  set_has_threat();
  if (threat_ == NULL) threat_ = new ::mozilla::safebrowsing::ThreatEntry;
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatMatch.threat)
  return threat_;
}
inline ::mozilla::safebrowsing::ThreatEntry* ThreatMatch::release_threat() {
  clear_has_threat();
  ::mozilla::safebrowsing::ThreatEntry* temp = threat_;
  threat_ = NULL;
  return temp;
}
inline void ThreatMatch::set_allocated_threat(::mozilla::safebrowsing::ThreatEntry* threat) {
  delete threat_;
  threat_ = threat;
  if (threat) {
    set_has_threat();
  } else {
    clear_has_threat();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatMatch.threat)
}

// optional .mozilla.safebrowsing.ThreatEntryMetadata threat_entry_metadata = 4;
inline bool ThreatMatch::has_threat_entry_metadata() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ThreatMatch::set_has_threat_entry_metadata() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ThreatMatch::clear_has_threat_entry_metadata() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ThreatMatch::clear_threat_entry_metadata() {
  if (threat_entry_metadata_ != NULL) threat_entry_metadata_->::mozilla::safebrowsing::ThreatEntryMetadata::Clear();
  clear_has_threat_entry_metadata();
}
inline const ::mozilla::safebrowsing::ThreatEntryMetadata& ThreatMatch::threat_entry_metadata() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatMatch.threat_entry_metadata)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return threat_entry_metadata_ != NULL ? *threat_entry_metadata_ : *default_instance().threat_entry_metadata_;
#else
  return threat_entry_metadata_ != NULL ? *threat_entry_metadata_ : *default_instance_->threat_entry_metadata_;
#endif
}
inline ::mozilla::safebrowsing::ThreatEntryMetadata* ThreatMatch::mutable_threat_entry_metadata() {
  set_has_threat_entry_metadata();
  if (threat_entry_metadata_ == NULL) threat_entry_metadata_ = new ::mozilla::safebrowsing::ThreatEntryMetadata;
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatMatch.threat_entry_metadata)
  return threat_entry_metadata_;
}
inline ::mozilla::safebrowsing::ThreatEntryMetadata* ThreatMatch::release_threat_entry_metadata() {
  clear_has_threat_entry_metadata();
  ::mozilla::safebrowsing::ThreatEntryMetadata* temp = threat_entry_metadata_;
  threat_entry_metadata_ = NULL;
  return temp;
}
inline void ThreatMatch::set_allocated_threat_entry_metadata(::mozilla::safebrowsing::ThreatEntryMetadata* threat_entry_metadata) {
  delete threat_entry_metadata_;
  threat_entry_metadata_ = threat_entry_metadata;
  if (threat_entry_metadata) {
    set_has_threat_entry_metadata();
  } else {
    clear_has_threat_entry_metadata();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatMatch.threat_entry_metadata)
}

// optional .mozilla.safebrowsing.Duration cache_duration = 5;
inline bool ThreatMatch::has_cache_duration() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ThreatMatch::set_has_cache_duration() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ThreatMatch::clear_has_cache_duration() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ThreatMatch::clear_cache_duration() {
  if (cache_duration_ != NULL) cache_duration_->::mozilla::safebrowsing::Duration::Clear();
  clear_has_cache_duration();
}
inline const ::mozilla::safebrowsing::Duration& ThreatMatch::cache_duration() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatMatch.cache_duration)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return cache_duration_ != NULL ? *cache_duration_ : *default_instance().cache_duration_;
#else
  return cache_duration_ != NULL ? *cache_duration_ : *default_instance_->cache_duration_;
#endif
}
inline ::mozilla::safebrowsing::Duration* ThreatMatch::mutable_cache_duration() {
  set_has_cache_duration();
  if (cache_duration_ == NULL) cache_duration_ = new ::mozilla::safebrowsing::Duration;
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatMatch.cache_duration)
  return cache_duration_;
}
inline ::mozilla::safebrowsing::Duration* ThreatMatch::release_cache_duration() {
  clear_has_cache_duration();
  ::mozilla::safebrowsing::Duration* temp = cache_duration_;
  cache_duration_ = NULL;
  return temp;
}
inline void ThreatMatch::set_allocated_cache_duration(::mozilla::safebrowsing::Duration* cache_duration) {
  delete cache_duration_;
  cache_duration_ = cache_duration;
  if (cache_duration) {
    set_has_cache_duration();
  } else {
    clear_has_cache_duration();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatMatch.cache_duration)
}

// -------------------------------------------------------------------

// FindThreatMatchesRequest

// optional .mozilla.safebrowsing.ClientInfo client = 1;
inline bool FindThreatMatchesRequest::has_client() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FindThreatMatchesRequest::set_has_client() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FindThreatMatchesRequest::clear_has_client() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FindThreatMatchesRequest::clear_client() {
  if (client_ != NULL) client_->::mozilla::safebrowsing::ClientInfo::Clear();
  clear_has_client();
}
inline const ::mozilla::safebrowsing::ClientInfo& FindThreatMatchesRequest::client() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FindThreatMatchesRequest.client)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return client_ != NULL ? *client_ : *default_instance().client_;
#else
  return client_ != NULL ? *client_ : *default_instance_->client_;
#endif
}
inline ::mozilla::safebrowsing::ClientInfo* FindThreatMatchesRequest::mutable_client() {
  set_has_client();
  if (client_ == NULL) client_ = new ::mozilla::safebrowsing::ClientInfo;
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FindThreatMatchesRequest.client)
  return client_;
}
inline ::mozilla::safebrowsing::ClientInfo* FindThreatMatchesRequest::release_client() {
  clear_has_client();
  ::mozilla::safebrowsing::ClientInfo* temp = client_;
  client_ = NULL;
  return temp;
}
inline void FindThreatMatchesRequest::set_allocated_client(::mozilla::safebrowsing::ClientInfo* client) {
  delete client_;
  client_ = client;
  if (client) {
    set_has_client();
  } else {
    clear_has_client();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.FindThreatMatchesRequest.client)
}

// optional .mozilla.safebrowsing.ThreatInfo threat_info = 2;
inline bool FindThreatMatchesRequest::has_threat_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FindThreatMatchesRequest::set_has_threat_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FindThreatMatchesRequest::clear_has_threat_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FindThreatMatchesRequest::clear_threat_info() {
  if (threat_info_ != NULL) threat_info_->::mozilla::safebrowsing::ThreatInfo::Clear();
  clear_has_threat_info();
}
inline const ::mozilla::safebrowsing::ThreatInfo& FindThreatMatchesRequest::threat_info() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FindThreatMatchesRequest.threat_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return threat_info_ != NULL ? *threat_info_ : *default_instance().threat_info_;
#else
  return threat_info_ != NULL ? *threat_info_ : *default_instance_->threat_info_;
#endif
}
inline ::mozilla::safebrowsing::ThreatInfo* FindThreatMatchesRequest::mutable_threat_info() {
  set_has_threat_info();
  if (threat_info_ == NULL) threat_info_ = new ::mozilla::safebrowsing::ThreatInfo;
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FindThreatMatchesRequest.threat_info)
  return threat_info_;
}
inline ::mozilla::safebrowsing::ThreatInfo* FindThreatMatchesRequest::release_threat_info() {
  clear_has_threat_info();
  ::mozilla::safebrowsing::ThreatInfo* temp = threat_info_;
  threat_info_ = NULL;
  return temp;
}
inline void FindThreatMatchesRequest::set_allocated_threat_info(::mozilla::safebrowsing::ThreatInfo* threat_info) {
  delete threat_info_;
  threat_info_ = threat_info;
  if (threat_info) {
    set_has_threat_info();
  } else {
    clear_has_threat_info();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.FindThreatMatchesRequest.threat_info)
}

// -------------------------------------------------------------------

// FindThreatMatchesResponse

// repeated .mozilla.safebrowsing.ThreatMatch matches = 1;
inline int FindThreatMatchesResponse::matches_size() const {
  return matches_.size();
}
inline void FindThreatMatchesResponse::clear_matches() {
  matches_.Clear();
}
inline const ::mozilla::safebrowsing::ThreatMatch& FindThreatMatchesResponse::matches(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FindThreatMatchesResponse.matches)
  return matches_.Get(index);
}
inline ::mozilla::safebrowsing::ThreatMatch* FindThreatMatchesResponse::mutable_matches(int index) {
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FindThreatMatchesResponse.matches)
  return matches_.Mutable(index);
}
inline ::mozilla::safebrowsing::ThreatMatch* FindThreatMatchesResponse::add_matches() {
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.FindThreatMatchesResponse.matches)
  return matches_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatMatch >&
FindThreatMatchesResponse::matches() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.FindThreatMatchesResponse.matches)
  return matches_;
}
inline ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatMatch >*
FindThreatMatchesResponse::mutable_matches() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.FindThreatMatchesResponse.matches)
  return &matches_;
}

// -------------------------------------------------------------------

// FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints

// optional int32 max_update_entries = 1;
inline bool FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::has_max_update_entries() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_has_max_update_entries() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::clear_has_max_update_entries() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::clear_max_update_entries() {
  max_update_entries_ = 0;
  clear_has_max_update_entries();
}
inline ::google::protobuf::int32 FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::max_update_entries() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.max_update_entries)
  return max_update_entries_;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_max_update_entries(::google::protobuf::int32 value) {
  set_has_max_update_entries();
  max_update_entries_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.max_update_entries)
}

// optional int32 max_database_entries = 2;
inline bool FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::has_max_database_entries() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_has_max_database_entries() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::clear_has_max_database_entries() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::clear_max_database_entries() {
  max_database_entries_ = 0;
  clear_has_max_database_entries();
}
inline ::google::protobuf::int32 FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::max_database_entries() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.max_database_entries)
  return max_database_entries_;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_max_database_entries(::google::protobuf::int32 value) {
  set_has_max_database_entries();
  max_database_entries_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.max_database_entries)
}

// optional string region = 3;
inline bool FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::has_region() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_has_region() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::clear_has_region() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::clear_region() {
  if (region_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    region_->clear();
  }
  clear_has_region();
}
inline const ::std::string& FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::region() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.region)
  return *region_;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_region(const ::std::string& value) {
  set_has_region();
  if (region_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    region_ = new ::std::string;
  }
  region_->assign(value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.region)
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_region(const char* value) {
  set_has_region();
  if (region_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    region_ = new ::std::string;
  }
  region_->assign(value);
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.region)
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_region(const char* value, size_t size) {
  set_has_region();
  if (region_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    region_ = new ::std::string;
  }
  region_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.region)
}
inline ::std::string* FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::mutable_region() {
  set_has_region();
  if (region_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    region_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.region)
  return region_;
}
inline ::std::string* FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::release_region() {
  clear_has_region();
  if (region_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = region_;
    region_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_allocated_region(::std::string* region) {
  if (region_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete region_;
  }
  if (region) {
    set_has_region();
    region_ = region;
  } else {
    clear_has_region();
    region_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.region)
}

// repeated .mozilla.safebrowsing.CompressionType supported_compressions = 4;
inline int FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::supported_compressions_size() const {
  return supported_compressions_.size();
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::clear_supported_compressions() {
  supported_compressions_.Clear();
}
inline ::mozilla::safebrowsing::CompressionType FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::supported_compressions(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.supported_compressions)
  return static_cast< ::mozilla::safebrowsing::CompressionType >(supported_compressions_.Get(index));
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::set_supported_compressions(int index, ::mozilla::safebrowsing::CompressionType value) {
  assert(::mozilla::safebrowsing::CompressionType_IsValid(value));
  supported_compressions_.Set(index, value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.supported_compressions)
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::add_supported_compressions(::mozilla::safebrowsing::CompressionType value) {
  assert(::mozilla::safebrowsing::CompressionType_IsValid(value));
  supported_compressions_.Add(value);
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.supported_compressions)
}
inline const ::google::protobuf::RepeatedField<int>&
FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::supported_compressions() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.supported_compressions)
  return supported_compressions_;
}
inline ::google::protobuf::RepeatedField<int>*
FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::mutable_supported_compressions() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.supported_compressions)
  return &supported_compressions_;
}

// -------------------------------------------------------------------

// FetchThreatListUpdatesRequest_ListUpdateRequest

// optional .mozilla.safebrowsing.ThreatType threat_type = 1;
inline bool FetchThreatListUpdatesRequest_ListUpdateRequest::has_threat_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::set_has_threat_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_has_threat_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_threat_type() {
  threat_type_ = 0;
  clear_has_threat_type();
}
inline ::mozilla::safebrowsing::ThreatType FetchThreatListUpdatesRequest_ListUpdateRequest::threat_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.threat_type)
  return static_cast< ::mozilla::safebrowsing::ThreatType >(threat_type_);
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::set_threat_type(::mozilla::safebrowsing::ThreatType value) {
  assert(::mozilla::safebrowsing::ThreatType_IsValid(value));
  set_has_threat_type();
  threat_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.threat_type)
}

// optional .mozilla.safebrowsing.PlatformType platform_type = 2;
inline bool FetchThreatListUpdatesRequest_ListUpdateRequest::has_platform_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::set_has_platform_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_has_platform_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_platform_type() {
  platform_type_ = 0;
  clear_has_platform_type();
}
inline ::mozilla::safebrowsing::PlatformType FetchThreatListUpdatesRequest_ListUpdateRequest::platform_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.platform_type)
  return static_cast< ::mozilla::safebrowsing::PlatformType >(platform_type_);
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::set_platform_type(::mozilla::safebrowsing::PlatformType value) {
  assert(::mozilla::safebrowsing::PlatformType_IsValid(value));
  set_has_platform_type();
  platform_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.platform_type)
}

// optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 5;
inline bool FetchThreatListUpdatesRequest_ListUpdateRequest::has_threat_entry_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::set_has_threat_entry_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_has_threat_entry_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_threat_entry_type() {
  threat_entry_type_ = 0;
  clear_has_threat_entry_type();
}
inline ::mozilla::safebrowsing::ThreatEntryType FetchThreatListUpdatesRequest_ListUpdateRequest::threat_entry_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.threat_entry_type)
  return static_cast< ::mozilla::safebrowsing::ThreatEntryType >(threat_entry_type_);
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::set_threat_entry_type(::mozilla::safebrowsing::ThreatEntryType value) {
  assert(::mozilla::safebrowsing::ThreatEntryType_IsValid(value));
  set_has_threat_entry_type();
  threat_entry_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.threat_entry_type)
}

// optional bytes state = 3;
inline bool FetchThreatListUpdatesRequest_ListUpdateRequest::has_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::set_has_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_has_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_state() {
  if (state_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    state_->clear();
  }
  clear_has_state();
}
inline const ::std::string& FetchThreatListUpdatesRequest_ListUpdateRequest::state() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.state)
  return *state_;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::set_state(const ::std::string& value) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    state_ = new ::std::string;
  }
  state_->assign(value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.state)
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::set_state(const char* value) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    state_ = new ::std::string;
  }
  state_->assign(value);
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.state)
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::set_state(const void* value, size_t size) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    state_ = new ::std::string;
  }
  state_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.state)
}
inline ::std::string* FetchThreatListUpdatesRequest_ListUpdateRequest::mutable_state() {
  set_has_state();
  if (state_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    state_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.state)
  return state_;
}
inline ::std::string* FetchThreatListUpdatesRequest_ListUpdateRequest::release_state() {
  clear_has_state();
  if (state_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = state_;
    state_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::set_allocated_state(::std::string* state) {
  if (state_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete state_;
  }
  if (state) {
    set_has_state();
    state_ = state;
  } else {
    clear_has_state();
    state_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.state)
}

// optional .mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints constraints = 4;
inline bool FetchThreatListUpdatesRequest_ListUpdateRequest::has_constraints() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::set_has_constraints() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_has_constraints() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::clear_constraints() {
  if (constraints_ != NULL) constraints_->::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints::Clear();
  clear_has_constraints();
}
inline const ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints& FetchThreatListUpdatesRequest_ListUpdateRequest::constraints() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.constraints)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return constraints_ != NULL ? *constraints_ : *default_instance().constraints_;
#else
  return constraints_ != NULL ? *constraints_ : *default_instance_->constraints_;
#endif
}
inline ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* FetchThreatListUpdatesRequest_ListUpdateRequest::mutable_constraints() {
  set_has_constraints();
  if (constraints_ == NULL) constraints_ = new ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints;
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.constraints)
  return constraints_;
}
inline ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* FetchThreatListUpdatesRequest_ListUpdateRequest::release_constraints() {
  clear_has_constraints();
  ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* temp = constraints_;
  constraints_ = NULL;
  return temp;
}
inline void FetchThreatListUpdatesRequest_ListUpdateRequest::set_allocated_constraints(::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints* constraints) {
  delete constraints_;
  constraints_ = constraints;
  if (constraints) {
    set_has_constraints();
  } else {
    clear_has_constraints();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.constraints)
}

// -------------------------------------------------------------------

// FetchThreatListUpdatesRequest

// optional .mozilla.safebrowsing.ClientInfo client = 1;
inline bool FetchThreatListUpdatesRequest::has_client() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FetchThreatListUpdatesRequest::set_has_client() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FetchThreatListUpdatesRequest::clear_has_client() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FetchThreatListUpdatesRequest::clear_client() {
  if (client_ != NULL) client_->::mozilla::safebrowsing::ClientInfo::Clear();
  clear_has_client();
}
inline const ::mozilla::safebrowsing::ClientInfo& FetchThreatListUpdatesRequest::client() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesRequest.client)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return client_ != NULL ? *client_ : *default_instance().client_;
#else
  return client_ != NULL ? *client_ : *default_instance_->client_;
#endif
}
inline ::mozilla::safebrowsing::ClientInfo* FetchThreatListUpdatesRequest::mutable_client() {
  set_has_client();
  if (client_ == NULL) client_ = new ::mozilla::safebrowsing::ClientInfo;
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FetchThreatListUpdatesRequest.client)
  return client_;
}
inline ::mozilla::safebrowsing::ClientInfo* FetchThreatListUpdatesRequest::release_client() {
  clear_has_client();
  ::mozilla::safebrowsing::ClientInfo* temp = client_;
  client_ = NULL;
  return temp;
}
inline void FetchThreatListUpdatesRequest::set_allocated_client(::mozilla::safebrowsing::ClientInfo* client) {
  delete client_;
  client_ = client;
  if (client) {
    set_has_client();
  } else {
    clear_has_client();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.FetchThreatListUpdatesRequest.client)
}

// repeated .mozilla.safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest list_update_requests = 3;
inline int FetchThreatListUpdatesRequest::list_update_requests_size() const {
  return list_update_requests_.size();
}
inline void FetchThreatListUpdatesRequest::clear_list_update_requests() {
  list_update_requests_.Clear();
}
inline const ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest& FetchThreatListUpdatesRequest::list_update_requests(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesRequest.list_update_requests)
  return list_update_requests_.Get(index);
}
inline ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest* FetchThreatListUpdatesRequest::mutable_list_update_requests(int index) {
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FetchThreatListUpdatesRequest.list_update_requests)
  return list_update_requests_.Mutable(index);
}
inline ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest* FetchThreatListUpdatesRequest::add_list_update_requests() {
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.FetchThreatListUpdatesRequest.list_update_requests)
  return list_update_requests_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest >&
FetchThreatListUpdatesRequest::list_update_requests() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.FetchThreatListUpdatesRequest.list_update_requests)
  return list_update_requests_;
}
inline ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::FetchThreatListUpdatesRequest_ListUpdateRequest >*
FetchThreatListUpdatesRequest::mutable_list_update_requests() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.FetchThreatListUpdatesRequest.list_update_requests)
  return &list_update_requests_;
}

// -------------------------------------------------------------------

// FetchThreatListUpdatesResponse_ListUpdateResponse

// optional .mozilla.safebrowsing.ThreatType threat_type = 1;
inline bool FetchThreatListUpdatesResponse_ListUpdateResponse::has_threat_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_has_threat_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_has_threat_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_threat_type() {
  threat_type_ = 0;
  clear_has_threat_type();
}
inline ::mozilla::safebrowsing::ThreatType FetchThreatListUpdatesResponse_ListUpdateResponse::threat_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.threat_type)
  return static_cast< ::mozilla::safebrowsing::ThreatType >(threat_type_);
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_threat_type(::mozilla::safebrowsing::ThreatType value) {
  assert(::mozilla::safebrowsing::ThreatType_IsValid(value));
  set_has_threat_type();
  threat_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.threat_type)
}

// optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 2;
inline bool FetchThreatListUpdatesResponse_ListUpdateResponse::has_threat_entry_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_has_threat_entry_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_has_threat_entry_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_threat_entry_type() {
  threat_entry_type_ = 0;
  clear_has_threat_entry_type();
}
inline ::mozilla::safebrowsing::ThreatEntryType FetchThreatListUpdatesResponse_ListUpdateResponse::threat_entry_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.threat_entry_type)
  return static_cast< ::mozilla::safebrowsing::ThreatEntryType >(threat_entry_type_);
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_threat_entry_type(::mozilla::safebrowsing::ThreatEntryType value) {
  assert(::mozilla::safebrowsing::ThreatEntryType_IsValid(value));
  set_has_threat_entry_type();
  threat_entry_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.threat_entry_type)
}

// optional .mozilla.safebrowsing.PlatformType platform_type = 3;
inline bool FetchThreatListUpdatesResponse_ListUpdateResponse::has_platform_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_has_platform_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_has_platform_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_platform_type() {
  platform_type_ = 0;
  clear_has_platform_type();
}
inline ::mozilla::safebrowsing::PlatformType FetchThreatListUpdatesResponse_ListUpdateResponse::platform_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.platform_type)
  return static_cast< ::mozilla::safebrowsing::PlatformType >(platform_type_);
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_platform_type(::mozilla::safebrowsing::PlatformType value) {
  assert(::mozilla::safebrowsing::PlatformType_IsValid(value));
  set_has_platform_type();
  platform_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.platform_type)
}

// optional .mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.ResponseType response_type = 4;
inline bool FetchThreatListUpdatesResponse_ListUpdateResponse::has_response_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_has_response_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_has_response_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_response_type() {
  response_type_ = 0;
  clear_has_response_type();
}
inline ::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType FetchThreatListUpdatesResponse_ListUpdateResponse::response_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.response_type)
  return static_cast< ::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType >(response_type_);
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_response_type(::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType value) {
  assert(::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_IsValid(value));
  set_has_response_type();
  response_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.response_type)
}

// repeated .mozilla.safebrowsing.ThreatEntrySet additions = 5;
inline int FetchThreatListUpdatesResponse_ListUpdateResponse::additions_size() const {
  return additions_.size();
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_additions() {
  additions_.Clear();
}
inline const ::mozilla::safebrowsing::ThreatEntrySet& FetchThreatListUpdatesResponse_ListUpdateResponse::additions(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.additions)
  return additions_.Get(index);
}
inline ::mozilla::safebrowsing::ThreatEntrySet* FetchThreatListUpdatesResponse_ListUpdateResponse::mutable_additions(int index) {
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.additions)
  return additions_.Mutable(index);
}
inline ::mozilla::safebrowsing::ThreatEntrySet* FetchThreatListUpdatesResponse_ListUpdateResponse::add_additions() {
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.additions)
  return additions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntrySet >&
FetchThreatListUpdatesResponse_ListUpdateResponse::additions() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.additions)
  return additions_;
}
inline ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntrySet >*
FetchThreatListUpdatesResponse_ListUpdateResponse::mutable_additions() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.additions)
  return &additions_;
}

// repeated .mozilla.safebrowsing.ThreatEntrySet removals = 6;
inline int FetchThreatListUpdatesResponse_ListUpdateResponse::removals_size() const {
  return removals_.size();
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_removals() {
  removals_.Clear();
}
inline const ::mozilla::safebrowsing::ThreatEntrySet& FetchThreatListUpdatesResponse_ListUpdateResponse::removals(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.removals)
  return removals_.Get(index);
}
inline ::mozilla::safebrowsing::ThreatEntrySet* FetchThreatListUpdatesResponse_ListUpdateResponse::mutable_removals(int index) {
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.removals)
  return removals_.Mutable(index);
}
inline ::mozilla::safebrowsing::ThreatEntrySet* FetchThreatListUpdatesResponse_ListUpdateResponse::add_removals() {
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.removals)
  return removals_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntrySet >&
FetchThreatListUpdatesResponse_ListUpdateResponse::removals() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.removals)
  return removals_;
}
inline ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntrySet >*
FetchThreatListUpdatesResponse_ListUpdateResponse::mutable_removals() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.removals)
  return &removals_;
}

// optional bytes new_client_state = 7;
inline bool FetchThreatListUpdatesResponse_ListUpdateResponse::has_new_client_state() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_has_new_client_state() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_has_new_client_state() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_new_client_state() {
  if (new_client_state_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    new_client_state_->clear();
  }
  clear_has_new_client_state();
}
inline const ::std::string& FetchThreatListUpdatesResponse_ListUpdateResponse::new_client_state() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.new_client_state)
  return *new_client_state_;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_new_client_state(const ::std::string& value) {
  set_has_new_client_state();
  if (new_client_state_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    new_client_state_ = new ::std::string;
  }
  new_client_state_->assign(value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.new_client_state)
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_new_client_state(const char* value) {
  set_has_new_client_state();
  if (new_client_state_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    new_client_state_ = new ::std::string;
  }
  new_client_state_->assign(value);
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.new_client_state)
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_new_client_state(const void* value, size_t size) {
  set_has_new_client_state();
  if (new_client_state_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    new_client_state_ = new ::std::string;
  }
  new_client_state_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.new_client_state)
}
inline ::std::string* FetchThreatListUpdatesResponse_ListUpdateResponse::mutable_new_client_state() {
  set_has_new_client_state();
  if (new_client_state_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    new_client_state_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.new_client_state)
  return new_client_state_;
}
inline ::std::string* FetchThreatListUpdatesResponse_ListUpdateResponse::release_new_client_state() {
  clear_has_new_client_state();
  if (new_client_state_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = new_client_state_;
    new_client_state_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_allocated_new_client_state(::std::string* new_client_state) {
  if (new_client_state_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete new_client_state_;
  }
  if (new_client_state) {
    set_has_new_client_state();
    new_client_state_ = new_client_state;
  } else {
    clear_has_new_client_state();
    new_client_state_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.new_client_state)
}

// optional .mozilla.safebrowsing.Checksum checksum = 8;
inline bool FetchThreatListUpdatesResponse_ListUpdateResponse::has_checksum() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_has_checksum() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_has_checksum() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::clear_checksum() {
  if (checksum_ != NULL) checksum_->::mozilla::safebrowsing::Checksum::Clear();
  clear_has_checksum();
}
inline const ::mozilla::safebrowsing::Checksum& FetchThreatListUpdatesResponse_ListUpdateResponse::checksum() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.checksum)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return checksum_ != NULL ? *checksum_ : *default_instance().checksum_;
#else
  return checksum_ != NULL ? *checksum_ : *default_instance_->checksum_;
#endif
}
inline ::mozilla::safebrowsing::Checksum* FetchThreatListUpdatesResponse_ListUpdateResponse::mutable_checksum() {
  set_has_checksum();
  if (checksum_ == NULL) checksum_ = new ::mozilla::safebrowsing::Checksum;
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.checksum)
  return checksum_;
}
inline ::mozilla::safebrowsing::Checksum* FetchThreatListUpdatesResponse_ListUpdateResponse::release_checksum() {
  clear_has_checksum();
  ::mozilla::safebrowsing::Checksum* temp = checksum_;
  checksum_ = NULL;
  return temp;
}
inline void FetchThreatListUpdatesResponse_ListUpdateResponse::set_allocated_checksum(::mozilla::safebrowsing::Checksum* checksum) {
  delete checksum_;
  checksum_ = checksum;
  if (checksum) {
    set_has_checksum();
  } else {
    clear_has_checksum();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse.checksum)
}

// -------------------------------------------------------------------

// FetchThreatListUpdatesResponse

// repeated .mozilla.safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse list_update_responses = 1;
inline int FetchThreatListUpdatesResponse::list_update_responses_size() const {
  return list_update_responses_.size();
}
inline void FetchThreatListUpdatesResponse::clear_list_update_responses() {
  list_update_responses_.Clear();
}
inline const ::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse& FetchThreatListUpdatesResponse::list_update_responses(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesResponse.list_update_responses)
  return list_update_responses_.Get(index);
}
inline ::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse* FetchThreatListUpdatesResponse::mutable_list_update_responses(int index) {
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FetchThreatListUpdatesResponse.list_update_responses)
  return list_update_responses_.Mutable(index);
}
inline ::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse* FetchThreatListUpdatesResponse::add_list_update_responses() {
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.FetchThreatListUpdatesResponse.list_update_responses)
  return list_update_responses_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse >&
FetchThreatListUpdatesResponse::list_update_responses() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.FetchThreatListUpdatesResponse.list_update_responses)
  return list_update_responses_;
}
inline ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::FetchThreatListUpdatesResponse_ListUpdateResponse >*
FetchThreatListUpdatesResponse::mutable_list_update_responses() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.FetchThreatListUpdatesResponse.list_update_responses)
  return &list_update_responses_;
}

// optional .mozilla.safebrowsing.Duration minimum_wait_duration = 2;
inline bool FetchThreatListUpdatesResponse::has_minimum_wait_duration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FetchThreatListUpdatesResponse::set_has_minimum_wait_duration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FetchThreatListUpdatesResponse::clear_has_minimum_wait_duration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FetchThreatListUpdatesResponse::clear_minimum_wait_duration() {
  if (minimum_wait_duration_ != NULL) minimum_wait_duration_->::mozilla::safebrowsing::Duration::Clear();
  clear_has_minimum_wait_duration();
}
inline const ::mozilla::safebrowsing::Duration& FetchThreatListUpdatesResponse::minimum_wait_duration() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FetchThreatListUpdatesResponse.minimum_wait_duration)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return minimum_wait_duration_ != NULL ? *minimum_wait_duration_ : *default_instance().minimum_wait_duration_;
#else
  return minimum_wait_duration_ != NULL ? *minimum_wait_duration_ : *default_instance_->minimum_wait_duration_;
#endif
}
inline ::mozilla::safebrowsing::Duration* FetchThreatListUpdatesResponse::mutable_minimum_wait_duration() {
  set_has_minimum_wait_duration();
  if (minimum_wait_duration_ == NULL) minimum_wait_duration_ = new ::mozilla::safebrowsing::Duration;
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FetchThreatListUpdatesResponse.minimum_wait_duration)
  return minimum_wait_duration_;
}
inline ::mozilla::safebrowsing::Duration* FetchThreatListUpdatesResponse::release_minimum_wait_duration() {
  clear_has_minimum_wait_duration();
  ::mozilla::safebrowsing::Duration* temp = minimum_wait_duration_;
  minimum_wait_duration_ = NULL;
  return temp;
}
inline void FetchThreatListUpdatesResponse::set_allocated_minimum_wait_duration(::mozilla::safebrowsing::Duration* minimum_wait_duration) {
  delete minimum_wait_duration_;
  minimum_wait_duration_ = minimum_wait_duration;
  if (minimum_wait_duration) {
    set_has_minimum_wait_duration();
  } else {
    clear_has_minimum_wait_duration();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.FetchThreatListUpdatesResponse.minimum_wait_duration)
}

// -------------------------------------------------------------------

// FindFullHashesRequest

// optional .mozilla.safebrowsing.ClientInfo client = 1;
inline bool FindFullHashesRequest::has_client() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FindFullHashesRequest::set_has_client() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FindFullHashesRequest::clear_has_client() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FindFullHashesRequest::clear_client() {
  if (client_ != NULL) client_->::mozilla::safebrowsing::ClientInfo::Clear();
  clear_has_client();
}
inline const ::mozilla::safebrowsing::ClientInfo& FindFullHashesRequest::client() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FindFullHashesRequest.client)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return client_ != NULL ? *client_ : *default_instance().client_;
#else
  return client_ != NULL ? *client_ : *default_instance_->client_;
#endif
}
inline ::mozilla::safebrowsing::ClientInfo* FindFullHashesRequest::mutable_client() {
  set_has_client();
  if (client_ == NULL) client_ = new ::mozilla::safebrowsing::ClientInfo;
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FindFullHashesRequest.client)
  return client_;
}
inline ::mozilla::safebrowsing::ClientInfo* FindFullHashesRequest::release_client() {
  clear_has_client();
  ::mozilla::safebrowsing::ClientInfo* temp = client_;
  client_ = NULL;
  return temp;
}
inline void FindFullHashesRequest::set_allocated_client(::mozilla::safebrowsing::ClientInfo* client) {
  delete client_;
  client_ = client;
  if (client) {
    set_has_client();
  } else {
    clear_has_client();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.FindFullHashesRequest.client)
}

// repeated bytes client_states = 2;
inline int FindFullHashesRequest::client_states_size() const {
  return client_states_.size();
}
inline void FindFullHashesRequest::clear_client_states() {
  client_states_.Clear();
}
inline const ::std::string& FindFullHashesRequest::client_states(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FindFullHashesRequest.client_states)
  return client_states_.Get(index);
}
inline ::std::string* FindFullHashesRequest::mutable_client_states(int index) {
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FindFullHashesRequest.client_states)
  return client_states_.Mutable(index);
}
inline void FindFullHashesRequest::set_client_states(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.FindFullHashesRequest.client_states)
  client_states_.Mutable(index)->assign(value);
}
inline void FindFullHashesRequest::set_client_states(int index, const char* value) {
  client_states_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.FindFullHashesRequest.client_states)
}
inline void FindFullHashesRequest::set_client_states(int index, const void* value, size_t size) {
  client_states_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.FindFullHashesRequest.client_states)
}
inline ::std::string* FindFullHashesRequest::add_client_states() {
  return client_states_.Add();
}
inline void FindFullHashesRequest::add_client_states(const ::std::string& value) {
  client_states_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.FindFullHashesRequest.client_states)
}
inline void FindFullHashesRequest::add_client_states(const char* value) {
  client_states_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mozilla.safebrowsing.FindFullHashesRequest.client_states)
}
inline void FindFullHashesRequest::add_client_states(const void* value, size_t size) {
  client_states_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mozilla.safebrowsing.FindFullHashesRequest.client_states)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FindFullHashesRequest::client_states() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.FindFullHashesRequest.client_states)
  return client_states_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FindFullHashesRequest::mutable_client_states() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.FindFullHashesRequest.client_states)
  return &client_states_;
}

// optional .mozilla.safebrowsing.ThreatInfo threat_info = 3;
inline bool FindFullHashesRequest::has_threat_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FindFullHashesRequest::set_has_threat_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FindFullHashesRequest::clear_has_threat_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FindFullHashesRequest::clear_threat_info() {
  if (threat_info_ != NULL) threat_info_->::mozilla::safebrowsing::ThreatInfo::Clear();
  clear_has_threat_info();
}
inline const ::mozilla::safebrowsing::ThreatInfo& FindFullHashesRequest::threat_info() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FindFullHashesRequest.threat_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return threat_info_ != NULL ? *threat_info_ : *default_instance().threat_info_;
#else
  return threat_info_ != NULL ? *threat_info_ : *default_instance_->threat_info_;
#endif
}
inline ::mozilla::safebrowsing::ThreatInfo* FindFullHashesRequest::mutable_threat_info() {
  set_has_threat_info();
  if (threat_info_ == NULL) threat_info_ = new ::mozilla::safebrowsing::ThreatInfo;
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FindFullHashesRequest.threat_info)
  return threat_info_;
}
inline ::mozilla::safebrowsing::ThreatInfo* FindFullHashesRequest::release_threat_info() {
  clear_has_threat_info();
  ::mozilla::safebrowsing::ThreatInfo* temp = threat_info_;
  threat_info_ = NULL;
  return temp;
}
inline void FindFullHashesRequest::set_allocated_threat_info(::mozilla::safebrowsing::ThreatInfo* threat_info) {
  delete threat_info_;
  threat_info_ = threat_info;
  if (threat_info) {
    set_has_threat_info();
  } else {
    clear_has_threat_info();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.FindFullHashesRequest.threat_info)
}

// -------------------------------------------------------------------

// FindFullHashesResponse

// repeated .mozilla.safebrowsing.ThreatMatch matches = 1;
inline int FindFullHashesResponse::matches_size() const {
  return matches_.size();
}
inline void FindFullHashesResponse::clear_matches() {
  matches_.Clear();
}
inline const ::mozilla::safebrowsing::ThreatMatch& FindFullHashesResponse::matches(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FindFullHashesResponse.matches)
  return matches_.Get(index);
}
inline ::mozilla::safebrowsing::ThreatMatch* FindFullHashesResponse::mutable_matches(int index) {
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FindFullHashesResponse.matches)
  return matches_.Mutable(index);
}
inline ::mozilla::safebrowsing::ThreatMatch* FindFullHashesResponse::add_matches() {
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.FindFullHashesResponse.matches)
  return matches_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatMatch >&
FindFullHashesResponse::matches() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.FindFullHashesResponse.matches)
  return matches_;
}
inline ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatMatch >*
FindFullHashesResponse::mutable_matches() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.FindFullHashesResponse.matches)
  return &matches_;
}

// optional .mozilla.safebrowsing.Duration minimum_wait_duration = 2;
inline bool FindFullHashesResponse::has_minimum_wait_duration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FindFullHashesResponse::set_has_minimum_wait_duration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FindFullHashesResponse::clear_has_minimum_wait_duration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FindFullHashesResponse::clear_minimum_wait_duration() {
  if (minimum_wait_duration_ != NULL) minimum_wait_duration_->::mozilla::safebrowsing::Duration::Clear();
  clear_has_minimum_wait_duration();
}
inline const ::mozilla::safebrowsing::Duration& FindFullHashesResponse::minimum_wait_duration() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FindFullHashesResponse.minimum_wait_duration)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return minimum_wait_duration_ != NULL ? *minimum_wait_duration_ : *default_instance().minimum_wait_duration_;
#else
  return minimum_wait_duration_ != NULL ? *minimum_wait_duration_ : *default_instance_->minimum_wait_duration_;
#endif
}
inline ::mozilla::safebrowsing::Duration* FindFullHashesResponse::mutable_minimum_wait_duration() {
  set_has_minimum_wait_duration();
  if (minimum_wait_duration_ == NULL) minimum_wait_duration_ = new ::mozilla::safebrowsing::Duration;
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FindFullHashesResponse.minimum_wait_duration)
  return minimum_wait_duration_;
}
inline ::mozilla::safebrowsing::Duration* FindFullHashesResponse::release_minimum_wait_duration() {
  clear_has_minimum_wait_duration();
  ::mozilla::safebrowsing::Duration* temp = minimum_wait_duration_;
  minimum_wait_duration_ = NULL;
  return temp;
}
inline void FindFullHashesResponse::set_allocated_minimum_wait_duration(::mozilla::safebrowsing::Duration* minimum_wait_duration) {
  delete minimum_wait_duration_;
  minimum_wait_duration_ = minimum_wait_duration;
  if (minimum_wait_duration) {
    set_has_minimum_wait_duration();
  } else {
    clear_has_minimum_wait_duration();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.FindFullHashesResponse.minimum_wait_duration)
}

// optional .mozilla.safebrowsing.Duration negative_cache_duration = 3;
inline bool FindFullHashesResponse::has_negative_cache_duration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FindFullHashesResponse::set_has_negative_cache_duration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FindFullHashesResponse::clear_has_negative_cache_duration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FindFullHashesResponse::clear_negative_cache_duration() {
  if (negative_cache_duration_ != NULL) negative_cache_duration_->::mozilla::safebrowsing::Duration::Clear();
  clear_has_negative_cache_duration();
}
inline const ::mozilla::safebrowsing::Duration& FindFullHashesResponse::negative_cache_duration() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.FindFullHashesResponse.negative_cache_duration)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return negative_cache_duration_ != NULL ? *negative_cache_duration_ : *default_instance().negative_cache_duration_;
#else
  return negative_cache_duration_ != NULL ? *negative_cache_duration_ : *default_instance_->negative_cache_duration_;
#endif
}
inline ::mozilla::safebrowsing::Duration* FindFullHashesResponse::mutable_negative_cache_duration() {
  set_has_negative_cache_duration();
  if (negative_cache_duration_ == NULL) negative_cache_duration_ = new ::mozilla::safebrowsing::Duration;
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.FindFullHashesResponse.negative_cache_duration)
  return negative_cache_duration_;
}
inline ::mozilla::safebrowsing::Duration* FindFullHashesResponse::release_negative_cache_duration() {
  clear_has_negative_cache_duration();
  ::mozilla::safebrowsing::Duration* temp = negative_cache_duration_;
  negative_cache_duration_ = NULL;
  return temp;
}
inline void FindFullHashesResponse::set_allocated_negative_cache_duration(::mozilla::safebrowsing::Duration* negative_cache_duration) {
  delete negative_cache_duration_;
  negative_cache_duration_ = negative_cache_duration;
  if (negative_cache_duration) {
    set_has_negative_cache_duration();
  } else {
    clear_has_negative_cache_duration();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.FindFullHashesResponse.negative_cache_duration)
}

// -------------------------------------------------------------------

// ThreatHit_ThreatSource

// optional string url = 1;
inline bool ThreatHit_ThreatSource::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ThreatHit_ThreatSource::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ThreatHit_ThreatSource::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ThreatHit_ThreatSource::clear_url() {
  if (url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& ThreatHit_ThreatSource::url() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatHit.ThreatSource.url)
  return *url_;
}
inline void ThreatHit_ThreatSource::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatHit.ThreatSource.url)
}
inline void ThreatHit_ThreatSource::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(value);
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.ThreatHit.ThreatSource.url)
}
inline void ThreatHit_ThreatSource::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.ThreatHit.ThreatSource.url)
}
inline ::std::string* ThreatHit_ThreatSource::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatHit.ThreatSource.url)
  return url_;
}
inline ::std::string* ThreatHit_ThreatSource::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ThreatHit_ThreatSource::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatHit.ThreatSource.url)
}

// optional .mozilla.safebrowsing.ThreatHit.ThreatSourceType type = 2;
inline bool ThreatHit_ThreatSource::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ThreatHit_ThreatSource::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ThreatHit_ThreatSource::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ThreatHit_ThreatSource::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::mozilla::safebrowsing::ThreatHit_ThreatSourceType ThreatHit_ThreatSource::type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatHit.ThreatSource.type)
  return static_cast< ::mozilla::safebrowsing::ThreatHit_ThreatSourceType >(type_);
}
inline void ThreatHit_ThreatSource::set_type(::mozilla::safebrowsing::ThreatHit_ThreatSourceType value) {
  assert(::mozilla::safebrowsing::ThreatHit_ThreatSourceType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatHit.ThreatSource.type)
}

// optional string remote_ip = 3;
inline bool ThreatHit_ThreatSource::has_remote_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ThreatHit_ThreatSource::set_has_remote_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ThreatHit_ThreatSource::clear_has_remote_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ThreatHit_ThreatSource::clear_remote_ip() {
  if (remote_ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remote_ip_->clear();
  }
  clear_has_remote_ip();
}
inline const ::std::string& ThreatHit_ThreatSource::remote_ip() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatHit.ThreatSource.remote_ip)
  return *remote_ip_;
}
inline void ThreatHit_ThreatSource::set_remote_ip(const ::std::string& value) {
  set_has_remote_ip();
  if (remote_ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remote_ip_ = new ::std::string;
  }
  remote_ip_->assign(value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatHit.ThreatSource.remote_ip)
}
inline void ThreatHit_ThreatSource::set_remote_ip(const char* value) {
  set_has_remote_ip();
  if (remote_ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remote_ip_ = new ::std::string;
  }
  remote_ip_->assign(value);
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.ThreatHit.ThreatSource.remote_ip)
}
inline void ThreatHit_ThreatSource::set_remote_ip(const char* value, size_t size) {
  set_has_remote_ip();
  if (remote_ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remote_ip_ = new ::std::string;
  }
  remote_ip_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.ThreatHit.ThreatSource.remote_ip)
}
inline ::std::string* ThreatHit_ThreatSource::mutable_remote_ip() {
  set_has_remote_ip();
  if (remote_ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    remote_ip_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatHit.ThreatSource.remote_ip)
  return remote_ip_;
}
inline ::std::string* ThreatHit_ThreatSource::release_remote_ip() {
  clear_has_remote_ip();
  if (remote_ip_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = remote_ip_;
    remote_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ThreatHit_ThreatSource::set_allocated_remote_ip(::std::string* remote_ip) {
  if (remote_ip_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete remote_ip_;
  }
  if (remote_ip) {
    set_has_remote_ip();
    remote_ip_ = remote_ip;
  } else {
    clear_has_remote_ip();
    remote_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatHit.ThreatSource.remote_ip)
}

// optional string referrer = 4;
inline bool ThreatHit_ThreatSource::has_referrer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ThreatHit_ThreatSource::set_has_referrer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ThreatHit_ThreatSource::clear_has_referrer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ThreatHit_ThreatSource::clear_referrer() {
  if (referrer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    referrer_->clear();
  }
  clear_has_referrer();
}
inline const ::std::string& ThreatHit_ThreatSource::referrer() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatHit.ThreatSource.referrer)
  return *referrer_;
}
inline void ThreatHit_ThreatSource::set_referrer(const ::std::string& value) {
  set_has_referrer();
  if (referrer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    referrer_ = new ::std::string;
  }
  referrer_->assign(value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatHit.ThreatSource.referrer)
}
inline void ThreatHit_ThreatSource::set_referrer(const char* value) {
  set_has_referrer();
  if (referrer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    referrer_ = new ::std::string;
  }
  referrer_->assign(value);
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.ThreatHit.ThreatSource.referrer)
}
inline void ThreatHit_ThreatSource::set_referrer(const char* value, size_t size) {
  set_has_referrer();
  if (referrer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    referrer_ = new ::std::string;
  }
  referrer_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.ThreatHit.ThreatSource.referrer)
}
inline ::std::string* ThreatHit_ThreatSource::mutable_referrer() {
  set_has_referrer();
  if (referrer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    referrer_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatHit.ThreatSource.referrer)
  return referrer_;
}
inline ::std::string* ThreatHit_ThreatSource::release_referrer() {
  clear_has_referrer();
  if (referrer_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = referrer_;
    referrer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ThreatHit_ThreatSource::set_allocated_referrer(::std::string* referrer) {
  if (referrer_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete referrer_;
  }
  if (referrer) {
    set_has_referrer();
    referrer_ = referrer;
  } else {
    clear_has_referrer();
    referrer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatHit.ThreatSource.referrer)
}

// -------------------------------------------------------------------

// ThreatHit

// optional .mozilla.safebrowsing.ThreatType threat_type = 1;
inline bool ThreatHit::has_threat_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ThreatHit::set_has_threat_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ThreatHit::clear_has_threat_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ThreatHit::clear_threat_type() {
  threat_type_ = 0;
  clear_has_threat_type();
}
inline ::mozilla::safebrowsing::ThreatType ThreatHit::threat_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatHit.threat_type)
  return static_cast< ::mozilla::safebrowsing::ThreatType >(threat_type_);
}
inline void ThreatHit::set_threat_type(::mozilla::safebrowsing::ThreatType value) {
  assert(::mozilla::safebrowsing::ThreatType_IsValid(value));
  set_has_threat_type();
  threat_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatHit.threat_type)
}

// optional .mozilla.safebrowsing.PlatformType platform_type = 2;
inline bool ThreatHit::has_platform_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ThreatHit::set_has_platform_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ThreatHit::clear_has_platform_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ThreatHit::clear_platform_type() {
  platform_type_ = 0;
  clear_has_platform_type();
}
inline ::mozilla::safebrowsing::PlatformType ThreatHit::platform_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatHit.platform_type)
  return static_cast< ::mozilla::safebrowsing::PlatformType >(platform_type_);
}
inline void ThreatHit::set_platform_type(::mozilla::safebrowsing::PlatformType value) {
  assert(::mozilla::safebrowsing::PlatformType_IsValid(value));
  set_has_platform_type();
  platform_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatHit.platform_type)
}

// optional .mozilla.safebrowsing.ThreatEntry entry = 3;
inline bool ThreatHit::has_entry() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ThreatHit::set_has_entry() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ThreatHit::clear_has_entry() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ThreatHit::clear_entry() {
  if (entry_ != NULL) entry_->::mozilla::safebrowsing::ThreatEntry::Clear();
  clear_has_entry();
}
inline const ::mozilla::safebrowsing::ThreatEntry& ThreatHit::entry() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatHit.entry)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return entry_ != NULL ? *entry_ : *default_instance().entry_;
#else
  return entry_ != NULL ? *entry_ : *default_instance_->entry_;
#endif
}
inline ::mozilla::safebrowsing::ThreatEntry* ThreatHit::mutable_entry() {
  set_has_entry();
  if (entry_ == NULL) entry_ = new ::mozilla::safebrowsing::ThreatEntry;
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatHit.entry)
  return entry_;
}
inline ::mozilla::safebrowsing::ThreatEntry* ThreatHit::release_entry() {
  clear_has_entry();
  ::mozilla::safebrowsing::ThreatEntry* temp = entry_;
  entry_ = NULL;
  return temp;
}
inline void ThreatHit::set_allocated_entry(::mozilla::safebrowsing::ThreatEntry* entry) {
  delete entry_;
  entry_ = entry;
  if (entry) {
    set_has_entry();
  } else {
    clear_has_entry();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatHit.entry)
}

// repeated .mozilla.safebrowsing.ThreatHit.ThreatSource resources = 4;
inline int ThreatHit::resources_size() const {
  return resources_.size();
}
inline void ThreatHit::clear_resources() {
  resources_.Clear();
}
inline const ::mozilla::safebrowsing::ThreatHit_ThreatSource& ThreatHit::resources(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatHit.resources)
  return resources_.Get(index);
}
inline ::mozilla::safebrowsing::ThreatHit_ThreatSource* ThreatHit::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatHit.resources)
  return resources_.Mutable(index);
}
inline ::mozilla::safebrowsing::ThreatHit_ThreatSource* ThreatHit::add_resources() {
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.ThreatHit.resources)
  return resources_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatHit_ThreatSource >&
ThreatHit::resources() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.ThreatHit.resources)
  return resources_;
}
inline ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatHit_ThreatSource >*
ThreatHit::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.ThreatHit.resources)
  return &resources_;
}

// -------------------------------------------------------------------

// ClientInfo

// optional string client_id = 1;
inline bool ClientInfo::has_client_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientInfo::set_has_client_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientInfo::clear_has_client_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientInfo::clear_client_id() {
  if (client_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_->clear();
  }
  clear_has_client_id();
}
inline const ::std::string& ClientInfo::client_id() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ClientInfo.client_id)
  return *client_id_;
}
inline void ClientInfo::set_client_id(const ::std::string& value) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ClientInfo.client_id)
}
inline void ClientInfo::set_client_id(const char* value) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.ClientInfo.client_id)
}
inline void ClientInfo::set_client_id(const char* value, size_t size) {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_ = new ::std::string;
  }
  client_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.ClientInfo.client_id)
}
inline ::std::string* ClientInfo::mutable_client_id() {
  set_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ClientInfo.client_id)
  return client_id_;
}
inline ::std::string* ClientInfo::release_client_id() {
  clear_has_client_id();
  if (client_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = client_id_;
    client_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ClientInfo::set_allocated_client_id(::std::string* client_id) {
  if (client_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete client_id_;
  }
  if (client_id) {
    set_has_client_id();
    client_id_ = client_id;
  } else {
    clear_has_client_id();
    client_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ClientInfo.client_id)
}

// optional string client_version = 2;
inline bool ClientInfo::has_client_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientInfo::set_has_client_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientInfo::clear_has_client_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientInfo::clear_client_version() {
  if (client_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_version_->clear();
  }
  clear_has_client_version();
}
inline const ::std::string& ClientInfo::client_version() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ClientInfo.client_version)
  return *client_version_;
}
inline void ClientInfo::set_client_version(const ::std::string& value) {
  set_has_client_version();
  if (client_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_version_ = new ::std::string;
  }
  client_version_->assign(value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ClientInfo.client_version)
}
inline void ClientInfo::set_client_version(const char* value) {
  set_has_client_version();
  if (client_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_version_ = new ::std::string;
  }
  client_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.ClientInfo.client_version)
}
inline void ClientInfo::set_client_version(const char* value, size_t size) {
  set_has_client_version();
  if (client_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_version_ = new ::std::string;
  }
  client_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.ClientInfo.client_version)
}
inline ::std::string* ClientInfo::mutable_client_version() {
  set_has_client_version();
  if (client_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    client_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ClientInfo.client_version)
  return client_version_;
}
inline ::std::string* ClientInfo::release_client_version() {
  clear_has_client_version();
  if (client_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = client_version_;
    client_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ClientInfo::set_allocated_client_version(::std::string* client_version) {
  if (client_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete client_version_;
  }
  if (client_version) {
    set_has_client_version();
    client_version_ = client_version;
  } else {
    clear_has_client_version();
    client_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ClientInfo.client_version)
}

// -------------------------------------------------------------------

// Checksum

// optional bytes sha256 = 1;
inline bool Checksum::has_sha256() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Checksum::set_has_sha256() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Checksum::clear_has_sha256() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Checksum::clear_sha256() {
  if (sha256_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sha256_->clear();
  }
  clear_has_sha256();
}
inline const ::std::string& Checksum::sha256() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.Checksum.sha256)
  return *sha256_;
}
inline void Checksum::set_sha256(const ::std::string& value) {
  set_has_sha256();
  if (sha256_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sha256_ = new ::std::string;
  }
  sha256_->assign(value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.Checksum.sha256)
}
inline void Checksum::set_sha256(const char* value) {
  set_has_sha256();
  if (sha256_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sha256_ = new ::std::string;
  }
  sha256_->assign(value);
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.Checksum.sha256)
}
inline void Checksum::set_sha256(const void* value, size_t size) {
  set_has_sha256();
  if (sha256_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sha256_ = new ::std::string;
  }
  sha256_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.Checksum.sha256)
}
inline ::std::string* Checksum::mutable_sha256() {
  set_has_sha256();
  if (sha256_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sha256_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.Checksum.sha256)
  return sha256_;
}
inline ::std::string* Checksum::release_sha256() {
  clear_has_sha256();
  if (sha256_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sha256_;
    sha256_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Checksum::set_allocated_sha256(::std::string* sha256) {
  if (sha256_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sha256_;
  }
  if (sha256) {
    set_has_sha256();
    sha256_ = sha256;
  } else {
    clear_has_sha256();
    sha256_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.Checksum.sha256)
}

// -------------------------------------------------------------------

// ThreatEntry

// optional bytes hash = 1;
inline bool ThreatEntry::has_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ThreatEntry::set_has_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ThreatEntry::clear_has_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ThreatEntry::clear_hash() {
  if (hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hash_->clear();
  }
  clear_has_hash();
}
inline const ::std::string& ThreatEntry::hash() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatEntry.hash)
  return *hash_;
}
inline void ThreatEntry::set_hash(const ::std::string& value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatEntry.hash)
}
inline void ThreatEntry::set_hash(const char* value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.ThreatEntry.hash)
}
inline void ThreatEntry::set_hash(const void* value, size_t size) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hash_ = new ::std::string;
  }
  hash_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.ThreatEntry.hash)
}
inline ::std::string* ThreatEntry::mutable_hash() {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hash_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatEntry.hash)
  return hash_;
}
inline ::std::string* ThreatEntry::release_hash() {
  clear_has_hash();
  if (hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hash_;
    hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ThreatEntry::set_allocated_hash(::std::string* hash) {
  if (hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hash_;
  }
  if (hash) {
    set_has_hash();
    hash_ = hash;
  } else {
    clear_has_hash();
    hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatEntry.hash)
}

// optional string url = 2;
inline bool ThreatEntry::has_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ThreatEntry::set_has_url() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ThreatEntry::clear_has_url() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ThreatEntry::clear_url() {
  if (url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& ThreatEntry::url() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatEntry.url)
  return *url_;
}
inline void ThreatEntry::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatEntry.url)
}
inline void ThreatEntry::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(value);
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.ThreatEntry.url)
}
inline void ThreatEntry::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.ThreatEntry.url)
}
inline ::std::string* ThreatEntry::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    url_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatEntry.url)
  return url_;
}
inline ::std::string* ThreatEntry::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ThreatEntry::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatEntry.url)
}

// -------------------------------------------------------------------

// ThreatEntrySet

// optional .mozilla.safebrowsing.CompressionType compression_type = 1;
inline bool ThreatEntrySet::has_compression_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ThreatEntrySet::set_has_compression_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ThreatEntrySet::clear_has_compression_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ThreatEntrySet::clear_compression_type() {
  compression_type_ = 0;
  clear_has_compression_type();
}
inline ::mozilla::safebrowsing::CompressionType ThreatEntrySet::compression_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatEntrySet.compression_type)
  return static_cast< ::mozilla::safebrowsing::CompressionType >(compression_type_);
}
inline void ThreatEntrySet::set_compression_type(::mozilla::safebrowsing::CompressionType value) {
  assert(::mozilla::safebrowsing::CompressionType_IsValid(value));
  set_has_compression_type();
  compression_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatEntrySet.compression_type)
}

// optional .mozilla.safebrowsing.RawHashes raw_hashes = 2;
inline bool ThreatEntrySet::has_raw_hashes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ThreatEntrySet::set_has_raw_hashes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ThreatEntrySet::clear_has_raw_hashes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ThreatEntrySet::clear_raw_hashes() {
  if (raw_hashes_ != NULL) raw_hashes_->::mozilla::safebrowsing::RawHashes::Clear();
  clear_has_raw_hashes();
}
inline const ::mozilla::safebrowsing::RawHashes& ThreatEntrySet::raw_hashes() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatEntrySet.raw_hashes)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return raw_hashes_ != NULL ? *raw_hashes_ : *default_instance().raw_hashes_;
#else
  return raw_hashes_ != NULL ? *raw_hashes_ : *default_instance_->raw_hashes_;
#endif
}
inline ::mozilla::safebrowsing::RawHashes* ThreatEntrySet::mutable_raw_hashes() {
  set_has_raw_hashes();
  if (raw_hashes_ == NULL) raw_hashes_ = new ::mozilla::safebrowsing::RawHashes;
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatEntrySet.raw_hashes)
  return raw_hashes_;
}
inline ::mozilla::safebrowsing::RawHashes* ThreatEntrySet::release_raw_hashes() {
  clear_has_raw_hashes();
  ::mozilla::safebrowsing::RawHashes* temp = raw_hashes_;
  raw_hashes_ = NULL;
  return temp;
}
inline void ThreatEntrySet::set_allocated_raw_hashes(::mozilla::safebrowsing::RawHashes* raw_hashes) {
  delete raw_hashes_;
  raw_hashes_ = raw_hashes;
  if (raw_hashes) {
    set_has_raw_hashes();
  } else {
    clear_has_raw_hashes();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatEntrySet.raw_hashes)
}

// optional .mozilla.safebrowsing.RawIndices raw_indices = 3;
inline bool ThreatEntrySet::has_raw_indices() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ThreatEntrySet::set_has_raw_indices() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ThreatEntrySet::clear_has_raw_indices() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ThreatEntrySet::clear_raw_indices() {
  if (raw_indices_ != NULL) raw_indices_->::mozilla::safebrowsing::RawIndices::Clear();
  clear_has_raw_indices();
}
inline const ::mozilla::safebrowsing::RawIndices& ThreatEntrySet::raw_indices() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatEntrySet.raw_indices)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return raw_indices_ != NULL ? *raw_indices_ : *default_instance().raw_indices_;
#else
  return raw_indices_ != NULL ? *raw_indices_ : *default_instance_->raw_indices_;
#endif
}
inline ::mozilla::safebrowsing::RawIndices* ThreatEntrySet::mutable_raw_indices() {
  set_has_raw_indices();
  if (raw_indices_ == NULL) raw_indices_ = new ::mozilla::safebrowsing::RawIndices;
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatEntrySet.raw_indices)
  return raw_indices_;
}
inline ::mozilla::safebrowsing::RawIndices* ThreatEntrySet::release_raw_indices() {
  clear_has_raw_indices();
  ::mozilla::safebrowsing::RawIndices* temp = raw_indices_;
  raw_indices_ = NULL;
  return temp;
}
inline void ThreatEntrySet::set_allocated_raw_indices(::mozilla::safebrowsing::RawIndices* raw_indices) {
  delete raw_indices_;
  raw_indices_ = raw_indices;
  if (raw_indices) {
    set_has_raw_indices();
  } else {
    clear_has_raw_indices();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatEntrySet.raw_indices)
}

// optional .mozilla.safebrowsing.RiceDeltaEncoding rice_hashes = 4;
inline bool ThreatEntrySet::has_rice_hashes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ThreatEntrySet::set_has_rice_hashes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ThreatEntrySet::clear_has_rice_hashes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ThreatEntrySet::clear_rice_hashes() {
  if (rice_hashes_ != NULL) rice_hashes_->::mozilla::safebrowsing::RiceDeltaEncoding::Clear();
  clear_has_rice_hashes();
}
inline const ::mozilla::safebrowsing::RiceDeltaEncoding& ThreatEntrySet::rice_hashes() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatEntrySet.rice_hashes)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return rice_hashes_ != NULL ? *rice_hashes_ : *default_instance().rice_hashes_;
#else
  return rice_hashes_ != NULL ? *rice_hashes_ : *default_instance_->rice_hashes_;
#endif
}
inline ::mozilla::safebrowsing::RiceDeltaEncoding* ThreatEntrySet::mutable_rice_hashes() {
  set_has_rice_hashes();
  if (rice_hashes_ == NULL) rice_hashes_ = new ::mozilla::safebrowsing::RiceDeltaEncoding;
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatEntrySet.rice_hashes)
  return rice_hashes_;
}
inline ::mozilla::safebrowsing::RiceDeltaEncoding* ThreatEntrySet::release_rice_hashes() {
  clear_has_rice_hashes();
  ::mozilla::safebrowsing::RiceDeltaEncoding* temp = rice_hashes_;
  rice_hashes_ = NULL;
  return temp;
}
inline void ThreatEntrySet::set_allocated_rice_hashes(::mozilla::safebrowsing::RiceDeltaEncoding* rice_hashes) {
  delete rice_hashes_;
  rice_hashes_ = rice_hashes;
  if (rice_hashes) {
    set_has_rice_hashes();
  } else {
    clear_has_rice_hashes();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatEntrySet.rice_hashes)
}

// optional .mozilla.safebrowsing.RiceDeltaEncoding rice_indices = 5;
inline bool ThreatEntrySet::has_rice_indices() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ThreatEntrySet::set_has_rice_indices() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ThreatEntrySet::clear_has_rice_indices() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ThreatEntrySet::clear_rice_indices() {
  if (rice_indices_ != NULL) rice_indices_->::mozilla::safebrowsing::RiceDeltaEncoding::Clear();
  clear_has_rice_indices();
}
inline const ::mozilla::safebrowsing::RiceDeltaEncoding& ThreatEntrySet::rice_indices() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatEntrySet.rice_indices)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return rice_indices_ != NULL ? *rice_indices_ : *default_instance().rice_indices_;
#else
  return rice_indices_ != NULL ? *rice_indices_ : *default_instance_->rice_indices_;
#endif
}
inline ::mozilla::safebrowsing::RiceDeltaEncoding* ThreatEntrySet::mutable_rice_indices() {
  set_has_rice_indices();
  if (rice_indices_ == NULL) rice_indices_ = new ::mozilla::safebrowsing::RiceDeltaEncoding;
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatEntrySet.rice_indices)
  return rice_indices_;
}
inline ::mozilla::safebrowsing::RiceDeltaEncoding* ThreatEntrySet::release_rice_indices() {
  clear_has_rice_indices();
  ::mozilla::safebrowsing::RiceDeltaEncoding* temp = rice_indices_;
  rice_indices_ = NULL;
  return temp;
}
inline void ThreatEntrySet::set_allocated_rice_indices(::mozilla::safebrowsing::RiceDeltaEncoding* rice_indices) {
  delete rice_indices_;
  rice_indices_ = rice_indices;
  if (rice_indices) {
    set_has_rice_indices();
  } else {
    clear_has_rice_indices();
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatEntrySet.rice_indices)
}

// -------------------------------------------------------------------

// RawIndices

// repeated int32 indices = 1;
inline int RawIndices::indices_size() const {
  return indices_.size();
}
inline void RawIndices::clear_indices() {
  indices_.Clear();
}
inline ::google::protobuf::int32 RawIndices::indices(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.RawIndices.indices)
  return indices_.Get(index);
}
inline void RawIndices::set_indices(int index, ::google::protobuf::int32 value) {
  indices_.Set(index, value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.RawIndices.indices)
}
inline void RawIndices::add_indices(::google::protobuf::int32 value) {
  indices_.Add(value);
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.RawIndices.indices)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
RawIndices::indices() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.RawIndices.indices)
  return indices_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
RawIndices::mutable_indices() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.RawIndices.indices)
  return &indices_;
}

// -------------------------------------------------------------------

// RawHashes

// optional int32 prefix_size = 1;
inline bool RawHashes::has_prefix_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RawHashes::set_has_prefix_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RawHashes::clear_has_prefix_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RawHashes::clear_prefix_size() {
  prefix_size_ = 0;
  clear_has_prefix_size();
}
inline ::google::protobuf::int32 RawHashes::prefix_size() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.RawHashes.prefix_size)
  return prefix_size_;
}
inline void RawHashes::set_prefix_size(::google::protobuf::int32 value) {
  set_has_prefix_size();
  prefix_size_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.RawHashes.prefix_size)
}

// optional bytes raw_hashes = 2;
inline bool RawHashes::has_raw_hashes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RawHashes::set_has_raw_hashes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RawHashes::clear_has_raw_hashes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RawHashes::clear_raw_hashes() {
  if (raw_hashes_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    raw_hashes_->clear();
  }
  clear_has_raw_hashes();
}
inline const ::std::string& RawHashes::raw_hashes() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.RawHashes.raw_hashes)
  return *raw_hashes_;
}
inline void RawHashes::set_raw_hashes(const ::std::string& value) {
  set_has_raw_hashes();
  if (raw_hashes_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    raw_hashes_ = new ::std::string;
  }
  raw_hashes_->assign(value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.RawHashes.raw_hashes)
}
inline void RawHashes::set_raw_hashes(const char* value) {
  set_has_raw_hashes();
  if (raw_hashes_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    raw_hashes_ = new ::std::string;
  }
  raw_hashes_->assign(value);
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.RawHashes.raw_hashes)
}
inline void RawHashes::set_raw_hashes(const void* value, size_t size) {
  set_has_raw_hashes();
  if (raw_hashes_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    raw_hashes_ = new ::std::string;
  }
  raw_hashes_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.RawHashes.raw_hashes)
}
inline ::std::string* RawHashes::mutable_raw_hashes() {
  set_has_raw_hashes();
  if (raw_hashes_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    raw_hashes_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.RawHashes.raw_hashes)
  return raw_hashes_;
}
inline ::std::string* RawHashes::release_raw_hashes() {
  clear_has_raw_hashes();
  if (raw_hashes_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = raw_hashes_;
    raw_hashes_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RawHashes::set_allocated_raw_hashes(::std::string* raw_hashes) {
  if (raw_hashes_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete raw_hashes_;
  }
  if (raw_hashes) {
    set_has_raw_hashes();
    raw_hashes_ = raw_hashes;
  } else {
    clear_has_raw_hashes();
    raw_hashes_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.RawHashes.raw_hashes)
}

// -------------------------------------------------------------------

// RiceDeltaEncoding

// optional int64 first_value = 1;
inline bool RiceDeltaEncoding::has_first_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RiceDeltaEncoding::set_has_first_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RiceDeltaEncoding::clear_has_first_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RiceDeltaEncoding::clear_first_value() {
  first_value_ = GOOGLE_LONGLONG(0);
  clear_has_first_value();
}
inline ::google::protobuf::int64 RiceDeltaEncoding::first_value() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.RiceDeltaEncoding.first_value)
  return first_value_;
}
inline void RiceDeltaEncoding::set_first_value(::google::protobuf::int64 value) {
  set_has_first_value();
  first_value_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.RiceDeltaEncoding.first_value)
}

// optional int32 rice_parameter = 2;
inline bool RiceDeltaEncoding::has_rice_parameter() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RiceDeltaEncoding::set_has_rice_parameter() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RiceDeltaEncoding::clear_has_rice_parameter() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RiceDeltaEncoding::clear_rice_parameter() {
  rice_parameter_ = 0;
  clear_has_rice_parameter();
}
inline ::google::protobuf::int32 RiceDeltaEncoding::rice_parameter() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.RiceDeltaEncoding.rice_parameter)
  return rice_parameter_;
}
inline void RiceDeltaEncoding::set_rice_parameter(::google::protobuf::int32 value) {
  set_has_rice_parameter();
  rice_parameter_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.RiceDeltaEncoding.rice_parameter)
}

// optional int32 num_entries = 3;
inline bool RiceDeltaEncoding::has_num_entries() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RiceDeltaEncoding::set_has_num_entries() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RiceDeltaEncoding::clear_has_num_entries() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RiceDeltaEncoding::clear_num_entries() {
  num_entries_ = 0;
  clear_has_num_entries();
}
inline ::google::protobuf::int32 RiceDeltaEncoding::num_entries() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.RiceDeltaEncoding.num_entries)
  return num_entries_;
}
inline void RiceDeltaEncoding::set_num_entries(::google::protobuf::int32 value) {
  set_has_num_entries();
  num_entries_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.RiceDeltaEncoding.num_entries)
}

// optional bytes encoded_data = 4;
inline bool RiceDeltaEncoding::has_encoded_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RiceDeltaEncoding::set_has_encoded_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RiceDeltaEncoding::clear_has_encoded_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RiceDeltaEncoding::clear_encoded_data() {
  if (encoded_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encoded_data_->clear();
  }
  clear_has_encoded_data();
}
inline const ::std::string& RiceDeltaEncoding::encoded_data() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.RiceDeltaEncoding.encoded_data)
  return *encoded_data_;
}
inline void RiceDeltaEncoding::set_encoded_data(const ::std::string& value) {
  set_has_encoded_data();
  if (encoded_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encoded_data_ = new ::std::string;
  }
  encoded_data_->assign(value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.RiceDeltaEncoding.encoded_data)
}
inline void RiceDeltaEncoding::set_encoded_data(const char* value) {
  set_has_encoded_data();
  if (encoded_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encoded_data_ = new ::std::string;
  }
  encoded_data_->assign(value);
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.RiceDeltaEncoding.encoded_data)
}
inline void RiceDeltaEncoding::set_encoded_data(const void* value, size_t size) {
  set_has_encoded_data();
  if (encoded_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encoded_data_ = new ::std::string;
  }
  encoded_data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.RiceDeltaEncoding.encoded_data)
}
inline ::std::string* RiceDeltaEncoding::mutable_encoded_data() {
  set_has_encoded_data();
  if (encoded_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    encoded_data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.RiceDeltaEncoding.encoded_data)
  return encoded_data_;
}
inline ::std::string* RiceDeltaEncoding::release_encoded_data() {
  clear_has_encoded_data();
  if (encoded_data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = encoded_data_;
    encoded_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RiceDeltaEncoding::set_allocated_encoded_data(::std::string* encoded_data) {
  if (encoded_data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete encoded_data_;
  }
  if (encoded_data) {
    set_has_encoded_data();
    encoded_data_ = encoded_data;
  } else {
    clear_has_encoded_data();
    encoded_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.RiceDeltaEncoding.encoded_data)
}

// -------------------------------------------------------------------

// ThreatEntryMetadata_MetadataEntry

// optional bytes key = 1;
inline bool ThreatEntryMetadata_MetadataEntry::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ThreatEntryMetadata_MetadataEntry::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ThreatEntryMetadata_MetadataEntry::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ThreatEntryMetadata_MetadataEntry::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& ThreatEntryMetadata_MetadataEntry::key() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.key)
  return *key_;
}
inline void ThreatEntryMetadata_MetadataEntry::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.key)
}
inline void ThreatEntryMetadata_MetadataEntry::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.key)
}
inline void ThreatEntryMetadata_MetadataEntry::set_key(const void* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.key)
}
inline ::std::string* ThreatEntryMetadata_MetadataEntry::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    key_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.key)
  return key_;
}
inline ::std::string* ThreatEntryMetadata_MetadataEntry::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ThreatEntryMetadata_MetadataEntry::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.key)
}

// optional bytes value = 2;
inline bool ThreatEntryMetadata_MetadataEntry::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ThreatEntryMetadata_MetadataEntry::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ThreatEntryMetadata_MetadataEntry::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ThreatEntryMetadata_MetadataEntry::clear_value() {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& ThreatEntryMetadata_MetadataEntry::value() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.value)
  return *value_;
}
inline void ThreatEntryMetadata_MetadataEntry::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.value)
}
inline void ThreatEntryMetadata_MetadataEntry::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(value);
  // @@protoc_insertion_point(field_set_char:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.value)
}
inline void ThreatEntryMetadata_MetadataEntry::set_value(const void* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.value)
}
inline ::std::string* ThreatEntryMetadata_MetadataEntry::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.value)
  return value_;
}
inline ::std::string* ThreatEntryMetadata_MetadataEntry::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ThreatEntryMetadata_MetadataEntry::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry.value)
}

// -------------------------------------------------------------------

// ThreatEntryMetadata

// repeated .mozilla.safebrowsing.ThreatEntryMetadata.MetadataEntry entries = 1;
inline int ThreatEntryMetadata::entries_size() const {
  return entries_.size();
}
inline void ThreatEntryMetadata::clear_entries() {
  entries_.Clear();
}
inline const ::mozilla::safebrowsing::ThreatEntryMetadata_MetadataEntry& ThreatEntryMetadata::entries(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatEntryMetadata.entries)
  return entries_.Get(index);
}
inline ::mozilla::safebrowsing::ThreatEntryMetadata_MetadataEntry* ThreatEntryMetadata::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ThreatEntryMetadata.entries)
  return entries_.Mutable(index);
}
inline ::mozilla::safebrowsing::ThreatEntryMetadata_MetadataEntry* ThreatEntryMetadata::add_entries() {
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.ThreatEntryMetadata.entries)
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntryMetadata_MetadataEntry >&
ThreatEntryMetadata::entries() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.ThreatEntryMetadata.entries)
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatEntryMetadata_MetadataEntry >*
ThreatEntryMetadata::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.ThreatEntryMetadata.entries)
  return &entries_;
}

// -------------------------------------------------------------------

// ThreatListDescriptor

// optional .mozilla.safebrowsing.ThreatType threat_type = 1;
inline bool ThreatListDescriptor::has_threat_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ThreatListDescriptor::set_has_threat_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ThreatListDescriptor::clear_has_threat_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ThreatListDescriptor::clear_threat_type() {
  threat_type_ = 0;
  clear_has_threat_type();
}
inline ::mozilla::safebrowsing::ThreatType ThreatListDescriptor::threat_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatListDescriptor.threat_type)
  return static_cast< ::mozilla::safebrowsing::ThreatType >(threat_type_);
}
inline void ThreatListDescriptor::set_threat_type(::mozilla::safebrowsing::ThreatType value) {
  assert(::mozilla::safebrowsing::ThreatType_IsValid(value));
  set_has_threat_type();
  threat_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatListDescriptor.threat_type)
}

// optional .mozilla.safebrowsing.PlatformType platform_type = 2;
inline bool ThreatListDescriptor::has_platform_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ThreatListDescriptor::set_has_platform_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ThreatListDescriptor::clear_has_platform_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ThreatListDescriptor::clear_platform_type() {
  platform_type_ = 0;
  clear_has_platform_type();
}
inline ::mozilla::safebrowsing::PlatformType ThreatListDescriptor::platform_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatListDescriptor.platform_type)
  return static_cast< ::mozilla::safebrowsing::PlatformType >(platform_type_);
}
inline void ThreatListDescriptor::set_platform_type(::mozilla::safebrowsing::PlatformType value) {
  assert(::mozilla::safebrowsing::PlatformType_IsValid(value));
  set_has_platform_type();
  platform_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatListDescriptor.platform_type)
}

// optional .mozilla.safebrowsing.ThreatEntryType threat_entry_type = 3;
inline bool ThreatListDescriptor::has_threat_entry_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ThreatListDescriptor::set_has_threat_entry_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ThreatListDescriptor::clear_has_threat_entry_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ThreatListDescriptor::clear_threat_entry_type() {
  threat_entry_type_ = 0;
  clear_has_threat_entry_type();
}
inline ::mozilla::safebrowsing::ThreatEntryType ThreatListDescriptor::threat_entry_type() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ThreatListDescriptor.threat_entry_type)
  return static_cast< ::mozilla::safebrowsing::ThreatEntryType >(threat_entry_type_);
}
inline void ThreatListDescriptor::set_threat_entry_type(::mozilla::safebrowsing::ThreatEntryType value) {
  assert(::mozilla::safebrowsing::ThreatEntryType_IsValid(value));
  set_has_threat_entry_type();
  threat_entry_type_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.ThreatListDescriptor.threat_entry_type)
}

// -------------------------------------------------------------------

// ListThreatListsResponse

// repeated .mozilla.safebrowsing.ThreatListDescriptor threat_lists = 1;
inline int ListThreatListsResponse::threat_lists_size() const {
  return threat_lists_.size();
}
inline void ListThreatListsResponse::clear_threat_lists() {
  threat_lists_.Clear();
}
inline const ::mozilla::safebrowsing::ThreatListDescriptor& ListThreatListsResponse::threat_lists(int index) const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.ListThreatListsResponse.threat_lists)
  return threat_lists_.Get(index);
}
inline ::mozilla::safebrowsing::ThreatListDescriptor* ListThreatListsResponse::mutable_threat_lists(int index) {
  // @@protoc_insertion_point(field_mutable:mozilla.safebrowsing.ListThreatListsResponse.threat_lists)
  return threat_lists_.Mutable(index);
}
inline ::mozilla::safebrowsing::ThreatListDescriptor* ListThreatListsResponse::add_threat_lists() {
  // @@protoc_insertion_point(field_add:mozilla.safebrowsing.ListThreatListsResponse.threat_lists)
  return threat_lists_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatListDescriptor >&
ListThreatListsResponse::threat_lists() const {
  // @@protoc_insertion_point(field_list:mozilla.safebrowsing.ListThreatListsResponse.threat_lists)
  return threat_lists_;
}
inline ::google::protobuf::RepeatedPtrField< ::mozilla::safebrowsing::ThreatListDescriptor >*
ListThreatListsResponse::mutable_threat_lists() {
  // @@protoc_insertion_point(field_mutable_list:mozilla.safebrowsing.ListThreatListsResponse.threat_lists)
  return &threat_lists_;
}

// -------------------------------------------------------------------

// Duration

// optional int64 seconds = 1;
inline bool Duration::has_seconds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Duration::set_has_seconds() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Duration::clear_has_seconds() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Duration::clear_seconds() {
  seconds_ = GOOGLE_LONGLONG(0);
  clear_has_seconds();
}
inline ::google::protobuf::int64 Duration::seconds() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.Duration.seconds)
  return seconds_;
}
inline void Duration::set_seconds(::google::protobuf::int64 value) {
  set_has_seconds();
  seconds_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.Duration.seconds)
}

// optional int32 nanos = 2;
inline bool Duration::has_nanos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Duration::set_has_nanos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Duration::clear_has_nanos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Duration::clear_nanos() {
  nanos_ = 0;
  clear_has_nanos();
}
inline ::google::protobuf::int32 Duration::nanos() const {
  // @@protoc_insertion_point(field_get:mozilla.safebrowsing.Duration.nanos)
  return nanos_;
}
inline void Duration::set_nanos(::google::protobuf::int32 value) {
  set_has_nanos();
  nanos_ = value;
  // @@protoc_insertion_point(field_set:mozilla.safebrowsing.Duration.nanos)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace safebrowsing
}  // namespace mozilla

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_safebrowsing_2eproto__INCLUDED
