// This file was autogenerated by the `uniffi-bindgen-gecko-js` crate.
// Trust me, you don't want to mess with it!

import { UniFFITypeError } from "moz-src:///toolkit/components/uniffi-js/js/UniFFI.sys.mjs";

// Objects intended to be used in the unit tests
export var UnitTestObjs = {};
/**
 * Handler for a single UniFFI CallbackInterface
 *
 * This class stores objects that implement a callback interface in a handle
 * map, allowing them to be referenced by the Rust code using an integer
 * handle.
 *
 * While the callback object is stored in the map, it allows the Rust code to
 * call methods on the object using the callback object handle, a method id,
 * and an ArrayBuffer packed with the method arguments.
 *
 * When the Rust code drops its reference, it sends a call with the methodId=0,
 * which causes callback object to be removed from the map.
 */
class UniFFICallbackHandler {
    #name;
    #interfaceId;
    #handleCounter;
    #handleMap;
    #methodHandlers;
    #allowNewCallbacks

    /**
     * Create a UniFFICallbackHandler
     * @param {string} name - Human-friendly name for this callback interface
     * @param {int} interfaceId - Interface ID for this CallbackInterface.
     * @param {UniFFICallbackMethodHandler[]} methodHandlers -- UniFFICallbackHandler for each method, in the same order as the UDL file
     */
     constructor(name, interfaceId, methodHandlers) {
        this.#name = name;
        this.#interfaceId = interfaceId;
        this.#handleCounter = 0;
        this.#handleMap = new Map();
        this.#methodHandlers = methodHandlers;
        this.#allowNewCallbacks = true;

        UniFFIScaffolding.registerCallbackHandler(this.#interfaceId, this);
        Services.obs.addObserver(this, "xpcom-shutdown");
     }

    /**
     * Store a callback object in the handle map and return the handle
     *
     * @param {obj} callbackObj - Object that implements the callback interface
     * @returns {int} - Handle for this callback object, this is what gets passed back to Rust.
     */
    storeCallbackObj(callbackObj) {
        if (!this.#allowNewCallbacks) {
            throw new UniFFIError(`No new callbacks allowed for ${this.#name}`);
        }
        const handle = this.#handleCounter;
        this.#handleCounter += 1;
        this.#handleMap.set(handle, new UniFFICallbackHandleMapEntry(callbackObj, Components.stack.caller.formattedStack.trim()));
        return handle;
    }

    /**
     * Get a previously stored callback object
     *
     * @param {int} handle - Callback object handle, returned from `storeCallbackObj()`
     * @returns {obj} - Callback object
     */
    getCallbackObj(handle) {
        const callbackObj = this.#handleMap.get(handle).callbackObj;
        if (callbackObj === undefined) {
            throw new UniFFIError(`${this.#name}: invalid callback handle id: ${handle}`);
        }
        return callbackObj;
    }

    /**
     * Get a UniFFICallbackMethodHandler
     *
     * @param {int} methodId - index of the method
     * @returns {UniFFICallbackMethodHandler}
     */
    getMethodHandler(methodId) {
        const methodHandler = this.#methodHandlers[methodId];
        if (methodHandler === undefined) {
            throw new UniFFIError(`${this.#name}: invalid method id: ${methodId}`)
        }
        return methodHandler;
    }

    /**
     * Set if new callbacks are allowed for this handler
     *
     * This is called with false during shutdown to ensure the callback maps don't
     * prevent JS objects from being GCed.
     */
    setAllowNewCallbacks(allow) {
        this.#allowNewCallbacks = allow
    }

    /**
     * Check that no callbacks are currently registered
     *
     * If there are callbacks registered a UniFFIError will be thrown.  This is
     * called during shutdown to generate an alert if there are leaked callback
     * interfaces.
     */
    assertNoRegisteredCallbacks() {
        if (this.#handleMap.size > 0) {
            const entry = this.#handleMap.values().next().value;
            throw new UniFFIError(`UniFFI interface ${this.#name} has ${this.#handleMap.size} registered callbacks at xpcom-shutdown. This likely indicates a UniFFI callback leak.\nStack trace for the first leaked callback:\n${entry.stackTrace}.`);
        }
    }

    /**
     * Invoke a method on a stored callback object
     * @param {int} handle - Object handle
     * @param {int} methodId - Method index (0-based)
     * @param {UniFFIScaffoldingValue[]} args - Arguments to pass to the method
     */
    call(handle, methodId, ...args) {
        try {
            const callbackObj = this.getCallbackObj(handle);
            const methodHandler = this.getMethodHandler(methodId);
            methodHandler.call(callbackObj, args);
        } catch (e) {
            console.error(`internal error invoking callback: ${e}`)
        }
    }

    /**
     * Invoke a method on a stored callback object
     * @param {int} handle - Object handle
     * @param {int} methodId - Method index (0-based)
     * @param {UniFFIScaffoldingValue[]} args - Arguments to pass to the method
     */
    async callAsync(handle, methodId, ...args) {
        const callbackObj = this.getCallbackObj(handle);
        const methodHandler = this.getMethodHandler(methodId);
        try {
            const returnValue = await methodHandler.call(callbackObj, args);
            return methodHandler.lowerReturn(returnValue);
        } catch(e) {
            return methodHandler.lowerError(e)
        }
    }

    /**
     * Destroy a stored callback object
     * @param {int} handle - Object handle
     */
    destroy(handle) {
        this.#handleMap.delete(handle);
    }

    /**
     * xpcom-shutdown observer method
     *
     * This handles:
     *  - Deregistering ourselves as the UniFFI callback handler
     *  - Checks for any leftover stored callbacks which indicate memory leaks
     */
    observe(aSubject, aTopic, aData) {
        if (aTopic == "xpcom-shutdown") {
            try {
                this.setAllowNewCallbacks(false);
                this.assertNoRegisteredCallbacks();
                UniFFIScaffolding.deregisterCallbackHandler(this.#interfaceId);
            } catch (ex) {
                console.error(`UniFFI Callback interface error during xpcom-shutdown: ${ex}`);
                Cc["@mozilla.org/xpcom/debug;1"]
                    .getService(Ci.nsIDebug2)
                    .abort(ex.filename, ex.lineNumber);
            }
         }
    }
}

/**
 * Handles calling a single method for a callback interface
 */
class UniFFICallbackMethodHandler {
    #name;
    #argsConverters;
    #returnConverter;
    #errorConverter;

    /**
     * Create a UniFFICallbackMethodHandler

     * @param {string} name -- Name of the method to call on the callback object
     * @param {FfiConverter[]} argsConverters - FfiConverter for each argument type
     */
    constructor(name, argsConverters, returnConverter, errorConverter) {
        this.#name = name;
        this.#argsConverters = argsConverters;
        this.#returnConverter = returnConverter;
        this.#errorConverter = errorConverter;
    }

     call(callbackObj, args) {
        const convertedArgs = this.#argsConverters.map((converter, i) => converter.lift(args[i]));
        return callbackObj[this.#name](...convertedArgs);
    }

    lowerReturn(returnValue) {
        return {
            code: "success",
            data: this.#returnConverter(returnValue),
        };
    }

    lowerError(error) {
        return {
            code: "error",
            data: this.#errorConverter(error),
        };
    }
}

/**
 * UniFFICallbackHandler.handleMap entry
 *
 * @property callbackObj - Callback object, this must implement the callback interface.
 * @property {string} stackTrace - Stack trace from when the callback object was registered.  This is used to proved extra context when debugging leaked callback objects.
 */
class UniFFICallbackHandleMapEntry {
    constructor(callbackObj, stackTrace) {
        this.callbackObj = callbackObj;
        this.stackTrace = stackTrace
    }
}


let lazy = {};

ChromeUtils.defineLazyGetter(lazy, "decoder", () => new TextDecoder());
ChromeUtils.defineLazyGetter(lazy, "encoder", () => new TextEncoder());

// Write/Read data to/from an ArrayBuffer
class ArrayBufferDataStream {
    constructor(arrayBuffer) {
        this.dataView = new DataView(arrayBuffer);
        this.pos = 0;
    }

    readUint8() {
        let rv = this.dataView.getUint8(this.pos);
        this.pos += 1;
        return rv;
    }

    writeUint8(value) {
        this.dataView.setUint8(this.pos, value);
        this.pos += 1;
    }

    readUint16() {
        let rv = this.dataView.getUint16(this.pos);
        this.pos += 2;
        return rv;
    }

    writeUint16(value) {
        this.dataView.setUint16(this.pos, value);
        this.pos += 2;
    }

    readUint32() {
        let rv = this.dataView.getUint32(this.pos);
        this.pos += 4;
        return rv;
    }

    writeUint32(value) {
        this.dataView.setUint32(this.pos, value);
        this.pos += 4;
    }

    readUint64() {
        let rv = this.dataView.getBigUint64(this.pos);
        this.pos += 8;
        return Number(rv);
    }

    writeUint64(value) {
        this.dataView.setBigUint64(this.pos, BigInt(value));
        this.pos += 8;
    }


    readInt8() {
        let rv = this.dataView.getInt8(this.pos);
        this.pos += 1;
        return rv;
    }

    writeInt8(value) {
        this.dataView.setInt8(this.pos, value);
        this.pos += 1;
    }

    readInt16() {
        let rv = this.dataView.getInt16(this.pos);
        this.pos += 2;
        return rv;
    }

    writeInt16(value) {
        this.dataView.setInt16(this.pos, value);
        this.pos += 2;
    }

    readInt32() {
        let rv = this.dataView.getInt32(this.pos);
        this.pos += 4;
        return rv;
    }

    writeInt32(value) {
        this.dataView.setInt32(this.pos, value);
        this.pos += 4;
    }

    readInt64() {
        let rv = this.dataView.getBigInt64(this.pos);
        this.pos += 8;
        return Number(rv);
    }

    writeInt64(value) {
        this.dataView.setBigInt64(this.pos, BigInt(value));
        this.pos += 8;
    }

    readFloat32() {
        let rv = this.dataView.getFloat32(this.pos);
        this.pos += 4;
        return rv;
    }

    writeFloat32(value) {
        this.dataView.setFloat32(this.pos, value);
        this.pos += 4;
    }

    readFloat64() {
        let rv = this.dataView.getFloat64(this.pos);
        this.pos += 8;
        return rv;
    }

    writeFloat64(value) {
        this.dataView.setFloat64(this.pos, value);
        this.pos += 8;
    }


    writeString(value) {
      // Note: in order to efficiently write this data, we first write the
      // string data, reserving 4 bytes for the size.
      const dest = new Uint8Array(this.dataView.buffer, this.pos + 4);
      const encodeResult = lazy.encoder.encodeInto(value, dest);
      if (encodeResult.read != value.length) {
        throw new UniFFIError(
            "writeString: out of space when writing to ArrayBuffer.  Did the computeSize() method returned the wrong result?"
        );
      }
      const size = encodeResult.written;
      // Next, go back and write the size before the string data
      this.dataView.setUint32(this.pos, size);
      // Finally, advance our position past both the size and string data
      this.pos += size + 4;
    }

    readString() {
      const size = this.readUint32();
      const source = new Uint8Array(this.dataView.buffer, this.pos, size)
      const value = lazy.decoder.decode(source);
      this.pos += size;
      return value;
    }

    readBytes() {
      const size = this.readInt32();
      const bytes = new Uint8Array(this.dataView.buffer, this.pos, size);
      this.pos += size;
      return bytes
    }

    writeBytes(value) {
      this.writeUint32(value.length);
      value.forEach((elt) => {
        this.writeUint8(elt);
      })
    }

    // Reads a pointer from the data stream
    // UniFFI Pointers are **always** 8 bytes long. That is enforced
    // by the C++ and Rust Scaffolding code.
    readPointer(pointerId) {
        const res = UniFFIScaffolding.readPointer(pointerId, this.dataView.buffer, this.pos);
        this.pos += 8;
        return res;
    }

    // Writes a pointer into the data stream
    // UniFFI Pointers are **always** 8 bytes long. That is enforced
    // by the C++ and Rust Scaffolding code.
    writePointer(pointerId, value) {
        UniFFIScaffolding.writePointer(pointerId, value, this.dataView.buffer, this.pos);
        this.pos += 8;
    }
}

function handleRustResult(result, liftCallback, liftErrCallback) {
    switch (result.code) {
        case "success":
            return liftCallback(result.data);

        case "error":
            throw liftErrCallback(result.data);

        case "internal-error":
            if (result.data) {
                throw new UniFFIInternalError(FfiConverterString.lift(result.data));
            } else {
                throw new UniFFIInternalError("Unknown error");
            }

        default:
            throw new UniFFIError(`Unexpected status code: ${result.code}`);
    }
}

class UniFFIError {
    constructor(message) {
        this.message = message;
    }

    toString() {
        return `UniFFIError: ${this.message}`
    }
}

class UniFFIInternalError extends UniFFIError {}

// Base class for FFI converters
class FfiConverter {
    // throw `UniFFITypeError` if a value to be converted has an invalid type
    static checkType(value) {
        if (value === undefined ) {
            throw new UniFFITypeError(`undefined`);
        }
        if (value === null ) {
            throw new UniFFITypeError(`null`);
        }
    }
}

// Base class for FFI converters that lift/lower by reading/writing to an ArrayBuffer
class FfiConverterArrayBuffer extends FfiConverter {
    static lift(buf) {
        return this.read(new ArrayBufferDataStream(buf));
    }

    static lower(value) {
        const buf = new ArrayBuffer(this.computeSize(value));
        const dataStream = new ArrayBufferDataStream(buf);
        this.write(dataStream, value);
        return buf;
    }

    /**
     * Computes the size of the value.
     *
     * @param {*} _value
     * @return {number}
     */
    static computeSize(_value) {
        throw new UniFFIInternalError("computeSize() should be declared in the derived class");
    }

    /**
     * Reads the type from a data stream.
     *
     * @param {ArrayBufferDataStream} _dataStream
     * @returns {any}
     */
    static read(_dataStream) {
        throw new UniFFIInternalError("read() should be declared in the derived class");
    }

    /**
     * Writes the type to a data stream.
     *
     * @param {ArrayBufferDataStream} _dataStream
     * @param {any} _value
     */
    static write(_dataStream, _value) {
        throw new UniFFIInternalError("write() should be declared in the derived class");
    }

}

// Symbols that are used to ensure that Object constructors
// can only be used with a proper UniFFI pointer
const uniffiObjectPtr = Symbol("uniffiObjectPtr");
const constructUniffiObject = Symbol("constructUniffiObject");
UnitTestObjs.uniffiObjectPtr = uniffiObjectPtr;
/**
 * asyncCallbackInterfaceCallGetValue
 */
export async function asyncCallbackInterfaceCallGetValue(
    v) {
   
FfiConverterTypeTestAsyncCallbackInterface.checkType(v);
const result = await UniFFIScaffolding.callAsync(
    111, // uniffi_uniffi_bindings_tests_fn_func_async_callback_interface_call_get_value
    FfiConverterTypeTestAsyncCallbackInterface.lower(v),
)
return handleRustResult(
    result,
    FfiConverterUInt32.lift.bind(FfiConverterUInt32),
    null,
)
}

/**
 * asyncCallbackInterfaceCallThrowError
 */
export async function asyncCallbackInterfaceCallThrowError(
    v) {
   
FfiConverterTypeTestAsyncCallbackInterface.checkType(v);
const result = await UniFFIScaffolding.callAsync(
    112, // uniffi_uniffi_bindings_tests_fn_func_async_callback_interface_call_throw_error
    FfiConverterTypeTestAsyncCallbackInterface.lower(v),
)
return handleRustResult(
    result,
    (result) => undefined,
    FfiConverterTypeTestError.lift.bind(FfiConverterTypeTestError),
)
}

/**
 * asyncRoundtripF32
 */
export async function asyncRoundtripF32(
    v) {
   
FfiConverterFloat32.checkType(v);
const result = await UniFFIScaffolding.callAsync(
    113, // uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_f32
    FfiConverterFloat32.lower(v),
)
return handleRustResult(
    result,
    FfiConverterFloat32.lift.bind(FfiConverterFloat32),
    null,
)
}

/**
 * asyncRoundtripF64
 */
export async function asyncRoundtripF64(
    v) {
   
FfiConverterFloat64.checkType(v);
const result = await UniFFIScaffolding.callAsync(
    114, // uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_f64
    FfiConverterFloat64.lower(v),
)
return handleRustResult(
    result,
    FfiConverterFloat64.lift.bind(FfiConverterFloat64),
    null,
)
}

/**
 * asyncRoundtripI16
 */
export async function asyncRoundtripI16(
    v) {
   
FfiConverterInt16.checkType(v);
const result = await UniFFIScaffolding.callAsync(
    115, // uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_i16
    FfiConverterInt16.lower(v),
)
return handleRustResult(
    result,
    FfiConverterInt16.lift.bind(FfiConverterInt16),
    null,
)
}

/**
 * asyncRoundtripI32
 */
export async function asyncRoundtripI32(
    v) {
   
FfiConverterInt32.checkType(v);
const result = await UniFFIScaffolding.callAsync(
    116, // uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_i32
    FfiConverterInt32.lower(v),
)
return handleRustResult(
    result,
    FfiConverterInt32.lift.bind(FfiConverterInt32),
    null,
)
}

/**
 * asyncRoundtripI64
 */
export async function asyncRoundtripI64(
    v) {
   
FfiConverterInt64.checkType(v);
const result = await UniFFIScaffolding.callAsync(
    117, // uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_i64
    FfiConverterInt64.lower(v),
)
return handleRustResult(
    result,
    FfiConverterInt64.lift.bind(FfiConverterInt64),
    null,
)
}

/**
 * asyncRoundtripI8
 */
export async function asyncRoundtripI8(
    v) {
   
FfiConverterInt8.checkType(v);
const result = await UniFFIScaffolding.callAsync(
    118, // uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_i8
    FfiConverterInt8.lower(v),
)
return handleRustResult(
    result,
    FfiConverterInt8.lift.bind(FfiConverterInt8),
    null,
)
}

/**
 * asyncRoundtripMap
 */
export async function asyncRoundtripMap(
    v) {
   
FfiConverterMapStringString.checkType(v);
const result = await UniFFIScaffolding.callAsync(
    119, // uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_map
    FfiConverterMapStringString.lower(v),
)
return handleRustResult(
    result,
    FfiConverterMapStringString.lift.bind(FfiConverterMapStringString),
    null,
)
}

/**
 * asyncRoundtripObj
 */
export async function asyncRoundtripObj(
    v) {
   
FfiConverterTypeAsyncInterface.checkType(v);
const result = await UniFFIScaffolding.callAsync(
    120, // uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_obj
    FfiConverterTypeAsyncInterface.lower(v),
)
return handleRustResult(
    result,
    FfiConverterTypeAsyncInterface.lift.bind(FfiConverterTypeAsyncInterface),
    null,
)
}

/**
 * asyncRoundtripString
 */
export async function asyncRoundtripString(
    v) {
   
FfiConverterString.checkType(v);
const result = await UniFFIScaffolding.callAsync(
    121, // uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_string
    FfiConverterString.lower(v),
)
return handleRustResult(
    result,
    FfiConverterString.lift.bind(FfiConverterString),
    null,
)
}

/**
 * asyncRoundtripU16
 */
export async function asyncRoundtripU16(
    v) {
   
FfiConverterUInt16.checkType(v);
const result = await UniFFIScaffolding.callAsync(
    122, // uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_u16
    FfiConverterUInt16.lower(v),
)
return handleRustResult(
    result,
    FfiConverterUInt16.lift.bind(FfiConverterUInt16),
    null,
)
}

/**
 * asyncRoundtripU32
 */
export async function asyncRoundtripU32(
    v) {
   
FfiConverterUInt32.checkType(v);
const result = await UniFFIScaffolding.callAsync(
    123, // uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_u32
    FfiConverterUInt32.lower(v),
)
return handleRustResult(
    result,
    FfiConverterUInt32.lift.bind(FfiConverterUInt32),
    null,
)
}

/**
 * asyncRoundtripU64
 */
export async function asyncRoundtripU64(
    v) {
   
FfiConverterUInt64.checkType(v);
const result = await UniFFIScaffolding.callAsync(
    124, // uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_u64
    FfiConverterUInt64.lower(v),
)
return handleRustResult(
    result,
    FfiConverterUInt64.lift.bind(FfiConverterUInt64),
    null,
)
}

/**
 * asyncRoundtripU8
 */
export async function asyncRoundtripU8(
    v) {
   
FfiConverterUInt8.checkType(v);
const result = await UniFFIScaffolding.callAsync(
    125, // uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_u8
    FfiConverterUInt8.lower(v),
)
return handleRustResult(
    result,
    FfiConverterUInt8.lift.bind(FfiConverterUInt8),
    null,
)
}

/**
 * asyncRoundtripVec
 */
export async function asyncRoundtripVec(
    v) {
   
FfiConverterSequenceUInt32.checkType(v);
const result = await UniFFIScaffolding.callAsync(
    126, // uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_vec
    FfiConverterSequenceUInt32.lower(v),
)
return handleRustResult(
    result,
    FfiConverterSequenceUInt32.lift.bind(FfiConverterSequenceUInt32),
    null,
)
}

/**
 * asyncThrowError
 */
export async function asyncThrowError() {
   
const result = await UniFFIScaffolding.callAsync(
    127, // uniffi_uniffi_bindings_tests_fn_func_async_throw_error
)
return handleRustResult(
    result,
    (result) => undefined,
    FfiConverterTypeTestError.lift.bind(FfiConverterTypeTestError),
)
}

/**
 * cloneInterface
 */
export function cloneInterface(
    int) {
   
FfiConverterTypeTestInterface.checkType(int);
const result = UniFFIScaffolding.callSync(
    128, // uniffi_uniffi_bindings_tests_fn_func_clone_interface
    FfiConverterTypeTestInterface.lower(int),
)
return handleRustResult(
    result,
    FfiConverterTypeTestInterface.lift.bind(FfiConverterTypeTestInterface),
    null,
)
}

/**
 * funcWithDefault
 */
export function funcWithDefault(
    arg = "DEFAULT") {
   
FfiConverterString.checkType(arg);
const result = UniFFIScaffolding.callSync(
    129, // uniffi_uniffi_bindings_tests_fn_func_func_with_default
    FfiConverterString.lower(arg),
)
return handleRustResult(
    result,
    FfiConverterString.lift.bind(FfiConverterString),
    null,
)
}

/**
 * funcWithError
 */
export function funcWithError(
    input) {
   
FfiConverterUInt32.checkType(input);
const result = UniFFIScaffolding.callSync(
    130, // uniffi_uniffi_bindings_tests_fn_func_func_with_error
    FfiConverterUInt32.lower(input),
)
return handleRustResult(
    result,
    (result) => undefined,
    FfiConverterTypeTestError.lift.bind(FfiConverterTypeTestError),
)
}

/**
 * funcWithFlatError
 */
export function funcWithFlatError(
    input) {
   
FfiConverterUInt32.checkType(input);
const result = UniFFIScaffolding.callSync(
    131, // uniffi_uniffi_bindings_tests_fn_func_func_with_flat_error
    FfiConverterUInt32.lower(input),
)
return handleRustResult(
    result,
    (result) => undefined,
    FfiConverterTypeTestFlatError.lift.bind(FfiConverterTypeTestFlatError),
)
}

/**
 * Test a multi-word argument.  `the_argument` should be normalized to the naming style of the
 * foreign language.
 */
export function funcWithMultiWordArg(
    theArgument) {
   
FfiConverterString.checkType(theArgument);
const result = UniFFIScaffolding.callSync(
    132, // uniffi_uniffi_bindings_tests_fn_func_func_with_multi_word_arg
    FfiConverterString.lower(theArgument),
)
return handleRustResult(
    result,
    FfiConverterString.lift.bind(FfiConverterString),
    null,
)
}

/**
 * invokeTestCallbackInterfaceMethod
 */
export function invokeTestCallbackInterfaceMethod(
    cbi) {
   
FfiConverterTypeTestCallbackInterface.checkType(cbi);
const result = UniFFIScaffolding.callSync(
    133, // uniffi_uniffi_bindings_tests_fn_func_invoke_test_callback_interface_method
    FfiConverterTypeTestCallbackInterface.lower(cbi),
)
return handleRustResult(
    result,
    FfiConverterUInt32.lift.bind(FfiConverterUInt32),
    null,
)
}

/**
 * roundtripBool
 */
export function roundtripBool(
    a) {
   
FfiConverterBoolean.checkType(a);
const result = UniFFIScaffolding.callSync(
    134, // uniffi_uniffi_bindings_tests_fn_func_roundtrip_bool
    FfiConverterBoolean.lower(a),
)
return handleRustResult(
    result,
    FfiConverterBoolean.lift.bind(FfiConverterBoolean),
    null,
)
}

/**
 * roundtripComplexCompound
 */
export function roundtripComplexCompound(
    a) {
   
FfiConverterOptionalSequenceMapStringUInt32.checkType(a);
const result = UniFFIScaffolding.callSync(
    135, // uniffi_uniffi_bindings_tests_fn_func_roundtrip_complex_compound
    FfiConverterOptionalSequenceMapStringUInt32.lower(a),
)
return handleRustResult(
    result,
    FfiConverterOptionalSequenceMapStringUInt32.lift.bind(FfiConverterOptionalSequenceMapStringUInt32),
    null,
)
}

/**
 * roundtripComplexEnum
 */
export function roundtripComplexEnum(
    en) {
   
FfiConverterTypeComplexEnum.checkType(en);
const result = UniFFIScaffolding.callSync(
    136, // uniffi_uniffi_bindings_tests_fn_func_roundtrip_complex_enum
    FfiConverterTypeComplexEnum.lower(en),
)
return handleRustResult(
    result,
    FfiConverterTypeComplexEnum.lift.bind(FfiConverterTypeComplexEnum),
    null,
)
}

/**
 * roundtripComplexRec
 */
export function roundtripComplexRec(
    rec) {
   
FfiConverterTypeComplexRec.checkType(rec);
const result = UniFFIScaffolding.callSync(
    137, // uniffi_uniffi_bindings_tests_fn_func_roundtrip_complex_rec
    FfiConverterTypeComplexRec.lower(rec),
)
return handleRustResult(
    result,
    FfiConverterTypeComplexRec.lift.bind(FfiConverterTypeComplexRec),
    null,
)
}

/**
 * roundtripCustomType
 */
export function roundtripCustomType(
    handle) {
   
FfiConverterTypeHandle.checkType(handle);
const result = UniFFIScaffolding.callSync(
    138, // uniffi_uniffi_bindings_tests_fn_func_roundtrip_custom_type
    FfiConverterTypeHandle.lower(handle),
)
return handleRustResult(
    result,
    FfiConverterTypeHandle.lift.bind(FfiConverterTypeHandle),
    null,
)
}

/**
 * roundtripEnumNoData
 */
export function roundtripEnumNoData(
    en) {
   
FfiConverterTypeEnumNoData.checkType(en);
const result = UniFFIScaffolding.callSync(
    139, // uniffi_uniffi_bindings_tests_fn_func_roundtrip_enum_no_data
    FfiConverterTypeEnumNoData.lower(en),
)
return handleRustResult(
    result,
    FfiConverterTypeEnumNoData.lift.bind(FfiConverterTypeEnumNoData),
    null,
)
}

/**
 * roundtripEnumWithData
 */
export function roundtripEnumWithData(
    en) {
   
FfiConverterTypeEnumWithData.checkType(en);
const result = UniFFIScaffolding.callSync(
    140, // uniffi_uniffi_bindings_tests_fn_func_roundtrip_enum_with_data
    FfiConverterTypeEnumWithData.lower(en),
)
return handleRustResult(
    result,
    FfiConverterTypeEnumWithData.lift.bind(FfiConverterTypeEnumWithData),
    null,
)
}

/**
 * roundtripF32
 */
export function roundtripF32(
    a) {
   
FfiConverterFloat32.checkType(a);
const result = UniFFIScaffolding.callSync(
    141, // uniffi_uniffi_bindings_tests_fn_func_roundtrip_f32
    FfiConverterFloat32.lower(a),
)
return handleRustResult(
    result,
    FfiConverterFloat32.lift.bind(FfiConverterFloat32),
    null,
)
}

/**
 * roundtripF64
 */
export function roundtripF64(
    a) {
   
FfiConverterFloat64.checkType(a);
const result = UniFFIScaffolding.callSync(
    142, // uniffi_uniffi_bindings_tests_fn_func_roundtrip_f64
    FfiConverterFloat64.lower(a),
)
return handleRustResult(
    result,
    FfiConverterFloat64.lift.bind(FfiConverterFloat64),
    null,
)
}

/**
 * roundtripHashMap
 */
export function roundtripHashMap(
    a) {
   
FfiConverterMapStringUInt32.checkType(a);
const result = UniFFIScaffolding.callSync(
    143, // uniffi_uniffi_bindings_tests_fn_func_roundtrip_hash_map
    FfiConverterMapStringUInt32.lower(a),
)
return handleRustResult(
    result,
    FfiConverterMapStringUInt32.lift.bind(FfiConverterMapStringUInt32),
    null,
)
}

/**
 * roundtripI16
 */
export function roundtripI16(
    a) {
   
FfiConverterInt16.checkType(a);
const result = UniFFIScaffolding.callSync(
    144, // uniffi_uniffi_bindings_tests_fn_func_roundtrip_i16
    FfiConverterInt16.lower(a),
)
return handleRustResult(
    result,
    FfiConverterInt16.lift.bind(FfiConverterInt16),
    null,
)
}

/**
 * roundtripI32
 */
export function roundtripI32(
    a) {
   
FfiConverterInt32.checkType(a);
const result = UniFFIScaffolding.callSync(
    145, // uniffi_uniffi_bindings_tests_fn_func_roundtrip_i32
    FfiConverterInt32.lower(a),
)
return handleRustResult(
    result,
    FfiConverterInt32.lift.bind(FfiConverterInt32),
    null,
)
}

/**
 * roundtripI64
 */
export function roundtripI64(
    a) {
   
FfiConverterInt64.checkType(a);
const result = UniFFIScaffolding.callSync(
    146, // uniffi_uniffi_bindings_tests_fn_func_roundtrip_i64
    FfiConverterInt64.lower(a),
)
return handleRustResult(
    result,
    FfiConverterInt64.lift.bind(FfiConverterInt64),
    null,
)
}

/**
 * roundtripI8
 */
export function roundtripI8(
    a) {
   
FfiConverterInt8.checkType(a);
const result = UniFFIScaffolding.callSync(
    147, // uniffi_uniffi_bindings_tests_fn_func_roundtrip_i8
    FfiConverterInt8.lower(a),
)
return handleRustResult(
    result,
    FfiConverterInt8.lift.bind(FfiConverterInt8),
    null,
)
}

/**
 * roundtripOption
 */
export function roundtripOption(
    a) {
   
FfiConverterOptionalUInt32.checkType(a);
const result = UniFFIScaffolding.callSync(
    148, // uniffi_uniffi_bindings_tests_fn_func_roundtrip_option
    FfiConverterOptionalUInt32.lower(a),
)
return handleRustResult(
    result,
    FfiConverterOptionalUInt32.lift.bind(FfiConverterOptionalUInt32),
    null,
)
}

/**
 * roundtripSimpleRec
 */
export async function roundtripSimpleRec(
    rec) {
   
FfiConverterTypeSimpleRec.checkType(rec);
const result = await UniFFIScaffolding.callAsyncWrapper(
    149, // uniffi_uniffi_bindings_tests_fn_func_roundtrip_simple_rec
    FfiConverterTypeSimpleRec.lower(rec),
)
return handleRustResult(
    result,
    FfiConverterTypeSimpleRec.lift.bind(FfiConverterTypeSimpleRec),
    null,
)
}

/**
 * roundtripString
 */
export function roundtripString(
    a) {
   
FfiConverterString.checkType(a);
const result = UniFFIScaffolding.callSync(
    150, // uniffi_uniffi_bindings_tests_fn_func_roundtrip_string
    FfiConverterString.lower(a),
)
return handleRustResult(
    result,
    FfiConverterString.lift.bind(FfiConverterString),
    null,
)
}

/**
 * roundtripU16
 */
export function roundtripU16(
    a) {
   
FfiConverterUInt16.checkType(a);
const result = UniFFIScaffolding.callSync(
    151, // uniffi_uniffi_bindings_tests_fn_func_roundtrip_u16
    FfiConverterUInt16.lower(a),
)
return handleRustResult(
    result,
    FfiConverterUInt16.lift.bind(FfiConverterUInt16),
    null,
)
}

/**
 * roundtripU32
 */
export function roundtripU32(
    a) {
   
FfiConverterUInt32.checkType(a);
const result = UniFFIScaffolding.callSync(
    152, // uniffi_uniffi_bindings_tests_fn_func_roundtrip_u32
    FfiConverterUInt32.lower(a),
)
return handleRustResult(
    result,
    FfiConverterUInt32.lift.bind(FfiConverterUInt32),
    null,
)
}

/**
 * roundtripU64
 */
export function roundtripU64(
    a) {
   
FfiConverterUInt64.checkType(a);
const result = UniFFIScaffolding.callSync(
    153, // uniffi_uniffi_bindings_tests_fn_func_roundtrip_u64
    FfiConverterUInt64.lower(a),
)
return handleRustResult(
    result,
    FfiConverterUInt64.lift.bind(FfiConverterUInt64),
    null,
)
}

/**
 * roundtripU8
 */
export function roundtripU8(
    a) {
   
FfiConverterUInt8.checkType(a);
const result = UniFFIScaffolding.callSync(
    154, // uniffi_uniffi_bindings_tests_fn_func_roundtrip_u8
    FfiConverterUInt8.lower(a),
)
return handleRustResult(
    result,
    FfiConverterUInt8.lift.bind(FfiConverterUInt8),
    null,
)
}

/**
 * roundtripVec
 */
export function roundtripVec(
    a) {
   
FfiConverterSequenceUInt32.checkType(a);
const result = UniFFIScaffolding.callSync(
    155, // uniffi_uniffi_bindings_tests_fn_func_roundtrip_vec
    FfiConverterSequenceUInt32.lower(a),
)
return handleRustResult(
    result,
    FfiConverterSequenceUInt32.lift.bind(FfiConverterSequenceUInt32),
    null,
)
}

/**
 * Complex test: input a bunch of different values and add them together
 */
export function sumWithManyTypes(
    a, 
    b, 
    c, 
    d, 
    e, 
    f, 
    g, 
    h, 
    i, 
    j, 
    negate) {
   
FfiConverterUInt8.checkType(a);
FfiConverterInt8.checkType(b);
FfiConverterUInt16.checkType(c);
FfiConverterInt16.checkType(d);
FfiConverterUInt32.checkType(e);
FfiConverterInt32.checkType(f);
FfiConverterUInt64.checkType(g);
FfiConverterInt64.checkType(h);
FfiConverterFloat32.checkType(i);
FfiConverterFloat64.checkType(j);
FfiConverterBoolean.checkType(negate);
const result = UniFFIScaffolding.callSync(
    156, // uniffi_uniffi_bindings_tests_fn_func_sum_with_many_types
    FfiConverterUInt8.lower(a),
    FfiConverterInt8.lower(b),
    FfiConverterUInt16.lower(c),
    FfiConverterInt16.lower(d),
    FfiConverterUInt32.lower(e),
    FfiConverterInt32.lower(f),
    FfiConverterUInt64.lower(g),
    FfiConverterInt64.lower(h),
    FfiConverterFloat32.lower(i),
    FfiConverterFloat64.lower(j),
    FfiConverterBoolean.lower(negate),
)
return handleRustResult(
    result,
    FfiConverterFloat64.lift.bind(FfiConverterFloat64),
    null,
)
}

/**
 * swapTestInterfaces
 */
export function swapTestInterfaces(
    interfaces) {
   
FfiConverterTypeTwoTestInterfaces.checkType(interfaces);
const result = UniFFIScaffolding.callSync(
    157, // uniffi_uniffi_bindings_tests_fn_func_swap_test_interfaces
    FfiConverterTypeTwoTestInterfaces.lower(interfaces),
)
return handleRustResult(
    result,
    FfiConverterTypeTwoTestInterfaces.lift.bind(FfiConverterTypeTwoTestInterfaces),
    null,
)
}

/**
 * testFunc
 */
export function testFunc() {
   
const result = UniFFIScaffolding.callSync(
    158, // uniffi_uniffi_bindings_tests_fn_func_test_func
)
return handleRustResult(
    result,
    (result) => undefined,
    null,
)
}


// Export the FFIConverter object to make external types work.
export class FfiConverterUInt8 extends FfiConverter {
    static checkType(value) {
        super.checkType(value);
        if (!Number.isInteger(value)) {
            throw new UniFFITypeError(`${value} is not an integer`);
        }
        if (value < 0 || value > 256) {
            throw new UniFFITypeError(`${value} exceeds the U8 bounds`);
        }
    }
    static computeSize(_value) {
        return 1;
    }
    static lift(value) {
        return value;
    }
    static lower(value) {
        return value;
    }
    static write(dataStream, value) {
        dataStream.writeUint8(value)
    }
    static read(dataStream) {
        return dataStream.readUint8()
    }
}
// Export the FFIConverter object to make external types work.
export class FfiConverterInt8 extends FfiConverter {
    static checkType(value) {
        super.checkType(value);
        if (!Number.isInteger(value)) {
            throw new UniFFITypeError(`${value} is not an integer`);
        }
        if (value < -128 || value > 127) {
            throw new UniFFITypeError(`${value} exceeds the I8 bounds`);
        }
    }
    static computeSize(_value) {
        return 1;
    }
    static lift(value) {
        return value;
    }
    static lower(value) {
        return value;
    }
    static write(dataStream, value) {
        dataStream.writeInt8(value)
    }
    static read(dataStream) {
        return dataStream.readInt8()
    }
}
// Export the FFIConverter object to make external types work.
export class FfiConverterUInt16 extends FfiConverter {
    static checkType(value) {
        super.checkType(value);
        if (!Number.isInteger(value)) {
            throw new UniFFITypeError(`${value} is not an integer`);
        }
        if (value < 0 || value > 65535) {
            throw new UniFFITypeError(`${value} exceeds the U16 bounds`);
        }
    }
    static computeSize(_value) {
        return 2;
    }
    static lift(value) {
        return value;
    }
    static lower(value) {
        return value;
    }
    static write(dataStream, value) {
        dataStream.writeUint16(value)
    }
    static read(dataStream) {
        return dataStream.readUint16()
    }
}
// Export the FFIConverter object to make external types work.
export class FfiConverterInt16 extends FfiConverter {
    static checkType(value) {
        super.checkType(value);
        if (!Number.isInteger(value)) {
            throw new UniFFITypeError(`${value} is not an integer`);
        }
        if (value < -32768 || value > 32767) {
            throw new UniFFITypeError(`${value} exceeds the I16 bounds`);
        }
    }
    static computeSize(_value) {
        return 2;
    }
    static lift(value) {
        return value;
    }
    static lower(value) {
        return value;
    }
    static write(dataStream, value) {
        dataStream.writeInt16(value)
    }
    static read(dataStream) {
        return dataStream.readInt16()
    }
}
// Export the FFIConverter object to make external types work.
export class FfiConverterUInt32 extends FfiConverter {
    static checkType(value) {
        super.checkType(value);
        if (!Number.isInteger(value)) {
            throw new UniFFITypeError(`${value} is not an integer`);
        }
        if (value < 0 || value > 4294967295) {
            throw new UniFFITypeError(`${value} exceeds the U32 bounds`);
        }
    }
    static computeSize(_value) {
        return 4;
    }
    static lift(value) {
        return value;
    }
    static lower(value) {
        return value;
    }
    static write(dataStream, value) {
        dataStream.writeUint32(value)
    }
    static read(dataStream) {
        return dataStream.readUint32()
    }
}
// Export the FFIConverter object to make external types work.
export class FfiConverterInt32 extends FfiConverter {
    static checkType(value) {
        super.checkType(value);
        if (!Number.isInteger(value)) {
            throw new UniFFITypeError(`${value} is not an integer`);
        }
        if (value < -2147483648 || value > 2147483647) {
            throw new UniFFITypeError(`${value} exceeds the I32 bounds`);
        }
    }
    static computeSize(_value) {
        return 4;
    }
    static lift(value) {
        return value;
    }
    static lower(value) {
        return value;
    }
    static write(dataStream, value) {
        dataStream.writeInt32(value)
    }
    static read(dataStream) {
        return dataStream.readInt32()
    }
}
// Export the FFIConverter object to make external types work.
export class FfiConverterUInt64 extends FfiConverter {
    static checkType(value) {
        super.checkType(value);
        if (!Number.isSafeInteger(value)) {
            throw new UniFFITypeError(`${value} exceeds the safe integer bounds`);
        }
        if (value < 0) {
            throw new UniFFITypeError(`${value} exceeds the U64 bounds`);
        }
    }
    static computeSize(_value) {
        return 8;
    }
    static lift(value) {
        return value;
    }
    static lower(value) {
        return value;
    }
    static write(dataStream, value) {
        dataStream.writeUint64(value)
    }
    static read(dataStream) {
        return dataStream.readUint64()
    }
}
// Export the FFIConverter object to make external types work.
export class FfiConverterInt64 extends FfiConverter {
    static checkType(value) {
        super.checkType(value);
        if (!Number.isSafeInteger(value)) {
            throw new UniFFITypeError(`${value} exceeds the safe integer bounds`);
        }
    }
    static computeSize(_value) {
        return 8;
    }
    static lift(value) {
        return value;
    }
    static lower(value) {
        return value;
    }
    static write(dataStream, value) {
        dataStream.writeInt64(value)
    }
    static read(dataStream) {
        return dataStream.readInt64()
    }
}
// Export the FFIConverter object to make external types work.
export class FfiConverterFloat32 extends FfiConverter {
    static computeSize(_value) {
        return 4;
    }
    static lift(value) {
        return value;
    }
    static lower(value) {
        return value;
    }
    static write(dataStream, value) {
        dataStream.writeFloat32(value)
    }
    static read(dataStream) {
        return dataStream.readFloat32()
    }
}
// Export the FFIConverter object to make external types work.
export class FfiConverterFloat64 extends FfiConverter {
    static computeSize(_value) {
        return 8;
    }
    static lift(value) {
        return value;
    }
    static lower(value) {
        return value;
    }
    static write(dataStream, value) {
        dataStream.writeFloat64(value)
    }
    static read(dataStream) {
        return dataStream.readFloat64()
    }
}
// Export the FFIConverter object to make external types work.
export class FfiConverterString extends FfiConverter {
    static checkType(value) {
        super.checkType(value);
        if (typeof value !== "string") {
            throw new UniFFITypeError(`${value} is not a string`);
        }
    }

    static lift(buf) {
        const utf8Arr = new Uint8Array(buf);
        return lazy.decoder.decode(utf8Arr);
    }
    static lower(value) {
        return lazy.encoder.encode(value).buffer;
    }

    static write(dataStream, value) {
        dataStream.writeString(value);
    }

    static read(dataStream) {
        return dataStream.readString();
    }

    static computeSize(value) {
        return 4 + lazy.encoder.encode(value).length
    }
}
/**
 * SimpleRec
 */
export class SimpleRec {
    constructor(
        {
            a
        } = {
            a: undefined
        }
    ) {
        try {
            FfiConverterUInt8.checkType(a)
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart("a");
            }
            throw e;
        }
        /**
         * a
         */
        this.a = a;
    }

    equals(other) {
        return (
            this.a == other.a
        )
    }
}

// Export the FFIConverter object to make external types work.
export class FfiConverterTypeSimpleRec extends FfiConverterArrayBuffer {
    static read(dataStream) {
        return new SimpleRec({
            a: FfiConverterUInt8.read(dataStream),
        });
    }
    static write(dataStream, value) {
        FfiConverterUInt8.write(dataStream, value.a);
    }

    static computeSize(value) {
        let totalSize = 0;
        totalSize += FfiConverterUInt8.computeSize(value.a);
        return totalSize
    }

    static checkType(value) {
        super.checkType(value);
        if (!(value instanceof SimpleRec)) {
            throw new UniFFITypeError(`Expected 'SimpleRec', found '${typeof value}'`);
        }
        try {
            FfiConverterUInt8.checkType(value.a);
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart(".a");
            }
            throw e;
        }
    }
}
/**
 * ComplexRec
 */
export class ComplexRec {
    constructor(
        {
            fieldU8, 
            fieldI8, 
            fieldU16, 
            fieldI16, 
            fieldU32, 
            fieldI32, 
            fieldU64, 
            fieldI64, 
            fieldF32, 
            fieldF64, 
            fieldString= "DefaultString", 
            fieldRec
        } = {
            fieldU8: undefined, 
            fieldI8: undefined, 
            fieldU16: undefined, 
            fieldI16: undefined, 
            fieldU32: undefined, 
            fieldI32: undefined, 
            fieldU64: undefined, 
            fieldI64: undefined, 
            fieldF32: undefined, 
            fieldF64: undefined, 
            fieldString: undefined, 
            fieldRec: undefined
        }
    ) {
        try {
            FfiConverterUInt8.checkType(fieldU8)
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart("fieldU8");
            }
            throw e;
        }
        try {
            FfiConverterInt8.checkType(fieldI8)
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart("fieldI8");
            }
            throw e;
        }
        try {
            FfiConverterUInt16.checkType(fieldU16)
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart("fieldU16");
            }
            throw e;
        }
        try {
            FfiConverterInt16.checkType(fieldI16)
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart("fieldI16");
            }
            throw e;
        }
        try {
            FfiConverterUInt32.checkType(fieldU32)
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart("fieldU32");
            }
            throw e;
        }
        try {
            FfiConverterInt32.checkType(fieldI32)
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart("fieldI32");
            }
            throw e;
        }
        try {
            FfiConverterUInt64.checkType(fieldU64)
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart("fieldU64");
            }
            throw e;
        }
        try {
            FfiConverterInt64.checkType(fieldI64)
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart("fieldI64");
            }
            throw e;
        }
        try {
            FfiConverterFloat32.checkType(fieldF32)
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart("fieldF32");
            }
            throw e;
        }
        try {
            FfiConverterFloat64.checkType(fieldF64)
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart("fieldF64");
            }
            throw e;
        }
        try {
            FfiConverterString.checkType(fieldString)
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart("fieldString");
            }
            throw e;
        }
        try {
            FfiConverterTypeSimpleRec.checkType(fieldRec)
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart("fieldRec");
            }
            throw e;
        }
        /**
         * fieldU8
         */
        this.fieldU8 = fieldU8;
        /**
         * fieldI8
         */
        this.fieldI8 = fieldI8;
        /**
         * fieldU16
         */
        this.fieldU16 = fieldU16;
        /**
         * fieldI16
         */
        this.fieldI16 = fieldI16;
        /**
         * fieldU32
         */
        this.fieldU32 = fieldU32;
        /**
         * fieldI32
         */
        this.fieldI32 = fieldI32;
        /**
         * fieldU64
         */
        this.fieldU64 = fieldU64;
        /**
         * fieldI64
         */
        this.fieldI64 = fieldI64;
        /**
         * fieldF32
         */
        this.fieldF32 = fieldF32;
        /**
         * fieldF64
         */
        this.fieldF64 = fieldF64;
        /**
         * fieldString
         */
        this.fieldString = fieldString;
        /**
         * fieldRec
         */
        this.fieldRec = fieldRec;
    }

    equals(other) {
        return (
            this.fieldU8 == other.fieldU8
            && this.fieldI8 == other.fieldI8
            && this.fieldU16 == other.fieldU16
            && this.fieldI16 == other.fieldI16
            && this.fieldU32 == other.fieldU32
            && this.fieldI32 == other.fieldI32
            && this.fieldU64 == other.fieldU64
            && this.fieldI64 == other.fieldI64
            && this.fieldF32 == other.fieldF32
            && this.fieldF64 == other.fieldF64
            && this.fieldString == other.fieldString
            && this.fieldRec.equals(other.fieldRec)
        )
    }
}

// Export the FFIConverter object to make external types work.
export class FfiConverterTypeComplexRec extends FfiConverterArrayBuffer {
    static read(dataStream) {
        return new ComplexRec({
            fieldU8: FfiConverterUInt8.read(dataStream),
            fieldI8: FfiConverterInt8.read(dataStream),
            fieldU16: FfiConverterUInt16.read(dataStream),
            fieldI16: FfiConverterInt16.read(dataStream),
            fieldU32: FfiConverterUInt32.read(dataStream),
            fieldI32: FfiConverterInt32.read(dataStream),
            fieldU64: FfiConverterUInt64.read(dataStream),
            fieldI64: FfiConverterInt64.read(dataStream),
            fieldF32: FfiConverterFloat32.read(dataStream),
            fieldF64: FfiConverterFloat64.read(dataStream),
            fieldString: FfiConverterString.read(dataStream),
            fieldRec: FfiConverterTypeSimpleRec.read(dataStream),
        });
    }
    static write(dataStream, value) {
        FfiConverterUInt8.write(dataStream, value.fieldU8);
        FfiConverterInt8.write(dataStream, value.fieldI8);
        FfiConverterUInt16.write(dataStream, value.fieldU16);
        FfiConverterInt16.write(dataStream, value.fieldI16);
        FfiConverterUInt32.write(dataStream, value.fieldU32);
        FfiConverterInt32.write(dataStream, value.fieldI32);
        FfiConverterUInt64.write(dataStream, value.fieldU64);
        FfiConverterInt64.write(dataStream, value.fieldI64);
        FfiConverterFloat32.write(dataStream, value.fieldF32);
        FfiConverterFloat64.write(dataStream, value.fieldF64);
        FfiConverterString.write(dataStream, value.fieldString);
        FfiConverterTypeSimpleRec.write(dataStream, value.fieldRec);
    }

    static computeSize(value) {
        let totalSize = 0;
        totalSize += FfiConverterUInt8.computeSize(value.fieldU8);
        totalSize += FfiConverterInt8.computeSize(value.fieldI8);
        totalSize += FfiConverterUInt16.computeSize(value.fieldU16);
        totalSize += FfiConverterInt16.computeSize(value.fieldI16);
        totalSize += FfiConverterUInt32.computeSize(value.fieldU32);
        totalSize += FfiConverterInt32.computeSize(value.fieldI32);
        totalSize += FfiConverterUInt64.computeSize(value.fieldU64);
        totalSize += FfiConverterInt64.computeSize(value.fieldI64);
        totalSize += FfiConverterFloat32.computeSize(value.fieldF32);
        totalSize += FfiConverterFloat64.computeSize(value.fieldF64);
        totalSize += FfiConverterString.computeSize(value.fieldString);
        totalSize += FfiConverterTypeSimpleRec.computeSize(value.fieldRec);
        return totalSize
    }

    static checkType(value) {
        super.checkType(value);
        if (!(value instanceof ComplexRec)) {
            throw new UniFFITypeError(`Expected 'ComplexRec', found '${typeof value}'`);
        }
        try {
            FfiConverterUInt8.checkType(value.fieldU8);
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart(".fieldU8");
            }
            throw e;
        }
        try {
            FfiConverterInt8.checkType(value.fieldI8);
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart(".fieldI8");
            }
            throw e;
        }
        try {
            FfiConverterUInt16.checkType(value.fieldU16);
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart(".fieldU16");
            }
            throw e;
        }
        try {
            FfiConverterInt16.checkType(value.fieldI16);
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart(".fieldI16");
            }
            throw e;
        }
        try {
            FfiConverterUInt32.checkType(value.fieldU32);
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart(".fieldU32");
            }
            throw e;
        }
        try {
            FfiConverterInt32.checkType(value.fieldI32);
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart(".fieldI32");
            }
            throw e;
        }
        try {
            FfiConverterUInt64.checkType(value.fieldU64);
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart(".fieldU64");
            }
            throw e;
        }
        try {
            FfiConverterInt64.checkType(value.fieldI64);
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart(".fieldI64");
            }
            throw e;
        }
        try {
            FfiConverterFloat32.checkType(value.fieldF32);
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart(".fieldF32");
            }
            throw e;
        }
        try {
            FfiConverterFloat64.checkType(value.fieldF64);
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart(".fieldF64");
            }
            throw e;
        }
        try {
            FfiConverterString.checkType(value.fieldString);
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart(".fieldString");
            }
            throw e;
        }
        try {
            FfiConverterTypeSimpleRec.checkType(value.fieldRec);
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart(".fieldRec");
            }
            throw e;
        }
    }
}
/**
 * RecWithDefault
 */
export class RecWithDefault {
    constructor(
        {
            a= 42
        } = {
            a: undefined
        }
    ) {
        try {
            FfiConverterUInt8.checkType(a)
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart("a");
            }
            throw e;
        }
        /**
         * a
         */
        this.a = a;
    }

    equals(other) {
        return (
            this.a == other.a
        )
    }
}

// Export the FFIConverter object to make external types work.
export class FfiConverterTypeRecWithDefault extends FfiConverterArrayBuffer {
    static read(dataStream) {
        return new RecWithDefault({
            a: FfiConverterUInt8.read(dataStream),
        });
    }
    static write(dataStream, value) {
        FfiConverterUInt8.write(dataStream, value.a);
    }

    static computeSize(value) {
        let totalSize = 0;
        totalSize += FfiConverterUInt8.computeSize(value.a);
        return totalSize
    }

    static checkType(value) {
        super.checkType(value);
        if (!(value instanceof RecWithDefault)) {
            throw new UniFFITypeError(`Expected 'RecWithDefault', found '${typeof value}'`);
        }
        try {
            FfiConverterUInt8.checkType(value.a);
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart(".a");
            }
            throw e;
        }
    }
}
/**
 * TestInterface
 */
export class TestInterface {
    // Use `init` to instantiate this class.
    // DO NOT USE THIS CONSTRUCTOR DIRECTLY
    constructor(opts) {
        if (!Object.prototype.hasOwnProperty.call(opts, constructUniffiObject)) {
            throw new UniFFIError("Attempting to construct an int using the JavaScript constructor directly" +
            "Please use a UDL defined constructor, or the init function for the primary constructor")
        }
        if (!(opts[constructUniffiObject] instanceof UniFFIPointer)) {
            throw new UniFFIError("Attempting to create a UniFFI object with a pointer that is not an instance of UniFFIPointer")
        }
        this[uniffiObjectPtr] = opts[constructUniffiObject];
    }
    
    static init(
        value) {
       
        FfiConverterUInt32.checkType(value);
        const result = UniFFIScaffolding.callSync(
            159, // uniffi_uniffi_bindings_tests_fn_constructor_testinterface_new
            FfiConverterUInt32.lower(value),
        )
        return handleRustResult(
            result,
            FfiConverterTypeTestInterface.lift.bind(FfiConverterTypeTestInterface),
            null,
        )
    }

    /**
     * getValue
     */
    getValue() {
       
        const result = UniFFIScaffolding.callSync(
            160, // uniffi_uniffi_bindings_tests_fn_method_testinterface_get_value
            FfiConverterTypeTestInterface.lower(this),
        )
        return handleRustResult(
            result,
            FfiConverterUInt32.lift.bind(FfiConverterUInt32),
            null,
        )
    }

    /**
     * Get the current reference count for this object
     * 
     * The count does not include the extra reference needed to call this method.
     */
    refCount() {
       
        const result = UniFFIScaffolding.callSync(
            161, // uniffi_uniffi_bindings_tests_fn_method_testinterface_ref_count
            FfiConverterTypeTestInterface.lower(this),
        )
        return handleRustResult(
            result,
            FfiConverterUInt32.lift.bind(FfiConverterUInt32),
            null,
        )
    }

}

// Export the FFIConverter object to make external types work.
export class FfiConverterTypeTestInterface extends FfiConverter {
    static lift(value) {
        const opts = {};
        opts[constructUniffiObject] = value;
        return new TestInterface(opts);
    }

    static lower(value) {
        const ptr = value[uniffiObjectPtr];
        if (!(ptr instanceof UniFFIPointer)) {
            throw new UniFFITypeError("Object is not a 'TestInterface' instance");
        }
        return ptr;
    }

    static read(dataStream) {
        return this.lift(dataStream.readPointer(14));
    }

    static write(dataStream, value) {
        dataStream.writePointer(14, this.lower(value));
    }

    static computeSize(value) {
        return 8;
    }
}
/**
 * TwoTestInterfaces
 */
export class TwoTestInterfaces {
    constructor(
        {
            first, 
            second
        } = {
            first: undefined, 
            second: undefined
        }
    ) {
        try {
            FfiConverterTypeTestInterface.checkType(first)
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart("first");
            }
            throw e;
        }
        try {
            FfiConverterTypeTestInterface.checkType(second)
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart("second");
            }
            throw e;
        }
        /**
         * first
         */
        this.first = first;
        /**
         * second
         */
        this.second = second;
    }

    equals(other) {
        return (
            this.first == other.first
            && this.second == other.second
        )
    }
}

// Export the FFIConverter object to make external types work.
export class FfiConverterTypeTwoTestInterfaces extends FfiConverterArrayBuffer {
    static read(dataStream) {
        return new TwoTestInterfaces({
            first: FfiConverterTypeTestInterface.read(dataStream),
            second: FfiConverterTypeTestInterface.read(dataStream),
        });
    }
    static write(dataStream, value) {
        FfiConverterTypeTestInterface.write(dataStream, value.first);
        FfiConverterTypeTestInterface.write(dataStream, value.second);
    }

    static computeSize(value) {
        let totalSize = 0;
        totalSize += FfiConverterTypeTestInterface.computeSize(value.first);
        totalSize += FfiConverterTypeTestInterface.computeSize(value.second);
        return totalSize
    }

    static checkType(value) {
        super.checkType(value);
        if (!(value instanceof TwoTestInterfaces)) {
            throw new UniFFITypeError(`Expected 'TwoTestInterfaces', found '${typeof value}'`);
        }
        try {
            FfiConverterTypeTestInterface.checkType(value.first);
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart(".first");
            }
            throw e;
        }
        try {
            FfiConverterTypeTestInterface.checkType(value.second);
        } catch (e) {
            if (e instanceof UniFFITypeError) {
                e.addItemDescriptionPart(".second");
            }
            throw e;
        }
    }
}

/**
 * EnumNoData
 */
export const EnumNoData = {
    /**
     * A
     */
    A: 0,
    /**
     * B
     */
    B: 1,
    /**
     * C
     */
    C: 2,
};
Object.freeze(EnumNoData);

// Export the FFIConverter object to make external types work.
export class FfiConverterTypeEnumNoData extends FfiConverterArrayBuffer {
    static #validValues = Object.values(EnumNoData)

    static read(dataStream) {
        // Use sequential indices (1-based) for the wire format to match the Rust scaffolding
        switch (dataStream.readInt32()) {
            case 1:
                return EnumNoData.A
            case 2:
                return EnumNoData.B
            case 3:
                return EnumNoData.C
            default:
                throw new UniFFITypeError("Unknown EnumNoData variant");
        }
    }

    static write(dataStream, value) {
        // Use sequential indices (1-based) for the wire format to match the Rust scaffolding
        if (value === EnumNoData.A) {
            dataStream.writeInt32(1);
            return;
        }
        if (value === EnumNoData.B) {
            dataStream.writeInt32(2);
            return;
        }
        if (value === EnumNoData.C) {
            dataStream.writeInt32(3);
            return;
        }
        throw new UniFFITypeError("Unknown EnumNoData variant");
    }

    static computeSize(value) {
        return 4;
    }

    static checkType(value) {
      // Check that the value is a valid enum variant
      if (!this.#validValues.includes(value)) {
          throw new UniFFITypeError(`${value} is not a valid value for EnumNoData`);
      }
    }
}

/**
 * EnumWithData
 */
export class EnumWithData {}
/**
 * A
 */
EnumWithData.A = class extends EnumWithData{
   constructor({value = undefined } = {}) {
                super();
            try {
                FfiConverterUInt8.checkType(value);
            } catch (e) {
                if (e instanceof UniFFITypeError) {
                    e.addItemDescriptionPart("value");
                }
                throw e;
            }
            this.value = value;
    }
}
/**
 * B
 */
EnumWithData.B = class extends EnumWithData{
   constructor({value = undefined } = {}) {
                super();
            try {
                FfiConverterString.checkType(value);
            } catch (e) {
                if (e instanceof UniFFITypeError) {
                    e.addItemDescriptionPart("value");
                }
                throw e;
            }
            this.value = value;
    }
}
/**
 * C
 */
EnumWithData.C = class extends EnumWithData{
   constructor() {
            super();
    }
}

// Export the FFIConverter object to make external types work.
export class FfiConverterTypeEnumWithData extends FfiConverterArrayBuffer {
    static read(dataStream) {
        // Use sequential indices (1-based) for the wire format to match the Rust scaffolding
        switch (dataStream.readInt32()) {
            case 1:
                return new EnumWithData.A({
                    value: FfiConverterUInt8.read(dataStream)
                });
            case 2:
                return new EnumWithData.B({
                    value: FfiConverterString.read(dataStream)
                });
            case 3:
                return new EnumWithData.C();
            default:
                throw new UniFFITypeError("Unknown EnumWithData variant");
        }
    }

    static write(dataStream, value) {
        // Use sequential indices (1-based) for the wire format to match the Rust scaffolding
        if (value instanceof EnumWithData.A) {
            dataStream.writeInt32(1);
            FfiConverterUInt8.write(dataStream, value.value);
            return;
        }
        if (value instanceof EnumWithData.B) {
            dataStream.writeInt32(2);
            FfiConverterString.write(dataStream, value.value);
            return;
        }
        if (value instanceof EnumWithData.C) {
            dataStream.writeInt32(3);
            return;
        }
        throw new UniFFITypeError("Unknown EnumWithData variant");
    }

    static computeSize(value) {
        // Size of the Int indicating the variant
        let totalSize = 4;
        if (value instanceof EnumWithData.A) {
            totalSize += FfiConverterUInt8.computeSize(value.value);
            return totalSize;
        }
        if (value instanceof EnumWithData.B) {
            totalSize += FfiConverterString.computeSize(value.value);
            return totalSize;
        }
        if (value instanceof EnumWithData.C) {
            return totalSize;
        }
        throw new UniFFITypeError("Unknown EnumWithData variant");
    }

    static checkType(value) {
      if (!(value instanceof EnumWithData)) {
        throw new UniFFITypeError(`${value} is not a subclass instance of EnumWithData`);
      }
    }
}

/**
 * ComplexEnum
 */
export class ComplexEnum {}
/**
 * A
 */
ComplexEnum.A = class extends ComplexEnum{
   constructor({value = undefined } = {}) {
                super();
            try {
                FfiConverterTypeEnumNoData.checkType(value);
            } catch (e) {
                if (e instanceof UniFFITypeError) {
                    e.addItemDescriptionPart("value");
                }
                throw e;
            }
            this.value = value;
    }
}
/**
 * B
 */
ComplexEnum.B = class extends ComplexEnum{
   constructor({value = undefined } = {}) {
                super();
            try {
                FfiConverterTypeEnumWithData.checkType(value);
            } catch (e) {
                if (e instanceof UniFFITypeError) {
                    e.addItemDescriptionPart("value");
                }
                throw e;
            }
            this.value = value;
    }
}
/**
 * C
 */
ComplexEnum.C = class extends ComplexEnum{
   constructor({value = undefined } = {}) {
                super();
            try {
                FfiConverterTypeSimpleRec.checkType(value);
            } catch (e) {
                if (e instanceof UniFFITypeError) {
                    e.addItemDescriptionPart("value");
                }
                throw e;
            }
            this.value = value;
    }
}

// Export the FFIConverter object to make external types work.
export class FfiConverterTypeComplexEnum extends FfiConverterArrayBuffer {
    static read(dataStream) {
        // Use sequential indices (1-based) for the wire format to match the Rust scaffolding
        switch (dataStream.readInt32()) {
            case 1:
                return new ComplexEnum.A({
                    value: FfiConverterTypeEnumNoData.read(dataStream)
                });
            case 2:
                return new ComplexEnum.B({
                    value: FfiConverterTypeEnumWithData.read(dataStream)
                });
            case 3:
                return new ComplexEnum.C({
                    value: FfiConverterTypeSimpleRec.read(dataStream)
                });
            default:
                throw new UniFFITypeError("Unknown ComplexEnum variant");
        }
    }

    static write(dataStream, value) {
        // Use sequential indices (1-based) for the wire format to match the Rust scaffolding
        if (value instanceof ComplexEnum.A) {
            dataStream.writeInt32(1);
            FfiConverterTypeEnumNoData.write(dataStream, value.value);
            return;
        }
        if (value instanceof ComplexEnum.B) {
            dataStream.writeInt32(2);
            FfiConverterTypeEnumWithData.write(dataStream, value.value);
            return;
        }
        if (value instanceof ComplexEnum.C) {
            dataStream.writeInt32(3);
            FfiConverterTypeSimpleRec.write(dataStream, value.value);
            return;
        }
        throw new UniFFITypeError("Unknown ComplexEnum variant");
    }

    static computeSize(value) {
        // Size of the Int indicating the variant
        let totalSize = 4;
        if (value instanceof ComplexEnum.A) {
            totalSize += FfiConverterTypeEnumNoData.computeSize(value.value);
            return totalSize;
        }
        if (value instanceof ComplexEnum.B) {
            totalSize += FfiConverterTypeEnumWithData.computeSize(value.value);
            return totalSize;
        }
        if (value instanceof ComplexEnum.C) {
            totalSize += FfiConverterTypeSimpleRec.computeSize(value.value);
            return totalSize;
        }
        throw new UniFFITypeError("Unknown ComplexEnum variant");
    }

    static checkType(value) {
      if (!(value instanceof ComplexEnum)) {
        throw new UniFFITypeError(`${value} is not a subclass instance of ComplexEnum`);
      }
    }
}

/**
 * ExplicitValuedEnum
 */
export const ExplicitValuedEnum = {
    /**
     * FIRST
     */
    FIRST: 1,
    /**
     * SECOND
     */
    SECOND: 2,
    /**
     * FOURTH
     */
    FOURTH: 4,
    /**
     * TENTH
     */
    TENTH: 10,
    /**
     * ELEVENTH
     */
    ELEVENTH: 11,
    /**
     * THIRTEENTH
     */
    THIRTEENTH: 13,
};
Object.freeze(ExplicitValuedEnum);

// Export the FFIConverter object to make external types work.
export class FfiConverterTypeExplicitValuedEnum extends FfiConverterArrayBuffer {
    static #validValues = Object.values(ExplicitValuedEnum)

    static read(dataStream) {
        // Use sequential indices (1-based) for the wire format to match the Rust scaffolding
        switch (dataStream.readInt32()) {
            case 1:
                return ExplicitValuedEnum.FIRST
            case 2:
                return ExplicitValuedEnum.SECOND
            case 3:
                return ExplicitValuedEnum.FOURTH
            case 4:
                return ExplicitValuedEnum.TENTH
            case 5:
                return ExplicitValuedEnum.ELEVENTH
            case 6:
                return ExplicitValuedEnum.THIRTEENTH
            default:
                throw new UniFFITypeError("Unknown ExplicitValuedEnum variant");
        }
    }

    static write(dataStream, value) {
        // Use sequential indices (1-based) for the wire format to match the Rust scaffolding
        if (value === ExplicitValuedEnum.FIRST) {
            dataStream.writeInt32(1);
            return;
        }
        if (value === ExplicitValuedEnum.SECOND) {
            dataStream.writeInt32(2);
            return;
        }
        if (value === ExplicitValuedEnum.FOURTH) {
            dataStream.writeInt32(3);
            return;
        }
        if (value === ExplicitValuedEnum.TENTH) {
            dataStream.writeInt32(4);
            return;
        }
        if (value === ExplicitValuedEnum.ELEVENTH) {
            dataStream.writeInt32(5);
            return;
        }
        if (value === ExplicitValuedEnum.THIRTEENTH) {
            dataStream.writeInt32(6);
            return;
        }
        throw new UniFFITypeError("Unknown ExplicitValuedEnum variant");
    }

    static computeSize(value) {
        return 4;
    }

    static checkType(value) {
      // Check that the value is a valid enum variant
      if (!this.#validValues.includes(value)) {
          throw new UniFFITypeError(`${value} is not a valid value for ExplicitValuedEnum`);
      }
    }
}

/**
 * GappedEnum
 */
export const GappedEnum = {
    /**
     * ONE
     */
    ONE: 10,
    /**
     * TWO
     */
    TWO: 11,
    /**
     * THREE
     */
    THREE: 14,
};
Object.freeze(GappedEnum);

// Export the FFIConverter object to make external types work.
export class FfiConverterTypeGappedEnum extends FfiConverterArrayBuffer {
    static #validValues = Object.values(GappedEnum)

    static read(dataStream) {
        // Use sequential indices (1-based) for the wire format to match the Rust scaffolding
        switch (dataStream.readInt32()) {
            case 1:
                return GappedEnum.ONE
            case 2:
                return GappedEnum.TWO
            case 3:
                return GappedEnum.THREE
            default:
                throw new UniFFITypeError("Unknown GappedEnum variant");
        }
    }

    static write(dataStream, value) {
        // Use sequential indices (1-based) for the wire format to match the Rust scaffolding
        if (value === GappedEnum.ONE) {
            dataStream.writeInt32(1);
            return;
        }
        if (value === GappedEnum.TWO) {
            dataStream.writeInt32(2);
            return;
        }
        if (value === GappedEnum.THREE) {
            dataStream.writeInt32(3);
            return;
        }
        throw new UniFFITypeError("Unknown GappedEnum variant");
    }

    static computeSize(value) {
        return 4;
    }

    static checkType(value) {
      // Check that the value is a valid enum variant
      if (!this.#validValues.includes(value)) {
          throw new UniFFITypeError(`${value} is not a valid value for GappedEnum`);
      }
    }
}

/**
 * Error enum
 */
export class TestError extends Error {}


/**
 * Failure1
 */
export class Failure1 extends TestError {

    constructor(
        ...params
    ) {
        super(...params);
    }
    toString() {
        return `Failure1: ${super.toString()}`
    }
}

/**
 * Failure2
 */
export class Failure2 extends TestError {

    constructor(
        data,
        ...params
    ) {
        const message = `data: ${ data }`;
        super(message, ...params);
        this.data = data;
    }
    toString() {
        return `Failure2: ${super.toString()}`
    }
}

// Export the FFIConverter object to make external types work.
export class FfiConverterTypeTestError extends FfiConverterArrayBuffer {
    static read(dataStream) {
        switch (dataStream.readInt32()) {
            case 1:
                return new Failure1(
                    );
            case 2:
                return new Failure2(
                    FfiConverterString.read(dataStream)
                    );
            default:
                throw new UniFFITypeError("Unknown TestError variant");
        }
    }
    static computeSize(value) {
        // Size of the Int indicating the variant
        let totalSize = 4;
        if (value instanceof Failure1) {
            return totalSize;
        }
        if (value instanceof Failure2) {
            totalSize += FfiConverterString.computeSize(value.data);
            return totalSize;
        }
        throw new UniFFITypeError("Unknown TestError variant");
    }
    static write(dataStream, value) {
        if (value instanceof Failure1) {
            dataStream.writeInt32(1);
            return;
        }
        if (value instanceof Failure2) {
            dataStream.writeInt32(2);
            FfiConverterString.write(dataStream, value.data);
            return;
        }
        throw new UniFFITypeError("Unknown TestError variant");
    }

    static errorClass = TestError;
}

/**
 * Flat error enum
 * 
 * The associated data for this won't be across the FFI.  Flat errors are mostly just a historical
 * artifact, but there are some use-cases for them -- for example variants that wrap errors from
 * other crates.
 */
export class TestFlatError extends Error {}


/**
 * Here's an example of a variant that only works with a flat error, `io::Error` is not
 * UniFFI compatible and can't be passed across the FFI.
 */
export class IoError extends TestFlatError {

    constructor(message, ...params) {
        super(...params);
        this.message = message;
    }
    toString() {
        return `IoError: ${super.toString()}`
    }
}

// Export the FFIConverter object to make external types work.
export class FfiConverterTypeTestFlatError extends FfiConverterArrayBuffer {
    static read(dataStream) {
        switch (dataStream.readInt32()) {
            case 1:
                return new IoError(FfiConverterString.read(dataStream));
            default:
                throw new UniFFITypeError("Unknown TestFlatError variant");
        }
    }
    static computeSize(value) {
        // Size of the Int indicating the variant
        let totalSize = 4;
        if (value instanceof IoError) {
            return totalSize;
        }
        throw new UniFFITypeError("Unknown TestFlatError variant");
    }
    static write(dataStream, value) {
        if (value instanceof IoError) {
            dataStream.writeInt32(1);
            return;
        }
        throw new UniFFITypeError("Unknown TestFlatError variant");
    }

    static errorClass = TestFlatError;
}
// Export the FFIConverter object to make external types work.
export class FfiConverterTypeHandle extends FfiConverter {
    static lift(buf) {
        return FfiConverterUInt64.lift(buf);    
    }
    
    static lower(buf) {
        return FfiConverterUInt64.lower(buf);
    }
    
    static write(dataStream, value) {
        FfiConverterUInt64.write(dataStream, value);
    } 
    
    static read(buf) {
        return FfiConverterUInt64.read(buf);
    }
    
    static computeSize(value) {
        return FfiConverterUInt64.computeSize(value);
    }
}

// TODO: We should also allow JS to customize the type eventually.
/**
 * AsyncInterface
 */
export class AsyncInterface {
    // Use `init` to instantiate this class.
    // DO NOT USE THIS CONSTRUCTOR DIRECTLY
    constructor(opts) {
        if (!Object.prototype.hasOwnProperty.call(opts, constructUniffiObject)) {
            throw new UniFFIError("Attempting to construct an int using the JavaScript constructor directly" +
            "Please use a UDL defined constructor, or the init function for the primary constructor")
        }
        if (!(opts[constructUniffiObject] instanceof UniFFIPointer)) {
            throw new UniFFIError("Attempting to create a UniFFI object with a pointer that is not an instance of UniFFIPointer")
        }
        this[uniffiObjectPtr] = opts[constructUniffiObject];
    }
    
    static init(
        name) {
       
        FfiConverterString.checkType(name);
        const result = UniFFIScaffolding.callSync(
            162, // uniffi_uniffi_bindings_tests_fn_constructor_asyncinterface_new
            FfiConverterString.lower(name),
        )
        return handleRustResult(
            result,
            FfiConverterTypeAsyncInterface.lift.bind(FfiConverterTypeAsyncInterface),
            null,
        )
    }

    /**
     * name
     */
    async name() {
       
        const result = await UniFFIScaffolding.callAsync(
            163, // uniffi_uniffi_bindings_tests_fn_method_asyncinterface_name
            FfiConverterTypeAsyncInterface.lower(this),
        )
        return handleRustResult(
            result,
            FfiConverterString.lift.bind(FfiConverterString),
            null,
        )
    }

}

// Export the FFIConverter object to make external types work.
export class FfiConverterTypeAsyncInterface extends FfiConverter {
    static lift(value) {
        const opts = {};
        opts[constructUniffiObject] = value;
        return new AsyncInterface(opts);
    }

    static lower(value) {
        const ptr = value[uniffiObjectPtr];
        if (!(ptr instanceof UniFFIPointer)) {
            throw new UniFFITypeError("Object is not a 'AsyncInterface' instance");
        }
        return ptr;
    }

    static read(dataStream) {
        return this.lift(dataStream.readPointer(15));
    }

    static write(dataStream, value) {
        dataStream.writePointer(15, this.lower(value));
    }

    static computeSize(value) {
        return 8;
    }
}
/**
 * ComplexMethods
 */
export class ComplexMethods {
    // Use `init` to instantiate this class.
    // DO NOT USE THIS CONSTRUCTOR DIRECTLY
    constructor(opts) {
        if (!Object.prototype.hasOwnProperty.call(opts, constructUniffiObject)) {
            throw new UniFFIError("Attempting to construct an int using the JavaScript constructor directly" +
            "Please use a UDL defined constructor, or the init function for the primary constructor")
        }
        if (!(opts[constructUniffiObject] instanceof UniFFIPointer)) {
            throw new UniFFIError("Attempting to create a UniFFI object with a pointer that is not an instance of UniFFIPointer")
        }
        this[uniffiObjectPtr] = opts[constructUniffiObject];
    }
    
    static init() {
       
        const result = UniFFIScaffolding.callSync(
            164, // uniffi_uniffi_bindings_tests_fn_constructor_complexmethods_new
        )
        return handleRustResult(
            result,
            FfiConverterTypeComplexMethods.lift.bind(FfiConverterTypeComplexMethods),
            null,
        )
    }

    /**
     * methodWithDefault
     */
    methodWithDefault(
        arg = "DEFAULT") {
       
        FfiConverterString.checkType(arg);
        const result = UniFFIScaffolding.callSync(
            165, // uniffi_uniffi_bindings_tests_fn_method_complexmethods_method_with_default
            FfiConverterTypeComplexMethods.lower(this),
            FfiConverterString.lower(arg),
        )
        return handleRustResult(
            result,
            FfiConverterString.lift.bind(FfiConverterString),
            null,
        )
    }

    /**
     * methodWithMultiWordArg
     */
    methodWithMultiWordArg(
        theArgument) {
       
        FfiConverterString.checkType(theArgument);
        const result = UniFFIScaffolding.callSync(
            166, // uniffi_uniffi_bindings_tests_fn_method_complexmethods_method_with_multi_word_arg
            FfiConverterTypeComplexMethods.lower(this),
            FfiConverterString.lower(theArgument),
        )
        return handleRustResult(
            result,
            FfiConverterString.lift.bind(FfiConverterString),
            null,
        )
    }

}

// Export the FFIConverter object to make external types work.
export class FfiConverterTypeComplexMethods extends FfiConverter {
    static lift(value) {
        const opts = {};
        opts[constructUniffiObject] = value;
        return new ComplexMethods(opts);
    }

    static lower(value) {
        const ptr = value[uniffiObjectPtr];
        if (!(ptr instanceof UniFFIPointer)) {
            throw new UniFFITypeError("Object is not a 'ComplexMethods' instance");
        }
        return ptr;
    }

    static read(dataStream) {
        return this.lift(dataStream.readPointer(16));
    }

    static write(dataStream, value) {
        dataStream.writePointer(16, this.lower(value));
    }

    static computeSize(value) {
        return 8;
    }
}
// Export the FFIConverter object to make external types work.
export class FfiConverterTypeTestAsyncCallbackInterface extends FfiConverter {
    static lower(callbackObj) {
        return uniffiCallbackHandlerTestAsyncCallbackInterface.storeCallbackObj(callbackObj)
    }

    static lift(handleId) {
        return uniffiCallbackHandlerTestAsyncCallbackInterface.getCallbackObj(handleId)
    }

    static read(dataStream) {
        return this.lift(dataStream.readInt64())
    }

    static write(dataStream, callbackObj) {
        dataStream.writeInt64(this.lower(callbackObj))
    }

    static computeSize(callbackObj) {
        return 8;
    }
}

const uniffiCallbackHandlerTestAsyncCallbackInterface = new UniFFICallbackHandler(
    "TestAsyncCallbackInterface",
    3,
    [
        new UniFFICallbackMethodHandler(
            "getValue",
            [
            ],
            FfiConverterUInt32.lower.bind(FfiConverterUInt32),
            (e) => {
              throw e;
            }
        ),
        new UniFFICallbackMethodHandler(
            "throwError",
            [
            ],
            (result) => undefined,
            (e) => {
              if (e instanceof TestError) {
                return FfiConverterTypeTestError.lower(e);
              }
              throw e;
            }
        ),
    ]
);

// Allow the shutdown-related functionality to be tested in the unit tests
UnitTestObjs.uniffiCallbackHandlerTestAsyncCallbackInterface = uniffiCallbackHandlerTestAsyncCallbackInterface;
// Export the FFIConverter object to make external types work.
export class FfiConverterTypeTestCallbackInterface extends FfiConverter {
    static lower(callbackObj) {
        return uniffiCallbackHandlerTestCallbackInterface.storeCallbackObj(callbackObj)
    }

    static lift(handleId) {
        return uniffiCallbackHandlerTestCallbackInterface.getCallbackObj(handleId)
    }

    static read(dataStream) {
        return this.lift(dataStream.readInt64())
    }

    static write(dataStream, callbackObj) {
        dataStream.writeInt64(this.lower(callbackObj))
    }

    static computeSize(callbackObj) {
        return 8;
    }
}

const uniffiCallbackHandlerTestCallbackInterface = new UniFFICallbackHandler(
    "TestCallbackInterface",
    4,
    [
        new UniFFICallbackMethodHandler(
            "getValue",
            [
            ],
            FfiConverterUInt32.lower.bind(FfiConverterUInt32),
            (e) => {
              throw e;
            }
        ),
    ]
);

// Allow the shutdown-related functionality to be tested in the unit tests
UnitTestObjs.uniffiCallbackHandlerTestCallbackInterface = uniffiCallbackHandlerTestCallbackInterface;
// Export the FFIConverter object to make external types work.
export class FfiConverterMapStringString extends FfiConverterArrayBuffer {
    static read(dataStream) {
        const len = dataStream.readInt32();
        const map = new Map();
        for (let i = 0; i < len; i++) {
            const key = FfiConverterString.read(dataStream);
            const value = FfiConverterString.read(dataStream);
            map.set(key, value);
        }

        return map;
    }

     static write(dataStream, map) {
        dataStream.writeInt32(map.size);
        for (const [key, value] of map) {
            FfiConverterString.write(dataStream, key);
            FfiConverterString.write(dataStream, value);
        }
    }

    static computeSize(map) {
        // The size of the length
        let size = 4;
        for (const [key, value] of map) {
            size += FfiConverterString.computeSize(key);
            size += FfiConverterString.computeSize(value);
        }
        return size;
    }

    static checkType(map) {
        for (const [key, value] of map) {
            try {
                FfiConverterString.checkType(key);
            } catch (e) {
                if (e instanceof UniFFITypeError) {
                    e.addItemDescriptionPart("(key)");
                }
                throw e;
            }

            try {
                FfiConverterString.checkType(value);
            } catch (e) {
                if (e instanceof UniFFITypeError) {
                    e.addItemDescriptionPart(`[${key}]`);
                }
                throw e;
            }
        }
    }
}
// Export the FFIConverter object to make external types work.
export class FfiConverterSequenceUInt32 extends FfiConverterArrayBuffer {
    static read(dataStream) {
        const len = dataStream.readInt32();
        const arr = [];
        for (let i = 0; i < len; i++) {
            arr.push(FfiConverterUInt32.read(dataStream));
        }
        return arr;
    }

    static write(dataStream, value) {
        dataStream.writeInt32(value.length);
        value.forEach((innerValue) => {
            FfiConverterUInt32.write(dataStream, innerValue);
        })
    }

    static computeSize(value) {
        // The size of the length
        let size = 4;
        for (const innerValue of value) {
            size += FfiConverterUInt32.computeSize(innerValue);
        }
        return size;
    }

    static checkType(value) {
        if (!Array.isArray(value)) {
            throw new UniFFITypeError(`${value} is not an array`);
        }
        value.forEach((innerValue, idx) => {
            try {
                FfiConverterUInt32.checkType(innerValue);
            } catch (e) {
                if (e instanceof UniFFITypeError) {
                    e.addItemDescriptionPart(`[${idx}]`);
                }
                throw e;
            }
        })
    }
}
// Export the FFIConverter object to make external types work.
export class FfiConverterBoolean extends FfiConverter {
    static computeSize(_value) {
        return 1;
    }
    static lift(value) {
        return value == 1;
    }
    static lower(value) {
        if (value) {
            return 1;
        } else {
            return 0;
        }
    }
    static write(dataStream, value) {
        dataStream.writeUint8(this.lower(value))
    }
    static read(dataStream) {
        return this.lift(dataStream.readUint8())
    }
}
// Export the FFIConverter object to make external types work.
export class FfiConverterMapStringUInt32 extends FfiConverterArrayBuffer {
    static read(dataStream) {
        const len = dataStream.readInt32();
        const map = new Map();
        for (let i = 0; i < len; i++) {
            const key = FfiConverterString.read(dataStream);
            const value = FfiConverterUInt32.read(dataStream);
            map.set(key, value);
        }

        return map;
    }

     static write(dataStream, map) {
        dataStream.writeInt32(map.size);
        for (const [key, value] of map) {
            FfiConverterString.write(dataStream, key);
            FfiConverterUInt32.write(dataStream, value);
        }
    }

    static computeSize(map) {
        // The size of the length
        let size = 4;
        for (const [key, value] of map) {
            size += FfiConverterString.computeSize(key);
            size += FfiConverterUInt32.computeSize(value);
        }
        return size;
    }

    static checkType(map) {
        for (const [key, value] of map) {
            try {
                FfiConverterString.checkType(key);
            } catch (e) {
                if (e instanceof UniFFITypeError) {
                    e.addItemDescriptionPart("(key)");
                }
                throw e;
            }

            try {
                FfiConverterUInt32.checkType(value);
            } catch (e) {
                if (e instanceof UniFFITypeError) {
                    e.addItemDescriptionPart(`[${key}]`);
                }
                throw e;
            }
        }
    }
}
// Export the FFIConverter object to make external types work.
export class FfiConverterSequenceMapStringUInt32 extends FfiConverterArrayBuffer {
    static read(dataStream) {
        const len = dataStream.readInt32();
        const arr = [];
        for (let i = 0; i < len; i++) {
            arr.push(FfiConverterMapStringUInt32.read(dataStream));
        }
        return arr;
    }

    static write(dataStream, value) {
        dataStream.writeInt32(value.length);
        value.forEach((innerValue) => {
            FfiConverterMapStringUInt32.write(dataStream, innerValue);
        })
    }

    static computeSize(value) {
        // The size of the length
        let size = 4;
        for (const innerValue of value) {
            size += FfiConverterMapStringUInt32.computeSize(innerValue);
        }
        return size;
    }

    static checkType(value) {
        if (!Array.isArray(value)) {
            throw new UniFFITypeError(`${value} is not an array`);
        }
        value.forEach((innerValue, idx) => {
            try {
                FfiConverterMapStringUInt32.checkType(innerValue);
            } catch (e) {
                if (e instanceof UniFFITypeError) {
                    e.addItemDescriptionPart(`[${idx}]`);
                }
                throw e;
            }
        })
    }
}
// Export the FFIConverter object to make external types work.
export class FfiConverterOptionalSequenceMapStringUInt32 extends FfiConverterArrayBuffer {
    static checkType(value) {
        if (value !== undefined && value !== null) {
            FfiConverterSequenceMapStringUInt32.checkType(value)
        }
    }

    static read(dataStream) {
        const code = dataStream.readUint8(0);
        switch (code) {
            case 0:
                return null
            case 1:
                return FfiConverterSequenceMapStringUInt32.read(dataStream)
            default:
                throw new UniFFIError(`Unexpected code: ${code}`);
        }
    }

    static write(dataStream, value) {
        if (value === null || value === undefined) {
            dataStream.writeUint8(0);
            return;
        }
        dataStream.writeUint8(1);
        FfiConverterSequenceMapStringUInt32.write(dataStream, value)
    }

    static computeSize(value) {
        if (value === null || value === undefined) {
            return 1;
        }
        return 1 + FfiConverterSequenceMapStringUInt32.computeSize(value)
    }
}
// Export the FFIConverter object to make external types work.
export class FfiConverterOptionalUInt32 extends FfiConverterArrayBuffer {
    static checkType(value) {
        if (value !== undefined && value !== null) {
            FfiConverterUInt32.checkType(value)
        }
    }

    static read(dataStream) {
        const code = dataStream.readUint8(0);
        switch (code) {
            case 0:
                return null
            case 1:
                return FfiConverterUInt32.read(dataStream)
            default:
                throw new UniFFIError(`Unexpected code: ${code}`);
        }
    }

    static write(dataStream, value) {
        if (value === null || value === undefined) {
            dataStream.writeUint8(0);
            return;
        }
        dataStream.writeUint8(1);
        FfiConverterUInt32.write(dataStream, value)
    }

    static computeSize(value) {
        if (value === null || value === undefined) {
            return 1;
        }
        return 1 + FfiConverterUInt32.computeSize(value)
    }
}
