// -*- mode: Rust -*-

// AUTOGENERATED BY glean_parser.  DO NOT EDIT.

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */


pub enum DynamicLabel { }

pub mod test {
    use crate::private::*;
    #[allow(unused_imports)] // CommonMetricData might be unused, let's avoid warnings
    use glean::CommonMetricData;
    #[allow(unused_imports)] // HistogramType might be unusued, let's avoid warnings
    use glean::HistogramType;
    use once_cell::sync::Lazy;

    #[allow(non_upper_case_globals)]
    /// generated from test.boolean_metric
    ///
    /// A multi-line
    /// description
    pub static boolean_metric: Lazy<BooleanMetric> = Lazy::new(|| {
        let meta =
            CommonMetricData {
                name: "boolean_metric".into(),
                category: "test".into(),
                send_in_pings: vec!["metrics".into()],
                lifetime: Lifetime::Application,
                disabled: false,
                ..Default::default()
            };
        let metric = BooleanMetric::new(BaseMetricId(1), meta)
;
        metric
    });

    #[allow(non_upper_case_globals)]
    /// generated from test.counter_metric
    ///
    /// A multi-line
    /// description
    pub static counter_metric: Lazy<CounterMetric> = Lazy::new(|| {
        let meta =
            CommonMetricData {
                name: "counter_metric".into(),
                category: "test".into(),
                send_in_pings: vec!["metrics".into()],
                lifetime: Lifetime::Application,
                disabled: false,
                ..Default::default()
            };
        let metric = CounterMetric::new(BaseMetricId(2), meta)
;
        metric
    });

    #[allow(non_upper_case_globals)]
    /// generated from test.custom_distribution_metric
    ///
    /// A multi-line
    /// description
    pub static custom_distribution_metric: Lazy<CustomDistributionMetric> = Lazy::new(|| {
        let meta =
            CommonMetricData {
                name: "custom_distribution_metric".into(),
                category: "test".into(),
                send_in_pings: vec!["metrics".into()],
                lifetime: Lifetime::Ping,
                disabled: false,
                ..Default::default()
            };
        let metric = CustomDistributionMetric::new(BaseMetricId(3), meta, 0, 100, 100, HistogramType::Linear)
;
        metric
    });

    #[allow(non_upper_case_globals)]
    /// generated from test.labeled_boolean_metric
    ///
    /// A multi-line
    /// description
    pub static labeled_boolean_metric: Lazy<LabeledMetric<LabeledBooleanMetric, super::DynamicLabel>> = Lazy::new(|| {
        let meta =
            LabeledMetricData::Common {
                cmd: CommonMetricData {
                    name: "labeled_boolean_metric".into(),
                    category: "test".into(),
                    send_in_pings: vec!["metrics".into()],
                    lifetime: Lifetime::Application,
                    disabled: false,
                    ..Default::default()
                },
            };
        let metric = LabeledMetric::new(BaseMetricId(4), meta, None);
        metric
    });

    #[repr(u16)]
    pub enum LabeledBooleanMetricLabelsLabel {
        EOneLabel = 0,
        ETwoLabels = 1,
        EThreeLabels = 2,
        EFourLabels = 3,
        EFiveLabels = 4,
        ESixLabels = 5,
        ESevenLabels = 6,
        EEightLabels = 7,
        ENineLabels = 8,
        ETenLabels = 9,
        __Other__,
    }
    impl From<u16> for LabeledBooleanMetricLabelsLabel {
        fn from(v: u16) -> Self {
            match v {
                0 => Self::EOneLabel,
                1 => Self::ETwoLabels,
                2 => Self::EThreeLabels,
                3 => Self::EFourLabels,
                4 => Self::EFiveLabels,
                5 => Self::ESixLabels,
                6 => Self::ESevenLabels,
                7 => Self::EEightLabels,
                8 => Self::ENineLabels,
                9 => Self::ETenLabels,
                _ => Self::__Other__,
            }
        }
    }
    impl Into<&'static str> for LabeledBooleanMetricLabelsLabel {
        fn into(self) -> &'static str {
            match self {
                Self::EOneLabel => "one_label",
                Self::ETwoLabels => "two_labels",
                Self::EThreeLabels => "three_labels",
                Self::EFourLabels => "four_labels",
                Self::EFiveLabels => "five_labels",
                Self::ESixLabels => "six_labels",
                Self::ESevenLabels => "seven_labels",
                Self::EEightLabels => "eight_labels",
                Self::ENineLabels => "nine_labels",
                Self::ETenLabels => "ten_labels",
                Self::__Other__ => "__other__",
            }
        }
    }
    #[allow(non_upper_case_globals)]
    /// generated from test.labeled_boolean_metric_labels
    ///
    /// A multi-line
    /// description
    pub static labeled_boolean_metric_labels: Lazy<LabeledMetric<LabeledBooleanMetric, LabeledBooleanMetricLabelsLabel>> = Lazy::new(|| {
        let meta =
            LabeledMetricData::Common {
                cmd: CommonMetricData {
                    name: "labeled_boolean_metric_labels".into(),
                    category: "test".into(),
                    send_in_pings: vec!["metrics".into()],
                    lifetime: Lifetime::Application,
                    disabled: false,
                    ..Default::default()
                },
            };
        let metric = LabeledMetric::new(BaseMetricId(5), meta, Some(vec![::std::borrow::Cow::from("eight_labels"), ::std::borrow::Cow::from("five_labels"), ::std::borrow::Cow::from("four_labels"), ::std::borrow::Cow::from("nine_labels"), ::std::borrow::Cow::from("one_label"), ::std::borrow::Cow::from("seven_labels"), ::std::borrow::Cow::from("six_labels"), ::std::borrow::Cow::from("ten_labels"), ::std::borrow::Cow::from("three_labels"), ::std::borrow::Cow::from("two_labels")]));
        metric
    });

    #[allow(non_upper_case_globals)]
    /// generated from test.labeled_counter_metric
    ///
    /// A multi-line
    /// description
    pub static labeled_counter_metric: Lazy<LabeledMetric<LabeledCounterMetric, super::DynamicLabel>> = Lazy::new(|| {
        let meta =
            LabeledMetricData::Common {
                cmd: CommonMetricData {
                    name: "labeled_counter_metric".into(),
                    category: "test".into(),
                    send_in_pings: vec!["metrics".into()],
                    lifetime: Lifetime::Application,
                    disabled: false,
                    ..Default::default()
                },
            };
        let metric = LabeledMetric::new(BaseMetricId(6), meta, None);
        metric
    });

    #[repr(u16)]
    pub enum LabeledCounterMetricLabelsLabel {
        EOneLabel = 0,
        ETwoLabels = 1,
        __Other__,
    }
    impl From<u16> for LabeledCounterMetricLabelsLabel {
        fn from(v: u16) -> Self {
            match v {
                0 => Self::EOneLabel,
                1 => Self::ETwoLabels,
                _ => Self::__Other__,
            }
        }
    }
    impl Into<&'static str> for LabeledCounterMetricLabelsLabel {
        fn into(self) -> &'static str {
            match self {
                Self::EOneLabel => "one_label",
                Self::ETwoLabels => "two_labels",
                Self::__Other__ => "__other__",
            }
        }
    }
    #[allow(non_upper_case_globals)]
    /// generated from test.labeled_counter_metric_labels
    ///
    /// A multi-line
    /// description
    pub static labeled_counter_metric_labels: Lazy<LabeledMetric<LabeledCounterMetric, LabeledCounterMetricLabelsLabel>> = Lazy::new(|| {
        let meta =
            LabeledMetricData::Common {
                cmd: CommonMetricData {
                    name: "labeled_counter_metric_labels".into(),
                    category: "test".into(),
                    send_in_pings: vec!["metrics".into()],
                    lifetime: Lifetime::Application,
                    disabled: false,
                    ..Default::default()
                },
            };
        let metric = LabeledMetric::new(BaseMetricId(7), meta, Some(vec![::std::borrow::Cow::from("one_label"), ::std::borrow::Cow::from("two_labels")]));
        metric
    });

    #[allow(non_upper_case_globals)]
    /// generated from test.labeled_string_metric
    ///
    /// A multi-line
    /// description
    pub static labeled_string_metric: Lazy<LabeledMetric<LabeledStringMetric, super::DynamicLabel>> = Lazy::new(|| {
        let meta =
            LabeledMetricData::Common {
                cmd: CommonMetricData {
                    name: "labeled_string_metric".into(),
                    category: "test".into(),
                    send_in_pings: vec!["metrics".into()],
                    lifetime: Lifetime::Application,
                    disabled: false,
                    ..Default::default()
                },
            };
        let metric = LabeledMetric::new(BaseMetricId(8), meta, None);
        metric
    });

    #[repr(u16)]
    pub enum LabeledStringMetricLabelsLabel {
        EOneLabel = 0,
        ETwoLabels = 1,
        __Other__,
    }
    impl From<u16> for LabeledStringMetricLabelsLabel {
        fn from(v: u16) -> Self {
            match v {
                0 => Self::EOneLabel,
                1 => Self::ETwoLabels,
                _ => Self::__Other__,
            }
        }
    }
    impl Into<&'static str> for LabeledStringMetricLabelsLabel {
        fn into(self) -> &'static str {
            match self {
                Self::EOneLabel => "one_label",
                Self::ETwoLabels => "two_labels",
                Self::__Other__ => "__other__",
            }
        }
    }
    #[allow(non_upper_case_globals)]
    /// generated from test.labeled_string_metric_labels
    ///
    /// A multi-line
    /// description
    pub static labeled_string_metric_labels: Lazy<LabeledMetric<LabeledStringMetric, LabeledStringMetricLabelsLabel>> = Lazy::new(|| {
        let meta =
            LabeledMetricData::Common {
                cmd: CommonMetricData {
                    name: "labeled_string_metric_labels".into(),
                    category: "test".into(),
                    send_in_pings: vec!["metrics".into()],
                    lifetime: Lifetime::Application,
                    disabled: false,
                    ..Default::default()
                },
            };
        let metric = LabeledMetric::new(BaseMetricId(9), meta, Some(vec![::std::borrow::Cow::from("one_label"), ::std::borrow::Cow::from("two_labels")]));
        metric
    });

    #[allow(non_upper_case_globals)]
    /// generated from test.memory_distribution_metric
    ///
    /// A multi-line
    /// description
    pub static memory_distribution_metric: Lazy<MemoryDistributionMetric> = Lazy::new(|| {
        let meta =
            CommonMetricData {
                name: "memory_distribution_metric".into(),
                category: "test".into(),
                send_in_pings: vec!["metrics".into()],
                lifetime: Lifetime::Ping,
                disabled: false,
                ..Default::default()
            };
        let metric = MemoryDistributionMetric::new(BaseMetricId(10), meta, MemoryUnit::Kilobyte)
;
        metric
    });

    #[allow(non_upper_case_globals)]
    /// generated from test.string_list_metric
    ///
    /// A multi-line
    /// description
    pub static string_list_metric: Lazy<StringListMetric> = Lazy::new(|| {
        let meta =
            CommonMetricData {
                name: "string_list_metric".into(),
                category: "test".into(),
                send_in_pings: vec!["metrics".into()],
                lifetime: Lifetime::Application,
                disabled: false,
                ..Default::default()
            };
        let metric = StringListMetric::new(BaseMetricId(11), meta)
;
        metric
    });

    #[allow(non_upper_case_globals)]
    /// generated from test.string_metric
    ///
    /// A multi-line
    /// description
    pub static string_metric: Lazy<StringMetric> = Lazy::new(|| {
        let meta =
            CommonMetricData {
                name: "string_metric".into(),
                category: "test".into(),
                send_in_pings: vec!["metrics".into()],
                lifetime: Lifetime::Application,
                disabled: false,
                ..Default::default()
            };
        let metric = StringMetric::new(BaseMetricId(12), meta)
;
        metric
    });

    #[allow(non_upper_case_globals)]
    /// generated from test.text_metric
    ///
    /// A multi-line
    /// description
    pub static text_metric: Lazy<TextMetric> = Lazy::new(|| {
        let meta =
            CommonMetricData {
                name: "text_metric".into(),
                category: "test".into(),
                send_in_pings: vec!["metrics".into()],
                lifetime: Lifetime::Application,
                disabled: false,
                ..Default::default()
            };
        let metric = TextMetric::new(BaseMetricId(13), meta)
;
        metric
    });

    #[allow(non_upper_case_globals)]
    /// generated from test.timespan_metric
    ///
    /// A multi-line
    /// description
    pub static timespan_metric: Lazy<TimespanMetric> = Lazy::new(|| {
        let meta =
            CommonMetricData {
                name: "timespan_metric".into(),
                category: "test".into(),
                send_in_pings: vec!["metrics".into()],
                lifetime: Lifetime::Application,
                disabled: false,
                ..Default::default()
            };
        let metric = TimespanMetric::new(BaseMetricId(14), meta, TimeUnit::Millisecond)
;
        metric
    });

    #[allow(non_upper_case_globals)]
    /// generated from test.timing_distribution_metric
    ///
    /// A multi-line
    /// description
    pub static timing_distribution_metric: Lazy<TimingDistributionMetric> = Lazy::new(|| {
        let meta =
            CommonMetricData {
                name: "timing_distribution_metric".into(),
                category: "test".into(),
                send_in_pings: vec!["metrics".into()],
                lifetime: Lifetime::Ping,
                disabled: false,
                ..Default::default()
            };
        let metric = TimingDistributionMetric::new(BaseMetricId(15), meta, TimeUnit::Nanosecond)
;
        metric
    });

    #[allow(non_upper_case_globals)]
    /// generated from test.unordered_boolean_metric
    ///
    /// A multi-line
    /// description
    pub static unordered_boolean_metric: Lazy<BooleanMetric> = Lazy::new(|| {
        let meta =
            CommonMetricData {
                name: "unordered_boolean_metric".into(),
                category: "test".into(),
                send_in_pings: vec!["metrics".into()],
                lifetime: Lifetime::Ping,
                disabled: false,
                ..Default::default()
            };
        let metric = BooleanMetric::with_unordered_ipc(BaseMetricId(16), meta)
;
        metric
    });

    #[allow(non_upper_case_globals)]
    /// generated from test.unordered_labeled_boolean_metric
    ///
    /// A multi-line
    /// description
    pub static unordered_labeled_boolean_metric: Lazy<LabeledMetric<LabeledBooleanMetric, super::DynamicLabel>> = Lazy::new(|| {
        let meta =
            LabeledMetricData::Common {
                cmd: CommonMetricData {
                    name: "unordered_labeled_boolean_metric".into(),
                    category: "test".into(),
                    send_in_pings: vec!["metrics".into()],
                    lifetime: Lifetime::Ping,
                    disabled: false,
                    ..Default::default()
                },
            };
        let metric = LabeledMetric::with_unordered_ipc(BaseMetricId(17), meta, None);
        metric
    });

}
pub mod test_nested {
    use crate::private::*;
    #[allow(unused_imports)] // CommonMetricData might be unused, let's avoid warnings
    use glean::CommonMetricData;
    #[allow(unused_imports)] // HistogramType might be unusued, let's avoid warnings
    use glean::HistogramType;
    use once_cell::sync::Lazy;

        pub type AnObjectObject = Vec<AnObjectObjectItem>;

        #[derive(Debug, Hash, Eq, PartialEq, Clone, ::glean::traits::__serde::Serialize, ::glean::traits::__serde::Deserialize)]
    #[allow(non_snake_case)]
    #[serde(deny_unknown_fields)]
    pub struct AnObjectObjectItem {
          #[serde(skip_serializing_if = "Option::is_none")]
          pub colour: Option<String>,
          #[serde(skip_serializing_if = "Option::is_none")]
          pub diameter: Option<i64>,
          #[serde(skip_serializing_if = "Option::is_none")]
          pub CamelCasedParameter: Option<i64>,
    }

    #[allow(non_upper_case_globals)]
    /// generated from test.nested.an_object
    ///
    /// An example object
    pub static an_object: Lazy<ObjectMetric<AnObjectObject>> = Lazy::new(|| {
        let meta =
            CommonMetricData {
                name: "an_object".into(),
                category: "test.nested".into(),
                send_in_pings: vec!["metrics".into()],
                lifetime: Lifetime::Ping,
                disabled: false,
                ..Default::default()
            };
        let metric = ObjectMetric::new(BaseMetricId(18), meta)
;
        #[cfg(feature = "with_gecko")]
        {
            crate::metrics::METRIC_MEM_OPS.with_borrow_mut(|ops| {
                use malloc_size_of::MallocSizeOf;
                super::count_memory_usage(metric.size_of(ops));
            });
        }
        metric
    });

    #[allow(non_upper_case_globals)]
    /// generated from test.nested.datetime_metric
    ///
    /// A multi-line
    /// description
    pub static datetime_metric: Lazy<DatetimeMetric> = Lazy::new(|| {
        let meta =
            CommonMetricData {
                name: "datetime_metric".into(),
                category: "test.nested".into(),
                send_in_pings: vec!["metrics".into()],
                lifetime: Lifetime::Application,
                disabled: false,
                ..Default::default()
            };
        let metric = DatetimeMetric::new(BaseMetricId(19), meta, TimeUnit::Millisecond)
;
        metric
    });

    #[allow(non_upper_case_globals)]
    /// generated from test.nested.event_metric
    ///
    /// A multi-line
    /// description
    pub static event_metric: Lazy<EventMetric<NoExtraKeys>> = Lazy::new(|| {
        let meta =
            CommonMetricData {
                name: "event_metric".into(),
                category: "test.nested".into(),
                send_in_pings: vec!["events".into()],
                lifetime: Lifetime::Ping,
                disabled: false,
                ..Default::default()
            };
        let metric = EventMetric::new(BaseMetricId(20), meta)
;
        #[cfg(feature = "with_gecko")]
        {
            crate::metrics::METRIC_MEM_OPS.with_borrow_mut(|ops| {
                use malloc_size_of::MallocSizeOf;
                super::count_memory_usage(metric.size_of(ops));
            });
        }
        metric
    });

    #[derive(Default, Debug, Clone, Hash, Eq, PartialEq)]
    #[allow(non_snake_case)]
    pub struct EventMetricWithExtraExtra {
        pub r#an_extra_key: Option<String>,
        pub r#another_extra_key: Option<String>,
        pub r#bool_extra: Option<bool>,
        pub r#quantity_extra: Option<u32>,
    }

    impl ExtraKeys for EventMetricWithExtraExtra {
        const ALLOWED_KEYS: &'static [&'static str] = &["an_extra_key", "another_extra_key", "bool_extra", "quantity_extra"];

        fn into_ffi_extra(self) -> ::std::collections::HashMap<String, String> {
          let mut map = ::std::collections::HashMap::new();
          self.r#an_extra_key.and_then(|val| map.insert("an_extra_key".into(), val.to_string()));
          self.r#another_extra_key.and_then(|val| map.insert("another_extra_key".into(), val.to_string()));
          self.r#bool_extra.and_then(|val| map.insert("bool_extra".into(), val.to_string()));
          self.r#quantity_extra.and_then(|val| map.insert("quantity_extra".into(), val.to_string()));
          map
        }
    }
    #[allow(non_upper_case_globals)]
    /// generated from test.nested.event_metric_with_extra
    ///
    /// A multi-line
    /// description
    pub static event_metric_with_extra: Lazy<EventMetric<EventMetricWithExtraExtra>> = Lazy::new(|| {
        let meta =
            CommonMetricData {
                name: "event_metric_with_extra".into(),
                category: "test.nested".into(),
                send_in_pings: vec!["events".into()],
                lifetime: Lifetime::Ping,
                disabled: false,
                ..Default::default()
            };
        let metric = EventMetric::new(BaseMetricId(21), meta)
;
        #[cfg(feature = "with_gecko")]
        {
            crate::metrics::METRIC_MEM_OPS.with_borrow_mut(|ops| {
                use malloc_size_of::MallocSizeOf;
                super::count_memory_usage(metric.size_of(ops));
            });
        }
        metric
    });

    #[allow(non_upper_case_globals)]
    /// generated from test.nested.external_denominator
    ///
    /// A multi-line
    /// description
    pub static external_denominator: Lazy<DenominatorMetric> = Lazy::new(|| {
        let meta =
            CommonMetricData {
                name: "external_denominator".into(),
                category: "test.nested".into(),
                send_in_pings: vec!["metrics".into()],
                lifetime: Lifetime::Ping,
                disabled: false,
                ..Default::default()
            };
        let metric = DenominatorMetric::new(BaseMetricId(22), meta, vec![CommonMetricData {name: "rate_with_external_denominator".into(), category: "test.nested".into(), send_in_pings: vec!["metrics".into()], lifetime: Lifetime::Ping, disabled: false,  ..Default::default()}, CommonMetricData {name: "rate_with_external_denominator".into(), category: "test2.nested".into(), send_in_pings: vec!["metrics".into()], lifetime: Lifetime::Ping, disabled: true,  ..Default::default()}])
;
        metric
    });

    #[allow(non_upper_case_globals)]
    /// generated from test.nested.optimizable_counter_metric
    ///
    /// A multi-line
    /// description
    pub static optimizable_counter_metric: Lazy<CounterMetric> = Lazy::new(|| {
        CounterMetric::codegen_new(
            23,
            "test.nested",
            "optimizable_counter_metric",
            "metrics"
        )
    });

    #[allow(non_upper_case_globals)]
    /// generated from test.nested.optimizable_disabled_counter_metric
    ///
    /// A multi-line
    /// description
    pub static optimizable_disabled_counter_metric: Lazy<CounterMetric> = Lazy::new(|| {
        CounterMetric::codegen_disabled_new(
            24,
            "test.nested",
            "optimizable_disabled_counter_metric",
            "metrics"
        )
    });

    #[allow(non_upper_case_globals)]
    /// generated from test.nested.quantity_metric
    ///
    /// A multi-line
    /// description
    pub static quantity_metric: Lazy<QuantityMetric> = Lazy::new(|| {
        let meta =
            CommonMetricData {
                name: "quantity_metric".into(),
                category: "test.nested".into(),
                send_in_pings: vec!["metrics".into()],
                lifetime: Lifetime::Ping,
                disabled: false,
                ..Default::default()
            };
        let metric = QuantityMetric::new(BaseMetricId(25), meta)
;
        metric
    });

    #[allow(non_upper_case_globals)]
    /// generated from test.nested.rate_metric
    ///
    /// A multi-line
    /// description
    pub static rate_metric: Lazy<RateMetric> = Lazy::new(|| {
        let meta =
            CommonMetricData {
                name: "rate_metric".into(),
                category: "test.nested".into(),
                send_in_pings: vec!["metrics".into()],
                lifetime: Lifetime::Ping,
                disabled: false,
                ..Default::default()
            };
        let metric = RateMetric::new(BaseMetricId(26), meta)
;
        metric
    });

    #[allow(non_upper_case_globals)]
    /// generated from test.nested.rate_with_external_denominator
    ///
    /// A multi-line
    /// description
    pub static rate_with_external_denominator: Lazy<NumeratorMetric> = Lazy::new(|| {
        let meta =
            CommonMetricData {
                name: "rate_with_external_denominator".into(),
                category: "test.nested".into(),
                send_in_pings: vec!["metrics".into()],
                lifetime: Lifetime::Ping,
                disabled: false,
                ..Default::default()
            };
        let metric = NumeratorMetric::new(BaseMetricId(27), meta)
;
        metric
    });

    #[allow(non_upper_case_globals)]
    /// generated from test.nested.uuid_metric
    ///
    /// A multi-line
    /// description
    pub static uuid_metric: Lazy<UuidMetric> = Lazy::new(|| {
        let meta =
            CommonMetricData {
                name: "uuid_metric".into(),
                category: "test.nested".into(),
                send_in_pings: vec!["metrics".into()],
                lifetime: Lifetime::Application,
                disabled: false,
                ..Default::default()
            };
        let metric = UuidMetric::new(BaseMetricId(28), meta)
;
        metric
    });

}
pub mod test2 {
    use crate::private::*;
    #[allow(unused_imports)] // CommonMetricData might be unused, let's avoid warnings
    use glean::CommonMetricData;
    #[allow(unused_imports)] // HistogramType might be unusued, let's avoid warnings
    use glean::HistogramType;
    use once_cell::sync::Lazy;

    #[allow(non_upper_case_globals)]
    /// generated from test2.boolean_metric
    ///
    /// A multi-line
    /// description
    pub static boolean_metric: Lazy<BooleanMetric> = Lazy::new(|| {
        let meta =
            CommonMetricData {
                name: "boolean_metric".into(),
                category: "test2".into(),
                send_in_pings: vec!["metrics".into()],
                lifetime: Lifetime::Application,
                disabled: true,
                ..Default::default()
            };
        let metric = BooleanMetric::new(BaseMetricId(29), meta)
;
        metric
    });

    #[allow(non_upper_case_globals)]
    /// generated from test2.counter_metric
    ///
    /// A multi-line
    /// description
    pub static counter_metric: Lazy<CounterMetric> = Lazy::new(|| {
        let meta =
            CommonMetricData {
                name: "counter_metric".into(),
                category: "test2".into(),
                send_in_pings: vec!["metrics".into()],
                lifetime: Lifetime::Application,
                disabled: true,
                ..Default::default()
            };
        let metric = CounterMetric::new(BaseMetricId(30), meta)
;
        metric
    });

    #[allow(non_upper_case_globals)]
    /// generated from test2.custom_distribution_metric
    ///
    /// A multi-line
    /// description
    pub static custom_distribution_metric: Lazy<CustomDistributionMetric> = Lazy::new(|| {
        let meta =
            CommonMetricData {
                name: "custom_distribution_metric".into(),
                category: "test2".into(),
                send_in_pings: vec!["metrics".into()],
                lifetime: Lifetime::Ping,
                disabled: true,
                ..Default::default()
            };
        let metric = CustomDistributionMetric::new(BaseMetricId(31), meta, 0, 100, 100, HistogramType::Linear)
;
        metric
    });

    #[allow(non_upper_case_globals)]
    /// generated from test2.labeled_boolean_metric
    ///
    /// A multi-line
    /// description
    pub static labeled_boolean_metric: Lazy<LabeledMetric<LabeledBooleanMetric, super::DynamicLabel>> = Lazy::new(|| {
        let meta =
            LabeledMetricData::Common {
                cmd: CommonMetricData {
                    name: "labeled_boolean_metric".into(),
                    category: "test2".into(),
                    send_in_pings: vec!["metrics".into()],
                    lifetime: Lifetime::Application,
                    disabled: true,
                    ..Default::default()
                },
            };
        let metric = LabeledMetric::new(BaseMetricId(32), meta, None);
        metric
    });

    #[repr(u16)]
    pub enum LabeledBooleanMetricLabelsLabel {
        EOneLabel = 0,
        ETwoLabels = 1,
        EThreeLabels = 2,
        EFourLabels = 3,
        EFiveLabels = 4,
        ESixLabels = 5,
        ESevenLabels = 6,
        EEightLabels = 7,
        ENineLabels = 8,
        ETenLabels = 9,
        __Other__,
    }
    impl From<u16> for LabeledBooleanMetricLabelsLabel {
        fn from(v: u16) -> Self {
            match v {
                0 => Self::EOneLabel,
                1 => Self::ETwoLabels,
                2 => Self::EThreeLabels,
                3 => Self::EFourLabels,
                4 => Self::EFiveLabels,
                5 => Self::ESixLabels,
                6 => Self::ESevenLabels,
                7 => Self::EEightLabels,
                8 => Self::ENineLabels,
                9 => Self::ETenLabels,
                _ => Self::__Other__,
            }
        }
    }
    impl Into<&'static str> for LabeledBooleanMetricLabelsLabel {
        fn into(self) -> &'static str {
            match self {
                Self::EOneLabel => "one_label",
                Self::ETwoLabels => "two_labels",
                Self::EThreeLabels => "three_labels",
                Self::EFourLabels => "four_labels",
                Self::EFiveLabels => "five_labels",
                Self::ESixLabels => "six_labels",
                Self::ESevenLabels => "seven_labels",
                Self::EEightLabels => "eight_labels",
                Self::ENineLabels => "nine_labels",
                Self::ETenLabels => "ten_labels",
                Self::__Other__ => "__other__",
            }
        }
    }
    #[allow(non_upper_case_globals)]
    /// generated from test2.labeled_boolean_metric_labels
    ///
    /// A multi-line
    /// description
    pub static labeled_boolean_metric_labels: Lazy<LabeledMetric<LabeledBooleanMetric, LabeledBooleanMetricLabelsLabel>> = Lazy::new(|| {
        let meta =
            LabeledMetricData::Common {
                cmd: CommonMetricData {
                    name: "labeled_boolean_metric_labels".into(),
                    category: "test2".into(),
                    send_in_pings: vec!["metrics".into()],
                    lifetime: Lifetime::Application,
                    disabled: true,
                    ..Default::default()
                },
            };
        let metric = LabeledMetric::new(BaseMetricId(33), meta, Some(vec![::std::borrow::Cow::from("eight_labels"), ::std::borrow::Cow::from("five_labels"), ::std::borrow::Cow::from("four_labels"), ::std::borrow::Cow::from("nine_labels"), ::std::borrow::Cow::from("one_label"), ::std::borrow::Cow::from("seven_labels"), ::std::borrow::Cow::from("six_labels"), ::std::borrow::Cow::from("ten_labels"), ::std::borrow::Cow::from("three_labels"), ::std::borrow::Cow::from("two_labels")]));
        metric
    });

    #[allow(non_upper_case_globals)]
    /// generated from test2.labeled_counter_metric
    ///
    /// A multi-line
    /// description
    pub static labeled_counter_metric: Lazy<LabeledMetric<LabeledCounterMetric, super::DynamicLabel>> = Lazy::new(|| {
        let meta =
            LabeledMetricData::Common {
                cmd: CommonMetricData {
                    name: "labeled_counter_metric".into(),
                    category: "test2".into(),
                    send_in_pings: vec!["metrics".into()],
                    lifetime: Lifetime::Application,
                    disabled: true,
                    ..Default::default()
                },
            };
        let metric = LabeledMetric::new(BaseMetricId(34), meta, None);
        metric
    });

    #[repr(u16)]
    pub enum LabeledCounterMetricLabelsLabel {
        EOneLabel = 0,
        ETwoLabels = 1,
        __Other__,
    }
    impl From<u16> for LabeledCounterMetricLabelsLabel {
        fn from(v: u16) -> Self {
            match v {
                0 => Self::EOneLabel,
                1 => Self::ETwoLabels,
                _ => Self::__Other__,
            }
        }
    }
    impl Into<&'static str> for LabeledCounterMetricLabelsLabel {
        fn into(self) -> &'static str {
            match self {
                Self::EOneLabel => "one_label",
                Self::ETwoLabels => "two_labels",
                Self::__Other__ => "__other__",
            }
        }
    }
    #[allow(non_upper_case_globals)]
    /// generated from test2.labeled_counter_metric_labels
    ///
    /// A multi-line
    /// description
    pub static labeled_counter_metric_labels: Lazy<LabeledMetric<LabeledCounterMetric, LabeledCounterMetricLabelsLabel>> = Lazy::new(|| {
        let meta =
            LabeledMetricData::Common {
                cmd: CommonMetricData {
                    name: "labeled_counter_metric_labels".into(),
                    category: "test2".into(),
                    send_in_pings: vec!["metrics".into()],
                    lifetime: Lifetime::Application,
                    disabled: true,
                    ..Default::default()
                },
            };
        let metric = LabeledMetric::new(BaseMetricId(35), meta, Some(vec![::std::borrow::Cow::from("one_label"), ::std::borrow::Cow::from("two_labels")]));
        metric
    });

    #[allow(non_upper_case_globals)]
    /// generated from test2.labeled_string_metric
    ///
    /// A multi-line
    /// description
    pub static labeled_string_metric: Lazy<LabeledMetric<LabeledStringMetric, super::DynamicLabel>> = Lazy::new(|| {
        let meta =
            LabeledMetricData::Common {
                cmd: CommonMetricData {
                    name: "labeled_string_metric".into(),
                    category: "test2".into(),
                    send_in_pings: vec!["metrics".into()],
                    lifetime: Lifetime::Application,
                    disabled: true,
                    ..Default::default()
                },
            };
        let metric = LabeledMetric::new(BaseMetricId(36), meta, None);
        metric
    });

    #[repr(u16)]
    pub enum LabeledStringMetricLabelsLabel {
        EOneLabel = 0,
        ETwoLabels = 1,
        __Other__,
    }
    impl From<u16> for LabeledStringMetricLabelsLabel {
        fn from(v: u16) -> Self {
            match v {
                0 => Self::EOneLabel,
                1 => Self::ETwoLabels,
                _ => Self::__Other__,
            }
        }
    }
    impl Into<&'static str> for LabeledStringMetricLabelsLabel {
        fn into(self) -> &'static str {
            match self {
                Self::EOneLabel => "one_label",
                Self::ETwoLabels => "two_labels",
                Self::__Other__ => "__other__",
            }
        }
    }
    #[allow(non_upper_case_globals)]
    /// generated from test2.labeled_string_metric_labels
    ///
    /// A multi-line
    /// description
    pub static labeled_string_metric_labels: Lazy<LabeledMetric<LabeledStringMetric, LabeledStringMetricLabelsLabel>> = Lazy::new(|| {
        let meta =
            LabeledMetricData::Common {
                cmd: CommonMetricData {
                    name: "labeled_string_metric_labels".into(),
                    category: "test2".into(),
                    send_in_pings: vec!["metrics".into()],
                    lifetime: Lifetime::Application,
                    disabled: true,
                    ..Default::default()
                },
            };
        let metric = LabeledMetric::new(BaseMetricId(37), meta, Some(vec![::std::borrow::Cow::from("one_label"), ::std::borrow::Cow::from("two_labels")]));
        metric
    });

    #[allow(non_upper_case_globals)]
    /// generated from test2.memory_distribution_metric
    ///
    /// A multi-line
    /// description
    pub static memory_distribution_metric: Lazy<MemoryDistributionMetric> = Lazy::new(|| {
        let meta =
            CommonMetricData {
                name: "memory_distribution_metric".into(),
                category: "test2".into(),
                send_in_pings: vec!["metrics".into()],
                lifetime: Lifetime::Ping,
                disabled: true,
                ..Default::default()
            };
        let metric = MemoryDistributionMetric::new(BaseMetricId(38), meta, MemoryUnit::Kilobyte)
;
        metric
    });

    #[allow(non_upper_case_globals)]
    /// generated from test2.string_list_metric
    ///
    /// A multi-line
    /// description
    pub static string_list_metric: Lazy<StringListMetric> = Lazy::new(|| {
        let meta =
            CommonMetricData {
                name: "string_list_metric".into(),
                category: "test2".into(),
                send_in_pings: vec!["metrics".into()],
                lifetime: Lifetime::Application,
                disabled: true,
                ..Default::default()
            };
        let metric = StringListMetric::new(BaseMetricId(39), meta)
;
        metric
    });

    #[allow(non_upper_case_globals)]
    /// generated from test2.string_metric
    ///
    /// A multi-line
    /// description
    pub static string_metric: Lazy<StringMetric> = Lazy::new(|| {
        let meta =
            CommonMetricData {
                name: "string_metric".into(),
                category: "test2".into(),
                send_in_pings: vec!["metrics".into()],
                lifetime: Lifetime::Application,
                disabled: true,
                ..Default::default()
            };
        let metric = StringMetric::new(BaseMetricId(40), meta)
;
        metric
    });

    #[allow(non_upper_case_globals)]
    /// generated from test2.text_metric
    ///
    /// A multi-line
    /// description
    pub static text_metric: Lazy<TextMetric> = Lazy::new(|| {
        let meta =
            CommonMetricData {
                name: "text_metric".into(),
                category: "test2".into(),
                send_in_pings: vec!["metrics".into()],
                lifetime: Lifetime::Application,
                disabled: true,
                ..Default::default()
            };
        let metric = TextMetric::new(BaseMetricId(41), meta)
;
        metric
    });

    #[allow(non_upper_case_globals)]
    /// generated from test2.timespan_metric
    ///
    /// A multi-line
    /// description
    pub static timespan_metric: Lazy<TimespanMetric> = Lazy::new(|| {
        let meta =
            CommonMetricData {
                name: "timespan_metric".into(),
                category: "test2".into(),
                send_in_pings: vec!["metrics".into()],
                lifetime: Lifetime::Application,
                disabled: true,
                ..Default::default()
            };
        let metric = TimespanMetric::new(BaseMetricId(42), meta, TimeUnit::Millisecond)
;
        metric
    });

    #[allow(non_upper_case_globals)]
    /// generated from test2.timing_distribution_metric
    ///
    /// A multi-line
    /// description
    pub static timing_distribution_metric: Lazy<TimingDistributionMetric> = Lazy::new(|| {
        let meta =
            CommonMetricData {
                name: "timing_distribution_metric".into(),
                category: "test2".into(),
                send_in_pings: vec!["metrics".into()],
                lifetime: Lifetime::Ping,
                disabled: true,
                ..Default::default()
            };
        let metric = TimingDistributionMetric::new(BaseMetricId(43), meta, TimeUnit::Nanosecond)
;
        metric
    });

    #[allow(non_upper_case_globals)]
    /// generated from test2.unordered_boolean_metric
    ///
    /// A multi-line
    /// description
    pub static unordered_boolean_metric: Lazy<BooleanMetric> = Lazy::new(|| {
        let meta =
            CommonMetricData {
                name: "unordered_boolean_metric".into(),
                category: "test2".into(),
                send_in_pings: vec!["metrics".into()],
                lifetime: Lifetime::Ping,
                disabled: true,
                ..Default::default()
            };
        let metric = BooleanMetric::with_unordered_ipc(BaseMetricId(44), meta)
;
        metric
    });

    #[allow(non_upper_case_globals)]
    /// generated from test2.unordered_labeled_boolean_metric
    ///
    /// A multi-line
    /// description
    pub static unordered_labeled_boolean_metric: Lazy<LabeledMetric<LabeledBooleanMetric, super::DynamicLabel>> = Lazy::new(|| {
        let meta =
            LabeledMetricData::Common {
                cmd: CommonMetricData {
                    name: "unordered_labeled_boolean_metric".into(),
                    category: "test2".into(),
                    send_in_pings: vec!["metrics".into()],
                    lifetime: Lifetime::Ping,
                    disabled: true,
                    ..Default::default()
                },
            };
        let metric = LabeledMetric::with_unordered_ipc(BaseMetricId(45), meta, None);
        metric
    });

}
pub mod test2_nested {
    use crate::private::*;
    #[allow(unused_imports)] // CommonMetricData might be unused, let's avoid warnings
    use glean::CommonMetricData;
    #[allow(unused_imports)] // HistogramType might be unusued, let's avoid warnings
    use glean::HistogramType;
    use once_cell::sync::Lazy;

        pub type AnObjectObject = Vec<AnObjectObjectItem>;

        #[derive(Debug, Hash, Eq, PartialEq, Clone, ::glean::traits::__serde::Serialize, ::glean::traits::__serde::Deserialize)]
    #[allow(non_snake_case)]
    #[serde(deny_unknown_fields)]
    pub struct AnObjectObjectItem {
          #[serde(skip_serializing_if = "Option::is_none")]
          pub colour: Option<String>,
          #[serde(skip_serializing_if = "Option::is_none")]
          pub diameter: Option<i64>,
          #[serde(skip_serializing_if = "Option::is_none")]
          pub CamelCasedParameter: Option<i64>,
    }

    #[allow(non_upper_case_globals)]
    /// generated from test2.nested.an_object
    ///
    /// An example object
    pub static an_object: Lazy<ObjectMetric<AnObjectObject>> = Lazy::new(|| {
        let meta =
            CommonMetricData {
                name: "an_object".into(),
                category: "test2.nested".into(),
                send_in_pings: vec!["metrics".into()],
                lifetime: Lifetime::Ping,
                disabled: true,
                ..Default::default()
            };
        let metric = ObjectMetric::new(BaseMetricId(46), meta)
;
        #[cfg(feature = "with_gecko")]
        {
            crate::metrics::METRIC_MEM_OPS.with_borrow_mut(|ops| {
                use malloc_size_of::MallocSizeOf;
                super::count_memory_usage(metric.size_of(ops));
            });
        }
        metric
    });

    #[allow(non_upper_case_globals)]
    /// generated from test2.nested.datetime_metric
    ///
    /// A multi-line
    /// description
    pub static datetime_metric: Lazy<DatetimeMetric> = Lazy::new(|| {
        let meta =
            CommonMetricData {
                name: "datetime_metric".into(),
                category: "test2.nested".into(),
                send_in_pings: vec!["metrics".into()],
                lifetime: Lifetime::Application,
                disabled: true,
                ..Default::default()
            };
        let metric = DatetimeMetric::new(BaseMetricId(47), meta, TimeUnit::Millisecond)
;
        metric
    });

    #[allow(non_upper_case_globals)]
    /// generated from test2.nested.event_metric
    ///
    /// A multi-line
    /// description
    pub static event_metric: Lazy<EventMetric<NoExtraKeys>> = Lazy::new(|| {
        let meta =
            CommonMetricData {
                name: "event_metric".into(),
                category: "test2.nested".into(),
                send_in_pings: vec!["events".into()],
                lifetime: Lifetime::Ping,
                disabled: true,
                ..Default::default()
            };
        let metric = EventMetric::new(BaseMetricId(48), meta)
;
        #[cfg(feature = "with_gecko")]
        {
            crate::metrics::METRIC_MEM_OPS.with_borrow_mut(|ops| {
                use malloc_size_of::MallocSizeOf;
                super::count_memory_usage(metric.size_of(ops));
            });
        }
        metric
    });

    #[derive(Default, Debug, Clone, Hash, Eq, PartialEq)]
    #[allow(non_snake_case)]
    pub struct EventMetricWithExtraExtra {
        pub r#an_extra_key: Option<String>,
        pub r#another_extra_key: Option<String>,
    }

    impl ExtraKeys for EventMetricWithExtraExtra {
        const ALLOWED_KEYS: &'static [&'static str] = &["an_extra_key", "another_extra_key"];

        fn into_ffi_extra(self) -> ::std::collections::HashMap<String, String> {
          let mut map = ::std::collections::HashMap::new();
          self.r#an_extra_key.and_then(|val| map.insert("an_extra_key".into(), val.to_string()));
          self.r#another_extra_key.and_then(|val| map.insert("another_extra_key".into(), val.to_string()));
          map
        }
    }
    #[allow(non_upper_case_globals)]
    /// generated from test2.nested.event_metric_with_extra
    ///
    /// A multi-line
    /// description
    pub static event_metric_with_extra: Lazy<EventMetric<EventMetricWithExtraExtra>> = Lazy::new(|| {
        let meta =
            CommonMetricData {
                name: "event_metric_with_extra".into(),
                category: "test2.nested".into(),
                send_in_pings: vec!["events".into()],
                lifetime: Lifetime::Ping,
                disabled: true,
                ..Default::default()
            };
        let metric = EventMetric::new(BaseMetricId(49), meta)
;
        #[cfg(feature = "with_gecko")]
        {
            crate::metrics::METRIC_MEM_OPS.with_borrow_mut(|ops| {
                use malloc_size_of::MallocSizeOf;
                super::count_memory_usage(metric.size_of(ops));
            });
        }
        metric
    });

    #[allow(non_upper_case_globals)]
    /// generated from test2.nested.external_denominator
    ///
    /// A multi-line
    /// description
    pub static external_denominator: Lazy<CounterMetric> = Lazy::new(|| {
        CounterMetric::codegen_disabled_new(
            50,
            "test2.nested",
            "external_denominator",
            "metrics"
        )
    });

    #[allow(non_upper_case_globals)]
    /// generated from test2.nested.optimizable_counter_metric
    ///
    /// A multi-line
    /// description
    pub static optimizable_counter_metric: Lazy<CounterMetric> = Lazy::new(|| {
        CounterMetric::codegen_disabled_new(
            51,
            "test2.nested",
            "optimizable_counter_metric",
            "metrics"
        )
    });

    #[allow(non_upper_case_globals)]
    /// generated from test2.nested.optimizable_disabled_counter_metric
    ///
    /// A multi-line
    /// description
    pub static optimizable_disabled_counter_metric: Lazy<CounterMetric> = Lazy::new(|| {
        CounterMetric::codegen_disabled_new(
            52,
            "test2.nested",
            "optimizable_disabled_counter_metric",
            "metrics"
        )
    });

    #[allow(non_upper_case_globals)]
    /// generated from test2.nested.quantity_metric
    ///
    /// A multi-line
    /// description
    pub static quantity_metric: Lazy<QuantityMetric> = Lazy::new(|| {
        let meta =
            CommonMetricData {
                name: "quantity_metric".into(),
                category: "test2.nested".into(),
                send_in_pings: vec!["metrics".into()],
                lifetime: Lifetime::Ping,
                disabled: true,
                ..Default::default()
            };
        let metric = QuantityMetric::new(BaseMetricId(53), meta)
;
        metric
    });

    #[allow(non_upper_case_globals)]
    /// generated from test2.nested.rate_metric
    ///
    /// A multi-line
    /// description
    pub static rate_metric: Lazy<RateMetric> = Lazy::new(|| {
        let meta =
            CommonMetricData {
                name: "rate_metric".into(),
                category: "test2.nested".into(),
                send_in_pings: vec!["metrics".into()],
                lifetime: Lifetime::Ping,
                disabled: true,
                ..Default::default()
            };
        let metric = RateMetric::new(BaseMetricId(54), meta)
;
        metric
    });

    #[allow(non_upper_case_globals)]
    /// generated from test2.nested.rate_with_external_denominator
    ///
    /// A multi-line
    /// description
    pub static rate_with_external_denominator: Lazy<NumeratorMetric> = Lazy::new(|| {
        let meta =
            CommonMetricData {
                name: "rate_with_external_denominator".into(),
                category: "test2.nested".into(),
                send_in_pings: vec!["metrics".into()],
                lifetime: Lifetime::Ping,
                disabled: true,
                ..Default::default()
            };
        let metric = NumeratorMetric::new(BaseMetricId(55), meta)
;
        metric
    });

    #[allow(non_upper_case_globals)]
    /// generated from test2.nested.uuid_metric
    ///
    /// A multi-line
    /// description
    pub static uuid_metric: Lazy<UuidMetric> = Lazy::new(|| {
        let meta =
            CommonMetricData {
                name: "uuid_metric".into(),
                category: "test2.nested".into(),
                send_in_pings: vec!["metrics".into()],
                lifetime: Lifetime::Application,
                disabled: true,
                ..Default::default()
            };
        let metric = UuidMetric::new(BaseMetricId(56), meta)
;
        metric
    });

}

#[allow(dead_code)]
pub(crate) mod __glean_metric_maps {
    use std::collections::HashMap;
    use std::sync::Arc;

    use crate::metrics::extra_keys_len;
    use crate::private::*;
    use malloc_size_of::MallocSizeOf;
    use once_cell::sync::Lazy;

    /// Measure the allocation size of all labeled metrics.
    ///
    /// Labeled metrics do allocate additional memory at runtime for the cache of instantiated submetrics.
    /// These are included in the `size_of` measurement automatically.
    ///
    /// **Note**: This function grows with the number of labeled metrics!
    /// If it becomes too big we need to think about further optimizations.
    fn fog_labeled_alloc_size(ops: &mut malloc_size_of::MallocSizeOfOps) -> usize {
        let mut n = 0;
          n += super::test::labeled_boolean_metric.size_of(ops);
          n += super::test::labeled_boolean_metric_labels.size_of(ops);
          n += super::test::unordered_labeled_boolean_metric.size_of(ops);
          n += super::test2::labeled_boolean_metric.size_of(ops);
          n += super::test2::labeled_boolean_metric_labels.size_of(ops);
          n += super::test2::unordered_labeled_boolean_metric.size_of(ops);
          n += super::test::labeled_counter_metric.size_of(ops);
          n += super::test::labeled_counter_metric_labels.size_of(ops);
          n += super::test2::labeled_counter_metric.size_of(ops);
          n += super::test2::labeled_counter_metric_labels.size_of(ops);
          n += super::test::labeled_string_metric.size_of(ops);
          n += super::test::labeled_string_metric_labels.size_of(ops);
          n += super::test2::labeled_string_metric.size_of(ops);
          n += super::test2::labeled_string_metric_labels.size_of(ops);
        n
    }

    fn fog_submetric_alloc_size(ops: &mut malloc_size_of::MallocSizeOfOps) -> usize {
        let mut n = 0;

        n += once_cell::sync::Lazy::get(&submetric_maps::LABELED_METRICS_TO_IDS).map(|m| {
            let lock = m.read().unwrap();
            (*lock).size_of(ops)
        }).unwrap_or(0);
        n += once_cell::sync::Lazy::get(&submetric_maps::LABELED_ENUMS_TO_IDS).map(|m| {
            let lock = m.read().unwrap();
            (*lock).size_of(ops)
        }).unwrap_or(0);

            n += once_cell::sync::Lazy::get(&submetric_maps::BOOLEAN_MAP).map(|m| {
                // The values are behind an `Arc`. We don't want to measure them.
                // We only measure the enclosing size of the values.
                let lock = m.read().unwrap();
                malloc_size_of::MallocShallowSizeOf::shallow_size_of(&*lock, ops)
            }).unwrap_or(0);
            n += once_cell::sync::Lazy::get(&submetric_maps::COUNTER_MAP).map(|m| {
                // The values are behind an `Arc`. We don't want to measure them.
                // We only measure the enclosing size of the values.
                let lock = m.read().unwrap();
                malloc_size_of::MallocShallowSizeOf::shallow_size_of(&*lock, ops)
            }).unwrap_or(0);
            n += once_cell::sync::Lazy::get(&submetric_maps::CUSTOM_DISTRIBUTION_MAP).map(|m| {
                // The values are behind an `Arc`. We don't want to measure them.
                // We only measure the enclosing size of the values.
                let lock = m.read().unwrap();
                malloc_size_of::MallocShallowSizeOf::shallow_size_of(&*lock, ops)
            }).unwrap_or(0);
            n += once_cell::sync::Lazy::get(&submetric_maps::MEMORY_DISTRIBUTION_MAP).map(|m| {
                // The values are behind an `Arc`. We don't want to measure them.
                // We only measure the enclosing size of the values.
                let lock = m.read().unwrap();
                malloc_size_of::MallocShallowSizeOf::shallow_size_of(&*lock, ops)
            }).unwrap_or(0);
            n += once_cell::sync::Lazy::get(&submetric_maps::STRING_MAP).map(|m| {
                // The values are behind an `Arc`. We don't want to measure them.
                // We only measure the enclosing size of the values.
                let lock = m.read().unwrap();
                malloc_size_of::MallocShallowSizeOf::shallow_size_of(&*lock, ops)
            }).unwrap_or(0);
            n += once_cell::sync::Lazy::get(&submetric_maps::TIMING_DISTRIBUTION_MAP).map(|m| {
                // The values are behind an `Arc`. We don't want to measure them.
                // We only measure the enclosing size of the values.
                let lock = m.read().unwrap();
                malloc_size_of::MallocShallowSizeOf::shallow_size_of(&*lock, ops)
            }).unwrap_or(0);
            n += once_cell::sync::Lazy::get(&submetric_maps::QUANTITY_MAP).map(|m| {
                // The values are behind an `Arc`. We don't want to measure them.
                // We only measure the enclosing size of the values.
                let lock = m.read().unwrap();
                malloc_size_of::MallocShallowSizeOf::shallow_size_of(&*lock, ops)
            }).unwrap_or(0);
        n
    }

    pub fn fog_map_alloc_size(ops: &mut malloc_size_of::MallocSizeOfOps) -> usize {
        let mut n = 0;
        n += BOOLEAN_MAP.size_of(ops);
        n += COUNTER_MAP.size_of(ops);
        n += CUSTOM_DISTRIBUTION_MAP.size_of(ops);
        n += MEMORY_DISTRIBUTION_MAP.size_of(ops);
        n += STRING_LIST_MAP.size_of(ops);
        n += STRING_MAP.size_of(ops);
        n += TEXT_MAP.size_of(ops);
        n += TIMESPAN_MAP.size_of(ops);
        n += TIMING_DISTRIBUTION_MAP.size_of(ops);
        n += DATETIME_MAP.size_of(ops);
        n += DENOMINATOR_MAP.size_of(ops);
        n += QUANTITY_MAP.size_of(ops);
        n += RATE_MAP.size_of(ops);
        n += NUMERATOR_MAP.size_of(ops);
        n += UUID_MAP.size_of(ops);

        n += fog_labeled_alloc_size(ops);
        n += fog_submetric_alloc_size(ops);

        n
    }

    pub static BOOLEAN_MAP: Lazy<HashMap<BaseMetricId, &Lazy<BooleanMetric>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(4);
        map.insert(BaseMetricId(1), &super::test::boolean_metric);
        map.insert(BaseMetricId(16), &super::test::unordered_boolean_metric);
        map.insert(BaseMetricId(29), &super::test2::boolean_metric);
        map.insert(BaseMetricId(44), &super::test2::unordered_boolean_metric);
        map
    });

    pub static COUNTER_MAP: Lazy<HashMap<BaseMetricId, &Lazy<CounterMetric>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(7);
        map.insert(BaseMetricId(2), &super::test::counter_metric);
        map.insert(BaseMetricId(23), &super::test_nested::optimizable_counter_metric);
        map.insert(BaseMetricId(24), &super::test_nested::optimizable_disabled_counter_metric);
        map.insert(BaseMetricId(30), &super::test2::counter_metric);
        map.insert(BaseMetricId(50), &super::test2_nested::external_denominator);
        map.insert(BaseMetricId(51), &super::test2_nested::optimizable_counter_metric);
        map.insert(BaseMetricId(52), &super::test2_nested::optimizable_disabled_counter_metric);
        map
    });

    pub static CUSTOM_DISTRIBUTION_MAP: Lazy<HashMap<BaseMetricId, &Lazy<CustomDistributionMetric>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(2);
        map.insert(BaseMetricId(3), &super::test::custom_distribution_metric);
        map.insert(BaseMetricId(31), &super::test2::custom_distribution_metric);
        map
    });

    pub static MEMORY_DISTRIBUTION_MAP: Lazy<HashMap<BaseMetricId, &Lazy<MemoryDistributionMetric>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(2);
        map.insert(BaseMetricId(10), &super::test::memory_distribution_metric);
        map.insert(BaseMetricId(38), &super::test2::memory_distribution_metric);
        map
    });

    pub static STRING_LIST_MAP: Lazy<HashMap<BaseMetricId, &Lazy<StringListMetric>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(2);
        map.insert(BaseMetricId(11), &super::test::string_list_metric);
        map.insert(BaseMetricId(39), &super::test2::string_list_metric);
        map
    });

    pub static STRING_MAP: Lazy<HashMap<BaseMetricId, &Lazy<StringMetric>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(2);
        map.insert(BaseMetricId(12), &super::test::string_metric);
        map.insert(BaseMetricId(40), &super::test2::string_metric);
        map
    });

    pub static TEXT_MAP: Lazy<HashMap<BaseMetricId, &Lazy<TextMetric>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(2);
        map.insert(BaseMetricId(13), &super::test::text_metric);
        map.insert(BaseMetricId(41), &super::test2::text_metric);
        map
    });

    pub static TIMESPAN_MAP: Lazy<HashMap<BaseMetricId, &Lazy<TimespanMetric>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(2);
        map.insert(BaseMetricId(14), &super::test::timespan_metric);
        map.insert(BaseMetricId(42), &super::test2::timespan_metric);
        map
    });

    pub static TIMING_DISTRIBUTION_MAP: Lazy<HashMap<BaseMetricId, &Lazy<TimingDistributionMetric>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(2);
        map.insert(BaseMetricId(15), &super::test::timing_distribution_metric);
        map.insert(BaseMetricId(43), &super::test2::timing_distribution_metric);
        map
    });

    pub static DATETIME_MAP: Lazy<HashMap<BaseMetricId, &Lazy<DatetimeMetric>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(2);
        map.insert(BaseMetricId(19), &super::test_nested::datetime_metric);
        map.insert(BaseMetricId(47), &super::test2_nested::datetime_metric);
        map
    });

    pub static DENOMINATOR_MAP: Lazy<HashMap<BaseMetricId, &Lazy<DenominatorMetric>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(1);
        map.insert(BaseMetricId(22), &super::test_nested::external_denominator);
        map
    });

    pub static QUANTITY_MAP: Lazy<HashMap<BaseMetricId, &Lazy<QuantityMetric>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(2);
        map.insert(BaseMetricId(25), &super::test_nested::quantity_metric);
        map.insert(BaseMetricId(53), &super::test2_nested::quantity_metric);
        map
    });

    pub static RATE_MAP: Lazy<HashMap<BaseMetricId, &Lazy<RateMetric>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(2);
        map.insert(BaseMetricId(26), &super::test_nested::rate_metric);
        map.insert(BaseMetricId(54), &super::test2_nested::rate_metric);
        map
    });

    pub static NUMERATOR_MAP: Lazy<HashMap<BaseMetricId, &Lazy<NumeratorMetric>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(2);
        map.insert(BaseMetricId(27), &super::test_nested::rate_with_external_denominator);
        map.insert(BaseMetricId(55), &super::test2_nested::rate_with_external_denominator);
        map
    });

    pub static UUID_MAP: Lazy<HashMap<BaseMetricId, &Lazy<UuidMetric>>> = Lazy::new(|| {
        let mut map = HashMap::with_capacity(2);
        map.insert(BaseMetricId(28), &super::test_nested::uuid_metric);
        map.insert(BaseMetricId(56), &super::test2_nested::uuid_metric);
        map
    });


    pub(crate) fn set_object_by_id(metric_id: u32, value: String) -> Result<(), ()> {
        match metric_id {
          18 => {
              super::test_nested::an_object.set_string(value);
              Ok(())
          }
          46 => {
              super::test2_nested::an_object.set_string(value);
              Ok(())
          }
           _ => Err(()),
        }
    }

    /// Wrapper to get the currently stored object for object metric as a string.
    ///
    /// # Arguments
    ///
    /// * `metric_id` - The metric's ID to look up
    /// * `ping_name` - (Optional) The ping name to look into.
    ///                 Defaults to the first value in `send_in_pings`.
    ///
    /// # Returns
    ///
    /// Returns the recorded object serialized as a JSON string or `None` if nothing stored.
    ///
    /// # Panics
    ///
    /// Panics if no object by the given metric ID could be found.
    pub(crate) fn object_test_get_value(metric_id: u32, ping_name: Option<String>) -> Option<String> {
        match metric_id {
           18 => super::test_nested::an_object.test_get_value_as_str(ping_name.as_deref()),
           46 => super::test2_nested::an_object.test_get_value_as_str(ping_name.as_deref()),
           _ => panic!("No object for metric id {}", metric_id),
        }
    }

    /// Check the provided object for errors.
    ///
    /// # Arguments
    ///
    /// * `metric_id` - The metric's ID to look up
    ///
    /// # Returns
    ///
    /// Returns a string for the recorded error or `None`.
    ///
    /// # Panics
    ///
    /// Panics if no object by the given metric ID could be found.
    #[allow(unused_variables)]
    pub(crate) fn object_test_get_error(metric_id: u32) -> Option<String> {
        #[cfg(feature = "with_gecko")]
        match metric_id {
           18 => test_get_errors!(super::test_nested::an_object),
           46 => test_get_errors!(super::test2_nested::an_object),
           _ => panic!("No object for metric id {}", metric_id),
        }

        #[cfg(not(feature = "with_gecko"))]
        {
            return None;
        }
    }

    /// Wrapper to record an event based on its metric ID.
    ///
    /// # Arguments
    ///
    /// * `metric_id` - The metric's ID to look up
    /// * `extra`     - An map of (extra key id, string) pairs.
    ///                 The map will be decoded into the appropriate `ExtraKeys` type.
    /// # Returns
    ///
    /// Returns `Ok(())` if the event was found and `record` was called with the given `extra`,
    /// or an `EventRecordingError::InvalidId` if no event by that ID exists
    /// or an `EventRecordingError::InvalidExtraKey` if the `extra` map could not be deserialized.
    pub(crate) fn record_event_by_id(metric_id: u32, extra: HashMap<String, String>) -> Result<(), EventRecordingError> {
        match metric_id {
          20 => {
              super::test_nested::event_metric.record_raw(extra);
              Ok(())
          }
          21 => {
              super::test_nested::event_metric_with_extra.record_raw(extra);
              Ok(())
          }
          48 => {
              super::test2_nested::event_metric.record_raw(extra);
              Ok(())
          }
          49 => {
              super::test2_nested::event_metric_with_extra.record_raw(extra);
              Ok(())
          }
           _ => Err(EventRecordingError::InvalidId),
        }
    }

    /// Wrapper to record an event based on its metric ID, with a provided timestamp.
    ///
    /// # Arguments
    ///
    /// * `metric_id` - The metric's ID to look up
    /// * `timestamp` - The time at which this event was recorded.
    /// * `extra`     - An map of (extra key id, string) pairs.
    ///                 The map will be decoded into the appropriate `ExtraKeys` type.
    /// # Returns
    ///
    /// Returns `Ok(())` if the event was found and `record` was called with the given `extra`,
    /// or an `EventRecordingError::InvalidId` if no event by that ID exists
    /// or an `EventRecordingError::InvalidExtraKey` if the event doesn't take extra pairs,
    /// but some are passed in.
    pub(crate) fn record_event_by_id_with_time(metric_id: BaseMetricId, timestamp: u64, extra: HashMap<String, String>) -> Result<(), EventRecordingError> {
        match metric_id {
          BaseMetricId(20) => {
              if extra_keys_len(&super::test_nested::event_metric) == 0 && !extra.is_empty() {
                return Err(EventRecordingError::InvalidExtraKey);
              }

              super::test_nested::event_metric.record_with_time(timestamp, extra);
              Ok(())
          }
          BaseMetricId(21) => {
              if extra_keys_len(&super::test_nested::event_metric_with_extra) == 0 && !extra.is_empty() {
                return Err(EventRecordingError::InvalidExtraKey);
              }

              super::test_nested::event_metric_with_extra.record_with_time(timestamp, extra);
              Ok(())
          }
          BaseMetricId(48) => {
              if extra_keys_len(&super::test2_nested::event_metric) == 0 && !extra.is_empty() {
                return Err(EventRecordingError::InvalidExtraKey);
              }

              super::test2_nested::event_metric.record_with_time(timestamp, extra);
              Ok(())
          }
          BaseMetricId(49) => {
              if extra_keys_len(&super::test2_nested::event_metric_with_extra) == 0 && !extra.is_empty() {
                return Err(EventRecordingError::InvalidExtraKey);
              }

              super::test2_nested::event_metric_with_extra.record_with_time(timestamp, extra);
              Ok(())
          }
           _ => Err(EventRecordingError::InvalidId),
        }
    }

    /// Wrapper to get the currently stored events for event metric.
    ///
    /// # Arguments
    ///
    /// * `metric_id` - The metric's ID to look up
    /// * `ping_name` - (Optional) The ping name to look into.
    ///                 Defaults to the first value in `send_in_pings`.
    ///
    /// # Returns
    ///
    /// Returns the recorded events or `None` if nothing stored.
    ///
    /// # Panics
    ///
    /// Panics if no event by the given metric ID could be found.
    pub(crate) fn event_test_get_value_wrapper(metric_id: u32, ping_name: Option<String>) -> Option<Vec<RecordedEvent>> {
        match metric_id {
           20 => super::test_nested::event_metric.test_get_value(ping_name.as_deref()),
           21 => super::test_nested::event_metric_with_extra.test_get_value(ping_name.as_deref()),
           48 => super::test2_nested::event_metric.test_get_value(ping_name.as_deref()),
           49 => super::test2_nested::event_metric_with_extra.test_get_value(ping_name.as_deref()),
           _ => panic!("No event for metric id {}", metric_id),
        }
    }

    /// Check the provided event for errors.
    ///
    /// # Arguments
    ///
    /// * `metric_id` - The metric's ID to look up
    /// * `ping_name` - (Optional) The ping name to look into.
    ///                 Defaults to the first value in `send_in_pings`.
    ///
    /// # Returns
    ///
    /// Returns a string for the recorded error or `None`.
    ///
    /// # Panics
    ///
    /// Panics if no event by the given metric ID could be found.
    #[allow(unused_variables)]
    pub(crate) fn event_test_get_error(metric_id: u32) -> Option<String> {
        #[cfg(feature = "with_gecko")]
        match metric_id {
           20 => test_get_errors!(super::test_nested::event_metric),
           21 => test_get_errors!(super::test_nested::event_metric_with_extra),
           48 => test_get_errors!(super::test2_nested::event_metric),
           49 => test_get_errors!(super::test2_nested::event_metric_with_extra),
           _ => panic!("No event for metric id {}", metric_id),
        }

        #[cfg(not(feature = "with_gecko"))]
        {
            return None;
        }
    }

    /// Gets the submetric from the specified labeled_boolean metric.
    ///
    /// # Arguments
    ///
    /// * `metric_id` - The metric's ID to look up
    /// * `label` - The label identifying the boolean submetric.
    ///
    /// # Returns
    ///
    /// Returns the boolean submetric.
    ///
    /// # Panics
    ///
    /// Panics if no labeled_boolean by the given metric ID could be found.
    #[allow(unused_variables)]
    pub(crate) fn labeled_boolean_get(metric_id: u32, label: &str) -> Arc<LabeledBooleanMetric> {
        match metric_id {
            4 => super::test::labeled_boolean_metric.get(label),
            5 => super::test::labeled_boolean_metric_labels.get(label),
            17 => super::test::unordered_labeled_boolean_metric.get(label),
            32 => super::test2::labeled_boolean_metric.get(label),
            33 => super::test2::labeled_boolean_metric_labels.get(label),
            45 => super::test2::unordered_labeled_boolean_metric.get(label),
            _ => panic!("No labeled_boolean for metric id {}", metric_id),
        }
    }
    /// Gets the submetric from the specified labeled_counter metric.
    ///
    /// # Arguments
    ///
    /// * `metric_id` - The metric's ID to look up
    /// * `label` - The label identifying the counter submetric.
    ///
    /// # Returns
    ///
    /// Returns the counter submetric.
    ///
    /// # Panics
    ///
    /// Panics if no labeled_counter by the given metric ID could be found.
    #[allow(unused_variables)]
    pub(crate) fn labeled_counter_get(metric_id: u32, label: &str) -> Arc<LabeledCounterMetric> {
        match metric_id {
            6 => super::test::labeled_counter_metric.get(label),
            7 => super::test::labeled_counter_metric_labels.get(label),
            34 => super::test2::labeled_counter_metric.get(label),
            35 => super::test2::labeled_counter_metric_labels.get(label),
            _ => panic!("No labeled_counter for metric id {}", metric_id),
        }
    }
    /// Gets the submetric from the specified labeled_string metric.
    ///
    /// # Arguments
    ///
    /// * `metric_id` - The metric's ID to look up
    /// * `label` - The label identifying the string submetric.
    ///
    /// # Returns
    ///
    /// Returns the string submetric.
    ///
    /// # Panics
    ///
    /// Panics if no labeled_string by the given metric ID could be found.
    #[allow(unused_variables)]
    pub(crate) fn labeled_string_get(metric_id: u32, label: &str) -> Arc<LabeledStringMetric> {
        match metric_id {
            8 => super::test::labeled_string_metric.get(label),
            9 => super::test::labeled_string_metric_labels.get(label),
            36 => super::test2::labeled_string_metric.get(label),
            37 => super::test2::labeled_string_metric_labels.get(label),
            _ => panic!("No labeled_string for metric id {}", metric_id),
        }
    }

    pub(crate) fn labeled_enum_to_str(metric_id: u32, label: u16) -> &'static str {
        match metric_id {
            5 => super::test::LabeledBooleanMetricLabelsLabel::from(label).into(),
            7 => super::test::LabeledCounterMetricLabelsLabel::from(label).into(),
            9 => super::test::LabeledStringMetricLabelsLabel::from(label).into(),
            33 => super::test2::LabeledBooleanMetricLabelsLabel::from(label).into(),
            35 => super::test2::LabeledCounterMetricLabelsLabel::from(label).into(),
            37 => super::test2::LabeledStringMetricLabelsLabel::from(label).into(),
            _ => panic!("Can't turn label enum to string for metric {} which isn't a labeled metric with static labels", metric_id),
        }
    }

    pub(crate) fn labeled_submetric_id_get(metric_id: u32, label: &str) -> u32 {
        match metric_id {
            4 => super::test::labeled_boolean_metric.get_submetric_id(label),
            5 => super::test::labeled_boolean_metric_labels.get_submetric_id(label),
            6 => super::test::labeled_counter_metric.get_submetric_id(label),
            7 => super::test::labeled_counter_metric_labels.get_submetric_id(label),
            8 => super::test::labeled_string_metric.get_submetric_id(label),
            9 => super::test::labeled_string_metric_labels.get_submetric_id(label),
            17 => super::test::unordered_labeled_boolean_metric.get_submetric_id(label),
            32 => super::test2::labeled_boolean_metric.get_submetric_id(label),
            33 => super::test2::labeled_boolean_metric_labels.get_submetric_id(label),
            34 => super::test2::labeled_counter_metric.get_submetric_id(label),
            35 => super::test2::labeled_counter_metric_labels.get_submetric_id(label),
            36 => super::test2::labeled_string_metric.get_submetric_id(label),
            37 => super::test2::labeled_string_metric_labels.get_submetric_id(label),
            45 => super::test2::unordered_labeled_boolean_metric.get_submetric_id(label),
            _ => panic!("No labeled metric for id {}", metric_id),
        }
    }

    pub(crate) mod submetric_maps {
        use std::sync::{
          atomic::AtomicU32,
          Arc,
          RwLock,
        };
        use super::*;

        pub(crate) const SUBMETRIC_BIT: u32 = 25;
        pub(crate) static NEXT_LABELED_SUBMETRIC_ID: AtomicU32 = AtomicU32::new((1 << SUBMETRIC_BIT) + 1);
        pub(crate) static LABELED_METRICS_TO_IDS: Lazy<RwLock<HashMap<(BaseMetricId, String), SubMetricId>>> = Lazy::new(||
            RwLock::new(HashMap::new())
        );
        pub(crate) static LABELED_ENUMS_TO_IDS: Lazy<RwLock<HashMap<(u32, u16), u32>>> = Lazy::new(||
            RwLock::new(HashMap::new())
        );

        pub static BOOLEAN_MAP: Lazy<RwLock<HashMap<SubMetricId, Arc<LabeledBooleanMetric>>>> = Lazy::new(||
            RwLock::new(HashMap::new())
        );
        pub static COUNTER_MAP: Lazy<RwLock<HashMap<SubMetricId, Arc<LabeledCounterMetric>>>> = Lazy::new(||
            RwLock::new(HashMap::new())
        );
        pub static CUSTOM_DISTRIBUTION_MAP: Lazy<RwLock<HashMap<SubMetricId, Arc<LabeledCustomDistributionMetric>>>> = Lazy::new(||
            RwLock::new(HashMap::new())
        );
        pub static MEMORY_DISTRIBUTION_MAP: Lazy<RwLock<HashMap<SubMetricId, Arc<LabeledMemoryDistributionMetric>>>> = Lazy::new(||
            RwLock::new(HashMap::new())
        );
        pub static STRING_MAP: Lazy<RwLock<HashMap<SubMetricId, Arc<LabeledStringMetric>>>> = Lazy::new(||
            RwLock::new(HashMap::new())
        );
        pub static TIMING_DISTRIBUTION_MAP: Lazy<RwLock<HashMap<SubMetricId, Arc<LabeledTimingDistributionMetric>>>> = Lazy::new(||
            RwLock::new(HashMap::new())
        );
        pub static QUANTITY_MAP: Lazy<RwLock<HashMap<SubMetricId, Arc<LabeledQuantityMetric>>>> = Lazy::new(||
            RwLock::new(HashMap::new())
        );
    }
}

