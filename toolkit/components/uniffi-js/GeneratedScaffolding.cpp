/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set ts=8 sts=2 et sw=2 tw=80: */

// Generated by uniffi-bindgen-gecko-js.  DO NOT EDIT.

#include "nsString.h"
#include "nsPrintfCString.h"
#include "mozilla/Logging.h"
#include "mozilla/Maybe.h"
#include "mozilla/StaticPtr.h"
#include "mozilla/UniquePtr.h"
#include "mozilla/dom/Promise.h"
#include "mozilla/dom/PromiseNativeHandler.h"
#include "mozilla/dom/UniFFIScaffolding.h"
#include "mozilla/uniffi/Call.h"
#include "mozilla/uniffi/Callbacks.h"
#include "mozilla/uniffi/FfiValue.h"
#include "mozilla/uniffi/PointerType.h"
#include "mozilla/uniffi/Rust.h"

namespace mozilla::uniffi {

using dom::ArrayBuffer;
using dom::AutoEntryScript;
using dom::GlobalObject;
using dom::RootedDictionary;
using dom::NullableRootedUnion;
using dom::Promise;
using dom::PromiseNativeHandler;
using dom::Sequence;
using dom::UniFFICallbackHandler;
using dom::UniFFIPointer;
using dom::UniFFIScaffoldingCallCode;
using dom::UniFFIScaffoldingCallResult;


/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set ts=8 sts=2 et sw=2 tw=80: */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

extern "C" {

  RustBuffer ffi_context_id_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_context_id_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_context_id_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_context_id_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  typedef void (*RustFutureContinuationCallback)(uint64_t, int8_t);
  typedef void (*ForeignFutureFree)(uint64_t);
  struct ForeignFuture {
    uint64_t handle;
    ForeignFutureFree free;
  };
  void ffi_context_id_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_context_id_rust_future_cancel_u8(uint64_t);
  uint8_t ffi_context_id_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_context_id_rust_future_free_u8(uint64_t);
  void ffi_context_id_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_context_id_rust_future_cancel_i8(uint64_t);
  int8_t ffi_context_id_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_context_id_rust_future_free_i8(uint64_t);
  void ffi_context_id_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_context_id_rust_future_cancel_u16(uint64_t);
  uint16_t ffi_context_id_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_context_id_rust_future_free_u16(uint64_t);
  void ffi_context_id_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_context_id_rust_future_cancel_i16(uint64_t);
  int16_t ffi_context_id_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_context_id_rust_future_free_i16(uint64_t);
  void ffi_context_id_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_context_id_rust_future_cancel_u32(uint64_t);
  uint32_t ffi_context_id_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_context_id_rust_future_free_u32(uint64_t);
  void ffi_context_id_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_context_id_rust_future_cancel_i32(uint64_t);
  int32_t ffi_context_id_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_context_id_rust_future_free_i32(uint64_t);
  void ffi_context_id_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_context_id_rust_future_cancel_u64(uint64_t);
  uint64_t ffi_context_id_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_context_id_rust_future_free_u64(uint64_t);
  void ffi_context_id_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_context_id_rust_future_cancel_i64(uint64_t);
  int64_t ffi_context_id_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_context_id_rust_future_free_i64(uint64_t);
  void ffi_context_id_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_context_id_rust_future_cancel_f32(uint64_t);
  float ffi_context_id_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_context_id_rust_future_free_f32(uint64_t);
  void ffi_context_id_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_context_id_rust_future_cancel_f64(uint64_t);
  double ffi_context_id_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_context_id_rust_future_free_f64(uint64_t);
  void ffi_context_id_rust_future_poll_pointer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_context_id_rust_future_cancel_pointer(uint64_t);
  void* ffi_context_id_rust_future_complete_pointer(uint64_t, RustCallStatus*);
  void ffi_context_id_rust_future_free_pointer(uint64_t);
  void ffi_context_id_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_context_id_rust_future_cancel_rust_buffer(uint64_t);
  RustBuffer ffi_context_id_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_context_id_rust_future_free_rust_buffer(uint64_t);
  void ffi_context_id_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_context_id_rust_future_cancel_void(uint64_t);
  void ffi_context_id_rust_future_complete_void(uint64_t, RustCallStatus*);
  void ffi_context_id_rust_future_free_void(uint64_t);
  void* uniffi_context_id_fn_clone_contextidcomponent(void*, RustCallStatus*);
  void uniffi_context_id_fn_free_contextidcomponent(void*, RustCallStatus*);
  typedef void (*CallbackInterfaceContextIdContextIdCallbackMethod0)(uint64_t, RustBuffer, int64_t, void*, RustCallStatus*);
  typedef void (*CallbackInterfaceContextIdContextIdCallbackMethod1)(uint64_t, RustBuffer, void*, RustCallStatus*);
  typedef void (*CallbackInterfaceFreeContextId_ContextIdCallback)(uint64_t);
  struct VTableCallbackInterfaceContextIdContextIdCallback {
    CallbackInterfaceContextIdContextIdCallbackMethod0 persist;
    CallbackInterfaceContextIdContextIdCallbackMethod1 rotated;
    CallbackInterfaceFreeContextId_ContextIdCallback uniffi_free;
  };
  void uniffi_context_id_fn_init_callback_vtable_contextidcallback(VTableCallbackInterfaceContextIdContextIdCallback*);
  void* uniffi_context_id_fn_constructor_contextidcomponent_new(RustBuffer, int64_t, int8_t, uint64_t, RustCallStatus*);
  void uniffi_context_id_fn_method_contextidcomponent_force_rotation(void*, RustCallStatus*);
  RustBuffer uniffi_context_id_fn_method_contextidcomponent_request(void*, uint8_t, RustCallStatus*);
  void uniffi_context_id_fn_method_contextidcomponent_unset_callback(void*, RustCallStatus*);
  uint32_t ffi_context_id_uniffi_contract_version();
  uint16_t uniffi_context_id_checksum_constructor_contextidcomponent_new();
  uint16_t uniffi_context_id_checksum_method_contextidcomponent_force_rotation();
  uint16_t uniffi_context_id_checksum_method_contextidcomponent_request();
  uint16_t uniffi_context_id_checksum_method_contextidcomponent_unset_callback();
  RustBuffer ffi_error_support_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_error_support_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_error_support_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_error_support_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_u8(uint64_t);
  uint8_t ffi_error_support_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_free_u8(uint64_t);
  void ffi_error_support_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_i8(uint64_t);
  int8_t ffi_error_support_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_free_i8(uint64_t);
  void ffi_error_support_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_u16(uint64_t);
  uint16_t ffi_error_support_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_free_u16(uint64_t);
  void ffi_error_support_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_i16(uint64_t);
  int16_t ffi_error_support_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_free_i16(uint64_t);
  void ffi_error_support_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_u32(uint64_t);
  uint32_t ffi_error_support_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_free_u32(uint64_t);
  void ffi_error_support_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_i32(uint64_t);
  int32_t ffi_error_support_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_free_i32(uint64_t);
  void ffi_error_support_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_u64(uint64_t);
  uint64_t ffi_error_support_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_free_u64(uint64_t);
  void ffi_error_support_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_i64(uint64_t);
  int64_t ffi_error_support_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_free_i64(uint64_t);
  void ffi_error_support_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_f32(uint64_t);
  float ffi_error_support_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_free_f32(uint64_t);
  void ffi_error_support_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_f64(uint64_t);
  double ffi_error_support_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_free_f64(uint64_t);
  void ffi_error_support_rust_future_poll_pointer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_pointer(uint64_t);
  void* ffi_error_support_rust_future_complete_pointer(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_free_pointer(uint64_t);
  void ffi_error_support_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_rust_buffer(uint64_t);
  RustBuffer ffi_error_support_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_free_rust_buffer(uint64_t);
  void ffi_error_support_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_void(uint64_t);
  void ffi_error_support_rust_future_complete_void(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_free_void(uint64_t);
  typedef void (*CallbackInterfaceErrorsupportApplicationErrorReporterMethod0)(uint64_t, RustBuffer, RustBuffer, void*, RustCallStatus*);
  typedef void (*CallbackInterfaceErrorsupportApplicationErrorReporterMethod1)(uint64_t, RustBuffer, RustBuffer, uint32_t, uint32_t, void*, RustCallStatus*);
  typedef void (*CallbackInterfaceFreeErrorsupport_ApplicationErrorReporter)(uint64_t);
  struct VTableCallbackInterfaceErrorsupportApplicationErrorReporter {
    CallbackInterfaceErrorsupportApplicationErrorReporterMethod0 report_error;
    CallbackInterfaceErrorsupportApplicationErrorReporterMethod1 report_breadcrumb;
    CallbackInterfaceFreeErrorsupport_ApplicationErrorReporter uniffi_free;
  };
  void uniffi_error_support_fn_init_callback_vtable_applicationerrorreporter(VTableCallbackInterfaceErrorsupportApplicationErrorReporter*);
  void uniffi_error_support_fn_func_set_application_error_reporter(uint64_t, RustCallStatus*);
  void uniffi_error_support_fn_func_unset_application_error_reporter(RustCallStatus*);
  uint32_t ffi_error_support_uniffi_contract_version();
  uint16_t uniffi_error_support_checksum_func_set_application_error_reporter();
  uint16_t uniffi_error_support_checksum_func_unset_application_error_reporter();
  RustBuffer ffi_relevancy_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_relevancy_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_relevancy_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_relevancy_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_u8(uint64_t);
  uint8_t ffi_relevancy_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_free_u8(uint64_t);
  void ffi_relevancy_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_i8(uint64_t);
  int8_t ffi_relevancy_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_free_i8(uint64_t);
  void ffi_relevancy_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_u16(uint64_t);
  uint16_t ffi_relevancy_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_free_u16(uint64_t);
  void ffi_relevancy_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_i16(uint64_t);
  int16_t ffi_relevancy_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_free_i16(uint64_t);
  void ffi_relevancy_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_u32(uint64_t);
  uint32_t ffi_relevancy_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_free_u32(uint64_t);
  void ffi_relevancy_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_i32(uint64_t);
  int32_t ffi_relevancy_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_free_i32(uint64_t);
  void ffi_relevancy_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_u64(uint64_t);
  uint64_t ffi_relevancy_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_free_u64(uint64_t);
  void ffi_relevancy_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_i64(uint64_t);
  int64_t ffi_relevancy_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_free_i64(uint64_t);
  void ffi_relevancy_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_f32(uint64_t);
  float ffi_relevancy_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_free_f32(uint64_t);
  void ffi_relevancy_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_f64(uint64_t);
  double ffi_relevancy_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_free_f64(uint64_t);
  void ffi_relevancy_rust_future_poll_pointer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_pointer(uint64_t);
  void* ffi_relevancy_rust_future_complete_pointer(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_free_pointer(uint64_t);
  void ffi_relevancy_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_rust_buffer(uint64_t);
  RustBuffer ffi_relevancy_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_free_rust_buffer(uint64_t);
  void ffi_relevancy_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_void(uint64_t);
  void ffi_relevancy_rust_future_complete_void(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_free_void(uint64_t);
  void* uniffi_relevancy_fn_clone_relevancystore(void*, RustCallStatus*);
  void uniffi_relevancy_fn_free_relevancystore(void*, RustCallStatus*);
  double uniffi_relevancy_fn_func_score(RustBuffer, RustBuffer, RustCallStatus*);
  void* uniffi_relevancy_fn_constructor_relevancystore_new(RustBuffer, void*, RustCallStatus*);
  void uniffi_relevancy_fn_method_relevancystore_bandit_init(void*, RustBuffer, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_relevancy_fn_method_relevancystore_bandit_select(void*, RustBuffer, RustBuffer, RustCallStatus*);
  void uniffi_relevancy_fn_method_relevancystore_bandit_update(void*, RustBuffer, RustBuffer, int8_t, RustCallStatus*);
  void uniffi_relevancy_fn_method_relevancystore_close(void*, RustCallStatus*);
  void uniffi_relevancy_fn_method_relevancystore_ensure_interest_data_populated(void*, RustCallStatus*);
  RustBuffer uniffi_relevancy_fn_method_relevancystore_get_bandit_data(void*, RustBuffer, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_relevancy_fn_method_relevancystore_ingest(void*, RustBuffer, RustCallStatus*);
  void uniffi_relevancy_fn_method_relevancystore_interrupt(void*, RustCallStatus*);
  RustBuffer uniffi_relevancy_fn_method_relevancystore_user_interest_vector(void*, RustCallStatus*);
  uint32_t ffi_relevancy_uniffi_contract_version();
  uint16_t uniffi_relevancy_checksum_func_score();
  uint16_t uniffi_relevancy_checksum_constructor_relevancystore_new();
  uint16_t uniffi_relevancy_checksum_method_relevancystore_bandit_init();
  uint16_t uniffi_relevancy_checksum_method_relevancystore_bandit_select();
  uint16_t uniffi_relevancy_checksum_method_relevancystore_bandit_update();
  uint16_t uniffi_relevancy_checksum_method_relevancystore_close();
  uint16_t uniffi_relevancy_checksum_method_relevancystore_ensure_interest_data_populated();
  uint16_t uniffi_relevancy_checksum_method_relevancystore_get_bandit_data();
  uint16_t uniffi_relevancy_checksum_method_relevancystore_ingest();
  uint16_t uniffi_relevancy_checksum_method_relevancystore_interrupt();
  uint16_t uniffi_relevancy_checksum_method_relevancystore_user_interest_vector();
  RustBuffer ffi_remote_settings_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_remote_settings_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_remote_settings_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_remote_settings_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_u8(uint64_t);
  uint8_t ffi_remote_settings_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_free_u8(uint64_t);
  void ffi_remote_settings_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_i8(uint64_t);
  int8_t ffi_remote_settings_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_free_i8(uint64_t);
  void ffi_remote_settings_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_u16(uint64_t);
  uint16_t ffi_remote_settings_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_free_u16(uint64_t);
  void ffi_remote_settings_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_i16(uint64_t);
  int16_t ffi_remote_settings_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_free_i16(uint64_t);
  void ffi_remote_settings_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_u32(uint64_t);
  uint32_t ffi_remote_settings_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_free_u32(uint64_t);
  void ffi_remote_settings_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_i32(uint64_t);
  int32_t ffi_remote_settings_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_free_i32(uint64_t);
  void ffi_remote_settings_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_u64(uint64_t);
  uint64_t ffi_remote_settings_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_free_u64(uint64_t);
  void ffi_remote_settings_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_i64(uint64_t);
  int64_t ffi_remote_settings_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_free_i64(uint64_t);
  void ffi_remote_settings_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_f32(uint64_t);
  float ffi_remote_settings_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_free_f32(uint64_t);
  void ffi_remote_settings_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_f64(uint64_t);
  double ffi_remote_settings_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_free_f64(uint64_t);
  void ffi_remote_settings_rust_future_poll_pointer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_pointer(uint64_t);
  void* ffi_remote_settings_rust_future_complete_pointer(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_free_pointer(uint64_t);
  void ffi_remote_settings_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_rust_buffer(uint64_t);
  RustBuffer ffi_remote_settings_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_free_rust_buffer(uint64_t);
  void ffi_remote_settings_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_void(uint64_t);
  void ffi_remote_settings_rust_future_complete_void(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_free_void(uint64_t);
  void* uniffi_remote_settings_fn_clone_remotesettings(void*, RustCallStatus*);
  void uniffi_remote_settings_fn_free_remotesettings(void*, RustCallStatus*);
  void* uniffi_remote_settings_fn_clone_remotesettingsclient(void*, RustCallStatus*);
  void uniffi_remote_settings_fn_free_remotesettingsclient(void*, RustCallStatus*);
  void* uniffi_remote_settings_fn_clone_remotesettingsservice(void*, RustCallStatus*);
  void uniffi_remote_settings_fn_free_remotesettingsservice(void*, RustCallStatus*);
  void* uniffi_remote_settings_fn_constructor_remotesettings_new(RustBuffer, RustCallStatus*);
  void uniffi_remote_settings_fn_method_remotesettings_download_attachment_to_path(void*, RustBuffer, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_remote_settings_fn_method_remotesettings_get_records(void*, RustCallStatus*);
  RustBuffer uniffi_remote_settings_fn_method_remotesettings_get_records_since(void*, uint64_t, RustCallStatus*);
  RustBuffer uniffi_remote_settings_fn_method_remotesettingsclient_collection_name(void*, RustCallStatus*);
  RustBuffer uniffi_remote_settings_fn_method_remotesettingsclient_get_attachment(void*, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_remote_settings_fn_method_remotesettingsclient_get_records(void*, int8_t, RustCallStatus*);
  RustBuffer uniffi_remote_settings_fn_method_remotesettingsclient_get_records_map(void*, int8_t, RustCallStatus*);
  void uniffi_remote_settings_fn_method_remotesettingsclient_shutdown(void*, RustCallStatus*);
  void uniffi_remote_settings_fn_method_remotesettingsclient_sync(void*, RustCallStatus*);
  void* uniffi_remote_settings_fn_constructor_remotesettingsservice_new(RustBuffer, RustBuffer, RustCallStatus*);
  void* uniffi_remote_settings_fn_method_remotesettingsservice_make_client(void*, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_remote_settings_fn_method_remotesettingsservice_sync(void*, RustCallStatus*);
  void uniffi_remote_settings_fn_method_remotesettingsservice_update_config(void*, RustBuffer, RustCallStatus*);
  uint32_t ffi_remote_settings_uniffi_contract_version();
  uint16_t uniffi_remote_settings_checksum_constructor_remotesettings_new();
  uint16_t uniffi_remote_settings_checksum_method_remotesettings_download_attachment_to_path();
  uint16_t uniffi_remote_settings_checksum_method_remotesettings_get_records();
  uint16_t uniffi_remote_settings_checksum_method_remotesettings_get_records_since();
  uint16_t uniffi_remote_settings_checksum_method_remotesettingsclient_collection_name();
  uint16_t uniffi_remote_settings_checksum_method_remotesettingsclient_get_attachment();
  uint16_t uniffi_remote_settings_checksum_method_remotesettingsclient_get_records();
  uint16_t uniffi_remote_settings_checksum_method_remotesettingsclient_get_records_map();
  uint16_t uniffi_remote_settings_checksum_method_remotesettingsclient_shutdown();
  uint16_t uniffi_remote_settings_checksum_method_remotesettingsclient_sync();
  uint16_t uniffi_remote_settings_checksum_constructor_remotesettingsservice_new();
  uint16_t uniffi_remote_settings_checksum_method_remotesettingsservice_make_client();
  uint16_t uniffi_remote_settings_checksum_method_remotesettingsservice_sync();
  uint16_t uniffi_remote_settings_checksum_method_remotesettingsservice_update_config();
  RustBuffer ffi_search_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_search_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_search_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_search_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_search_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_u8(uint64_t);
  uint8_t ffi_search_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_free_u8(uint64_t);
  void ffi_search_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_i8(uint64_t);
  int8_t ffi_search_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_free_i8(uint64_t);
  void ffi_search_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_u16(uint64_t);
  uint16_t ffi_search_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_free_u16(uint64_t);
  void ffi_search_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_i16(uint64_t);
  int16_t ffi_search_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_free_i16(uint64_t);
  void ffi_search_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_u32(uint64_t);
  uint32_t ffi_search_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_free_u32(uint64_t);
  void ffi_search_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_i32(uint64_t);
  int32_t ffi_search_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_free_i32(uint64_t);
  void ffi_search_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_u64(uint64_t);
  uint64_t ffi_search_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_free_u64(uint64_t);
  void ffi_search_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_i64(uint64_t);
  int64_t ffi_search_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_free_i64(uint64_t);
  void ffi_search_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_f32(uint64_t);
  float ffi_search_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_free_f32(uint64_t);
  void ffi_search_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_f64(uint64_t);
  double ffi_search_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_free_f64(uint64_t);
  void ffi_search_rust_future_poll_pointer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_pointer(uint64_t);
  void* ffi_search_rust_future_complete_pointer(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_free_pointer(uint64_t);
  void ffi_search_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_rust_buffer(uint64_t);
  RustBuffer ffi_search_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_free_rust_buffer(uint64_t);
  void ffi_search_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_void(uint64_t);
  void ffi_search_rust_future_complete_void(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_free_void(uint64_t);
  void* uniffi_search_fn_clone_searchengineselector(void*, RustCallStatus*);
  void uniffi_search_fn_free_searchengineselector(void*, RustCallStatus*);
  void* uniffi_search_fn_constructor_searchengineselector_new(RustCallStatus*);
  void uniffi_search_fn_method_searchengineselector_clear_search_config(void*, RustCallStatus*);
  RustBuffer uniffi_search_fn_method_searchengineselector_filter_engine_configuration(void*, RustBuffer, RustCallStatus*);
  void uniffi_search_fn_method_searchengineselector_set_config_overrides(void*, RustBuffer, RustCallStatus*);
  void uniffi_search_fn_method_searchengineselector_set_search_config(void*, RustBuffer, RustCallStatus*);
  void uniffi_search_fn_method_searchengineselector_use_remote_settings_server(void*, void*, int8_t, RustCallStatus*);
  uint32_t ffi_search_uniffi_contract_version();
  uint16_t uniffi_search_checksum_constructor_searchengineselector_new();
  uint16_t uniffi_search_checksum_method_searchengineselector_clear_search_config();
  uint16_t uniffi_search_checksum_method_searchengineselector_filter_engine_configuration();
  uint16_t uniffi_search_checksum_method_searchengineselector_set_config_overrides();
  uint16_t uniffi_search_checksum_method_searchengineselector_set_search_config();
  uint16_t uniffi_search_checksum_method_searchengineselector_use_remote_settings_server();
  RustBuffer ffi_suggest_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_suggest_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_suggest_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_suggest_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_u8(uint64_t);
  uint8_t ffi_suggest_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_free_u8(uint64_t);
  void ffi_suggest_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_i8(uint64_t);
  int8_t ffi_suggest_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_free_i8(uint64_t);
  void ffi_suggest_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_u16(uint64_t);
  uint16_t ffi_suggest_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_free_u16(uint64_t);
  void ffi_suggest_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_i16(uint64_t);
  int16_t ffi_suggest_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_free_i16(uint64_t);
  void ffi_suggest_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_u32(uint64_t);
  uint32_t ffi_suggest_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_free_u32(uint64_t);
  void ffi_suggest_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_i32(uint64_t);
  int32_t ffi_suggest_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_free_i32(uint64_t);
  void ffi_suggest_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_u64(uint64_t);
  uint64_t ffi_suggest_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_free_u64(uint64_t);
  void ffi_suggest_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_i64(uint64_t);
  int64_t ffi_suggest_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_free_i64(uint64_t);
  void ffi_suggest_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_f32(uint64_t);
  float ffi_suggest_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_free_f32(uint64_t);
  void ffi_suggest_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_f64(uint64_t);
  double ffi_suggest_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_free_f64(uint64_t);
  void ffi_suggest_rust_future_poll_pointer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_pointer(uint64_t);
  void* ffi_suggest_rust_future_complete_pointer(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_free_pointer(uint64_t);
  void ffi_suggest_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_rust_buffer(uint64_t);
  RustBuffer ffi_suggest_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_free_rust_buffer(uint64_t);
  void ffi_suggest_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_void(uint64_t);
  void ffi_suggest_rust_future_complete_void(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_free_void(uint64_t);
  void* uniffi_suggest_fn_clone_suggeststore(void*, RustCallStatus*);
  void uniffi_suggest_fn_free_suggeststore(void*, RustCallStatus*);
  void* uniffi_suggest_fn_clone_suggeststorebuilder(void*, RustCallStatus*);
  void uniffi_suggest_fn_free_suggeststorebuilder(void*, RustCallStatus*);
  int8_t uniffi_suggest_fn_func_raw_suggestion_url_matches(RustBuffer, RustBuffer, RustCallStatus*);
  void* uniffi_suggest_fn_constructor_suggeststore_new(RustBuffer, void*, RustCallStatus*);
  int8_t uniffi_suggest_fn_method_suggeststore_any_dismissed_suggestions(void*, RustCallStatus*);
  void uniffi_suggest_fn_method_suggeststore_clear(void*, RustCallStatus*);
  void uniffi_suggest_fn_method_suggeststore_clear_dismissed_suggestions(void*, RustCallStatus*);
  void uniffi_suggest_fn_method_suggeststore_dismiss_by_key(void*, RustBuffer, RustCallStatus*);
  void uniffi_suggest_fn_method_suggeststore_dismiss_by_suggestion(void*, RustBuffer, RustCallStatus*);
  void uniffi_suggest_fn_method_suggeststore_dismiss_suggestion(void*, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_suggest_fn_method_suggeststore_fetch_geoname_alternates(void*, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_suggest_fn_method_suggeststore_fetch_geonames(void*, RustBuffer, int8_t, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_suggest_fn_method_suggeststore_fetch_global_config(void*, RustCallStatus*);
  RustBuffer uniffi_suggest_fn_method_suggeststore_fetch_provider_config(void*, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_suggest_fn_method_suggeststore_ingest(void*, RustBuffer, RustCallStatus*);
  void uniffi_suggest_fn_method_suggeststore_interrupt(void*, RustBuffer, RustCallStatus*);
  int8_t uniffi_suggest_fn_method_suggeststore_is_dismissed_by_key(void*, RustBuffer, RustCallStatus*);
  int8_t uniffi_suggest_fn_method_suggeststore_is_dismissed_by_suggestion(void*, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_suggest_fn_method_suggeststore_query(void*, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_suggest_fn_method_suggeststore_query_with_metrics(void*, RustBuffer, RustCallStatus*);
  void* uniffi_suggest_fn_constructor_suggeststorebuilder_new(RustCallStatus*);
  void* uniffi_suggest_fn_method_suggeststorebuilder_build(void*, RustCallStatus*);
  void* uniffi_suggest_fn_method_suggeststorebuilder_cache_path(void*, RustBuffer, RustCallStatus*);
  void* uniffi_suggest_fn_method_suggeststorebuilder_data_path(void*, RustBuffer, RustCallStatus*);
  void* uniffi_suggest_fn_method_suggeststorebuilder_load_extension(void*, RustBuffer, RustBuffer, RustCallStatus*);
  void* uniffi_suggest_fn_method_suggeststorebuilder_remote_settings_bucket_name(void*, RustBuffer, RustCallStatus*);
  void* uniffi_suggest_fn_method_suggeststorebuilder_remote_settings_server(void*, RustBuffer, RustCallStatus*);
  void* uniffi_suggest_fn_method_suggeststorebuilder_remote_settings_service(void*, void*, RustCallStatus*);
  uint32_t ffi_suggest_uniffi_contract_version();
  uint16_t uniffi_suggest_checksum_func_raw_suggestion_url_matches();
  uint16_t uniffi_suggest_checksum_constructor_suggeststore_new();
  uint16_t uniffi_suggest_checksum_method_suggeststore_any_dismissed_suggestions();
  uint16_t uniffi_suggest_checksum_method_suggeststore_clear();
  uint16_t uniffi_suggest_checksum_method_suggeststore_clear_dismissed_suggestions();
  uint16_t uniffi_suggest_checksum_method_suggeststore_dismiss_by_key();
  uint16_t uniffi_suggest_checksum_method_suggeststore_dismiss_by_suggestion();
  uint16_t uniffi_suggest_checksum_method_suggeststore_dismiss_suggestion();
  uint16_t uniffi_suggest_checksum_method_suggeststore_fetch_geoname_alternates();
  uint16_t uniffi_suggest_checksum_method_suggeststore_fetch_geonames();
  uint16_t uniffi_suggest_checksum_method_suggeststore_fetch_global_config();
  uint16_t uniffi_suggest_checksum_method_suggeststore_fetch_provider_config();
  uint16_t uniffi_suggest_checksum_method_suggeststore_ingest();
  uint16_t uniffi_suggest_checksum_method_suggeststore_interrupt();
  uint16_t uniffi_suggest_checksum_method_suggeststore_is_dismissed_by_key();
  uint16_t uniffi_suggest_checksum_method_suggeststore_is_dismissed_by_suggestion();
  uint16_t uniffi_suggest_checksum_method_suggeststore_query();
  uint16_t uniffi_suggest_checksum_method_suggeststore_query_with_metrics();
  uint16_t uniffi_suggest_checksum_constructor_suggeststorebuilder_new();
  uint16_t uniffi_suggest_checksum_method_suggeststorebuilder_build();
  uint16_t uniffi_suggest_checksum_method_suggeststorebuilder_cache_path();
  uint16_t uniffi_suggest_checksum_method_suggeststorebuilder_data_path();
  uint16_t uniffi_suggest_checksum_method_suggeststorebuilder_load_extension();
  uint16_t uniffi_suggest_checksum_method_suggeststorebuilder_remote_settings_bucket_name();
  uint16_t uniffi_suggest_checksum_method_suggeststorebuilder_remote_settings_server();
  uint16_t uniffi_suggest_checksum_method_suggeststorebuilder_remote_settings_service();
  RustBuffer ffi_sync15_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_sync15_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_sync15_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_sync15_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_u8(uint64_t);
  uint8_t ffi_sync15_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_free_u8(uint64_t);
  void ffi_sync15_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_i8(uint64_t);
  int8_t ffi_sync15_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_free_i8(uint64_t);
  void ffi_sync15_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_u16(uint64_t);
  uint16_t ffi_sync15_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_free_u16(uint64_t);
  void ffi_sync15_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_i16(uint64_t);
  int16_t ffi_sync15_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_free_i16(uint64_t);
  void ffi_sync15_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_u32(uint64_t);
  uint32_t ffi_sync15_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_free_u32(uint64_t);
  void ffi_sync15_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_i32(uint64_t);
  int32_t ffi_sync15_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_free_i32(uint64_t);
  void ffi_sync15_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_u64(uint64_t);
  uint64_t ffi_sync15_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_free_u64(uint64_t);
  void ffi_sync15_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_i64(uint64_t);
  int64_t ffi_sync15_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_free_i64(uint64_t);
  void ffi_sync15_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_f32(uint64_t);
  float ffi_sync15_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_free_f32(uint64_t);
  void ffi_sync15_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_f64(uint64_t);
  double ffi_sync15_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_free_f64(uint64_t);
  void ffi_sync15_rust_future_poll_pointer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_pointer(uint64_t);
  void* ffi_sync15_rust_future_complete_pointer(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_free_pointer(uint64_t);
  void ffi_sync15_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_rust_buffer(uint64_t);
  RustBuffer ffi_sync15_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_free_rust_buffer(uint64_t);
  void ffi_sync15_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_void(uint64_t);
  void ffi_sync15_rust_future_complete_void(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_free_void(uint64_t);
  uint32_t ffi_sync15_uniffi_contract_version();
  RustBuffer ffi_tabs_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_tabs_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_tabs_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_tabs_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_u8(uint64_t);
  uint8_t ffi_tabs_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_free_u8(uint64_t);
  void ffi_tabs_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_i8(uint64_t);
  int8_t ffi_tabs_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_free_i8(uint64_t);
  void ffi_tabs_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_u16(uint64_t);
  uint16_t ffi_tabs_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_free_u16(uint64_t);
  void ffi_tabs_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_i16(uint64_t);
  int16_t ffi_tabs_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_free_i16(uint64_t);
  void ffi_tabs_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_u32(uint64_t);
  uint32_t ffi_tabs_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_free_u32(uint64_t);
  void ffi_tabs_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_i32(uint64_t);
  int32_t ffi_tabs_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_free_i32(uint64_t);
  void ffi_tabs_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_u64(uint64_t);
  uint64_t ffi_tabs_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_free_u64(uint64_t);
  void ffi_tabs_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_i64(uint64_t);
  int64_t ffi_tabs_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_free_i64(uint64_t);
  void ffi_tabs_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_f32(uint64_t);
  float ffi_tabs_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_free_f32(uint64_t);
  void ffi_tabs_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_f64(uint64_t);
  double ffi_tabs_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_free_f64(uint64_t);
  void ffi_tabs_rust_future_poll_pointer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_pointer(uint64_t);
  void* ffi_tabs_rust_future_complete_pointer(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_free_pointer(uint64_t);
  void ffi_tabs_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_rust_buffer(uint64_t);
  RustBuffer ffi_tabs_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_free_rust_buffer(uint64_t);
  void ffi_tabs_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_void(uint64_t);
  void ffi_tabs_rust_future_complete_void(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_free_void(uint64_t);
  void* uniffi_tabs_fn_clone_remotecommandstore(void*, RustCallStatus*);
  void uniffi_tabs_fn_free_remotecommandstore(void*, RustCallStatus*);
  void* uniffi_tabs_fn_clone_tabsbridgedengine(void*, RustCallStatus*);
  void uniffi_tabs_fn_free_tabsbridgedengine(void*, RustCallStatus*);
  void* uniffi_tabs_fn_clone_tabsstore(void*, RustCallStatus*);
  void uniffi_tabs_fn_free_tabsstore(void*, RustCallStatus*);
  int8_t uniffi_tabs_fn_method_remotecommandstore_add_remote_command(void*, RustBuffer, RustBuffer, RustCallStatus*);
  int8_t uniffi_tabs_fn_method_remotecommandstore_add_remote_command_at(void*, RustBuffer, RustBuffer, int64_t, RustCallStatus*);
  RustBuffer uniffi_tabs_fn_method_remotecommandstore_get_unsent_commands(void*, RustCallStatus*);
  int8_t uniffi_tabs_fn_method_remotecommandstore_remove_remote_command(void*, RustBuffer, RustBuffer, RustCallStatus*);
  int8_t uniffi_tabs_fn_method_remotecommandstore_set_pending_command_sent(void*, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_tabs_fn_method_tabsbridgedengine_apply(void*, RustCallStatus*);
  RustBuffer uniffi_tabs_fn_method_tabsbridgedengine_ensure_current_sync_id(void*, RustBuffer, RustCallStatus*);
  int64_t uniffi_tabs_fn_method_tabsbridgedengine_last_sync(void*, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsbridgedengine_prepare_for_sync(void*, RustBuffer, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsbridgedengine_reset(void*, RustCallStatus*);
  RustBuffer uniffi_tabs_fn_method_tabsbridgedengine_reset_sync_id(void*, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsbridgedengine_set_last_sync(void*, int64_t, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsbridgedengine_set_uploaded(void*, int64_t, RustBuffer, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsbridgedengine_store_incoming(void*, RustBuffer, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsbridgedengine_sync_finished(void*, RustCallStatus*);
  RustBuffer uniffi_tabs_fn_method_tabsbridgedengine_sync_id(void*, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsbridgedengine_sync_started(void*, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsbridgedengine_wipe(void*, RustCallStatus*);
  void* uniffi_tabs_fn_constructor_tabsstore_new(RustBuffer, RustCallStatus*);
  void* uniffi_tabs_fn_method_tabsstore_bridged_engine(void*, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsstore_close_connection(void*, RustCallStatus*);
  RustBuffer uniffi_tabs_fn_method_tabsstore_get_all(void*, RustCallStatus*);
  void* uniffi_tabs_fn_method_tabsstore_new_remote_command_store(void*, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsstore_register_with_sync_manager(void*, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsstore_set_local_tabs(void*, RustBuffer, RustCallStatus*);
  uint32_t ffi_tabs_uniffi_contract_version();
  uint16_t uniffi_tabs_checksum_method_remotecommandstore_add_remote_command();
  uint16_t uniffi_tabs_checksum_method_remotecommandstore_add_remote_command_at();
  uint16_t uniffi_tabs_checksum_method_remotecommandstore_get_unsent_commands();
  uint16_t uniffi_tabs_checksum_method_remotecommandstore_remove_remote_command();
  uint16_t uniffi_tabs_checksum_method_remotecommandstore_set_pending_command_sent();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_apply();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_ensure_current_sync_id();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_last_sync();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_prepare_for_sync();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_reset();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_reset_sync_id();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_set_last_sync();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_set_uploaded();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_store_incoming();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_sync_finished();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_sync_id();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_sync_started();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_wipe();
  uint16_t uniffi_tabs_checksum_constructor_tabsstore_new();
  uint16_t uniffi_tabs_checksum_method_tabsstore_bridged_engine();
  uint16_t uniffi_tabs_checksum_method_tabsstore_close_connection();
  uint16_t uniffi_tabs_checksum_method_tabsstore_get_all();
  uint16_t uniffi_tabs_checksum_method_tabsstore_new_remote_command_store();
  uint16_t uniffi_tabs_checksum_method_tabsstore_register_with_sync_manager();
  uint16_t uniffi_tabs_checksum_method_tabsstore_set_local_tabs();
  RustBuffer ffi_webext_storage_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_webext_storage_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_webext_storage_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_webext_storage_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_u8(uint64_t);
  uint8_t ffi_webext_storage_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_free_u8(uint64_t);
  void ffi_webext_storage_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_i8(uint64_t);
  int8_t ffi_webext_storage_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_free_i8(uint64_t);
  void ffi_webext_storage_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_u16(uint64_t);
  uint16_t ffi_webext_storage_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_free_u16(uint64_t);
  void ffi_webext_storage_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_i16(uint64_t);
  int16_t ffi_webext_storage_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_free_i16(uint64_t);
  void ffi_webext_storage_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_u32(uint64_t);
  uint32_t ffi_webext_storage_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_free_u32(uint64_t);
  void ffi_webext_storage_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_i32(uint64_t);
  int32_t ffi_webext_storage_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_free_i32(uint64_t);
  void ffi_webext_storage_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_u64(uint64_t);
  uint64_t ffi_webext_storage_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_free_u64(uint64_t);
  void ffi_webext_storage_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_i64(uint64_t);
  int64_t ffi_webext_storage_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_free_i64(uint64_t);
  void ffi_webext_storage_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_f32(uint64_t);
  float ffi_webext_storage_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_free_f32(uint64_t);
  void ffi_webext_storage_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_f64(uint64_t);
  double ffi_webext_storage_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_free_f64(uint64_t);
  void ffi_webext_storage_rust_future_poll_pointer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_pointer(uint64_t);
  void* ffi_webext_storage_rust_future_complete_pointer(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_free_pointer(uint64_t);
  void ffi_webext_storage_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_rust_buffer(uint64_t);
  RustBuffer ffi_webext_storage_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_free_rust_buffer(uint64_t);
  void ffi_webext_storage_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_void(uint64_t);
  void ffi_webext_storage_rust_future_complete_void(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_free_void(uint64_t);
  void* uniffi_webext_storage_fn_clone_webextstoragebridgedengine(void*, RustCallStatus*);
  void uniffi_webext_storage_fn_free_webextstoragebridgedengine(void*, RustCallStatus*);
  void* uniffi_webext_storage_fn_clone_webextstoragestore(void*, RustCallStatus*);
  void uniffi_webext_storage_fn_free_webextstoragestore(void*, RustCallStatus*);
  RustBuffer uniffi_webext_storage_fn_method_webextstoragebridgedengine_apply(void*, RustCallStatus*);
  RustBuffer uniffi_webext_storage_fn_method_webextstoragebridgedengine_ensure_current_sync_id(void*, RustBuffer, RustCallStatus*);
  int64_t uniffi_webext_storage_fn_method_webextstoragebridgedengine_last_sync(void*, RustCallStatus*);
  void uniffi_webext_storage_fn_method_webextstoragebridgedengine_prepare_for_sync(void*, RustBuffer, RustCallStatus*);
  void uniffi_webext_storage_fn_method_webextstoragebridgedengine_reset(void*, RustCallStatus*);
  RustBuffer uniffi_webext_storage_fn_method_webextstoragebridgedengine_reset_sync_id(void*, RustCallStatus*);
  void uniffi_webext_storage_fn_method_webextstoragebridgedengine_set_last_sync(void*, int64_t, RustCallStatus*);
  void uniffi_webext_storage_fn_method_webextstoragebridgedengine_set_uploaded(void*, int64_t, RustBuffer, RustCallStatus*);
  void uniffi_webext_storage_fn_method_webextstoragebridgedengine_store_incoming(void*, RustBuffer, RustCallStatus*);
  void uniffi_webext_storage_fn_method_webextstoragebridgedengine_sync_finished(void*, RustCallStatus*);
  RustBuffer uniffi_webext_storage_fn_method_webextstoragebridgedengine_sync_id(void*, RustCallStatus*);
  void uniffi_webext_storage_fn_method_webextstoragebridgedengine_sync_started(void*, RustCallStatus*);
  void uniffi_webext_storage_fn_method_webextstoragebridgedengine_wipe(void*, RustCallStatus*);
  void* uniffi_webext_storage_fn_constructor_webextstoragestore_new(RustBuffer, RustCallStatus*);
  void* uniffi_webext_storage_fn_method_webextstoragestore_bridged_engine(void*, RustCallStatus*);
  RustBuffer uniffi_webext_storage_fn_method_webextstoragestore_clear(void*, RustBuffer, RustCallStatus*);
  void uniffi_webext_storage_fn_method_webextstoragestore_close(void*, RustCallStatus*);
  RustBuffer uniffi_webext_storage_fn_method_webextstoragestore_get(void*, RustBuffer, RustBuffer, RustCallStatus*);
  uint64_t uniffi_webext_storage_fn_method_webextstoragestore_get_bytes_in_use(void*, RustBuffer, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_webext_storage_fn_method_webextstoragestore_get_synced_changes(void*, RustCallStatus*);
  RustBuffer uniffi_webext_storage_fn_method_webextstoragestore_remove(void*, RustBuffer, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_webext_storage_fn_method_webextstoragestore_set(void*, RustBuffer, RustBuffer, RustCallStatus*);
  uint32_t ffi_webext_storage_uniffi_contract_version();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_apply();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_ensure_current_sync_id();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_last_sync();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_prepare_for_sync();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_reset();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_reset_sync_id();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_set_last_sync();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_set_uploaded();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_store_incoming();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_sync_finished();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_sync_id();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_sync_started();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_wipe();
  uint16_t uniffi_webext_storage_checksum_constructor_webextstoragestore_new();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragestore_bridged_engine();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragestore_clear();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragestore_close();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragestore_get();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragestore_get_bytes_in_use();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragestore_get_synced_changes();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragestore_remove();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragestore_set();

#ifdef MOZ_UNIFFI_FIXTURES
  RustBuffer ffi_uniffi_bindings_tests_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_uniffi_bindings_tests_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_uniffi_bindings_tests_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_cancel_u8(uint64_t);
  uint8_t ffi_uniffi_bindings_tests_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rust_future_free_u8(uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_cancel_i8(uint64_t);
  int8_t ffi_uniffi_bindings_tests_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rust_future_free_i8(uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_cancel_u16(uint64_t);
  uint16_t ffi_uniffi_bindings_tests_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rust_future_free_u16(uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_cancel_i16(uint64_t);
  int16_t ffi_uniffi_bindings_tests_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rust_future_free_i16(uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_cancel_u32(uint64_t);
  uint32_t ffi_uniffi_bindings_tests_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rust_future_free_u32(uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_cancel_i32(uint64_t);
  int32_t ffi_uniffi_bindings_tests_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rust_future_free_i32(uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_cancel_u64(uint64_t);
  uint64_t ffi_uniffi_bindings_tests_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rust_future_free_u64(uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_cancel_i64(uint64_t);
  int64_t ffi_uniffi_bindings_tests_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rust_future_free_i64(uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_cancel_f32(uint64_t);
  float ffi_uniffi_bindings_tests_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rust_future_free_f32(uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_cancel_f64(uint64_t);
  double ffi_uniffi_bindings_tests_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rust_future_free_f64(uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_poll_pointer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_cancel_pointer(uint64_t);
  void* ffi_uniffi_bindings_tests_rust_future_complete_pointer(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rust_future_free_pointer(uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_cancel_rust_buffer(uint64_t);
  RustBuffer ffi_uniffi_bindings_tests_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rust_future_free_rust_buffer(uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_cancel_void(uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_complete_void(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rust_future_free_void(uint64_t);
  void* uniffi_uniffi_bindings_tests_fn_clone_asyncinterface(void*, RustCallStatus*);
  void uniffi_uniffi_bindings_tests_fn_free_asyncinterface(void*, RustCallStatus*);
  void* uniffi_uniffi_bindings_tests_fn_clone_asynctesttraitinterface(void*, RustCallStatus*);
  void uniffi_uniffi_bindings_tests_fn_free_asynctesttraitinterface(void*, RustCallStatus*);
  void* uniffi_uniffi_bindings_tests_fn_clone_complexmethods(void*, RustCallStatus*);
  void uniffi_uniffi_bindings_tests_fn_free_complexmethods(void*, RustCallStatus*);
  void* uniffi_uniffi_bindings_tests_fn_clone_testinterface(void*, RustCallStatus*);
  void uniffi_uniffi_bindings_tests_fn_free_testinterface(void*, RustCallStatus*);
  void* uniffi_uniffi_bindings_tests_fn_clone_testtraitinterface(void*, RustCallStatus*);
  void uniffi_uniffi_bindings_tests_fn_free_testtraitinterface(void*, RustCallStatus*);
  struct ForeignFutureResultVoid {
    RustCallStatus call_status;
  };
  typedef void (*ForeignFutureCompletevoid)(uint64_t, ForeignFutureResultVoid);
  typedef void (*CallbackInterfaceUniffiBindingsTestsAsyncTestTraitInterfaceMethod0)(uint64_t, ForeignFutureCompletevoid, uint64_t, ForeignFuture*);
  struct ForeignFutureResultU32 {
    uint32_t return_value;
    RustCallStatus call_status;
  };
  typedef void (*ForeignFutureCompleteu32)(uint64_t, ForeignFutureResultU32);
  typedef void (*CallbackInterfaceUniffiBindingsTestsAsyncTestTraitInterfaceMethod1)(uint64_t, ForeignFutureCompleteu32, uint64_t, ForeignFuture*);
  typedef void (*CallbackInterfaceUniffiBindingsTestsAsyncTestTraitInterfaceMethod2)(uint64_t, uint32_t, ForeignFutureCompletevoid, uint64_t, ForeignFuture*);
  struct ForeignFutureResultRustBuffer {
    RustBuffer return_value;
    RustCallStatus call_status;
  };
  typedef void (*ForeignFutureCompleterust_buffer)(uint64_t, ForeignFutureResultRustBuffer);
  typedef void (*CallbackInterfaceUniffiBindingsTestsAsyncTestTraitInterfaceMethod3)(uint64_t, RustBuffer, ForeignFutureCompleterust_buffer, uint64_t, ForeignFuture*);
  typedef void (*CallbackInterfaceFreeUniffiBindingsTests_AsyncTestTraitInterface)(uint64_t);
  struct VTableCallbackInterfaceUniffiBindingsTestsAsyncTestTraitInterface {
    CallbackInterfaceUniffiBindingsTestsAsyncTestTraitInterfaceMethod0 noop;
    CallbackInterfaceUniffiBindingsTestsAsyncTestTraitInterfaceMethod1 get_value;
    CallbackInterfaceUniffiBindingsTestsAsyncTestTraitInterfaceMethod2 set_value;
    CallbackInterfaceUniffiBindingsTestsAsyncTestTraitInterfaceMethod3 throw_if_equal;
    CallbackInterfaceFreeUniffiBindingsTests_AsyncTestTraitInterface uniffi_free;
  };
  void uniffi_uniffi_bindings_tests_fn_init_callback_vtable_asynctesttraitinterface(VTableCallbackInterfaceUniffiBindingsTestsAsyncTestTraitInterface*);
  typedef void (*CallbackInterfaceUniffiBindingsTestsTestTraitInterfaceMethod0)(uint64_t, void*, RustCallStatus*);
  typedef void (*CallbackInterfaceUniffiBindingsTestsTestTraitInterfaceMethod1)(uint64_t, uint32_t*, RustCallStatus*);
  typedef void (*CallbackInterfaceUniffiBindingsTestsTestTraitInterfaceMethod2)(uint64_t, uint32_t, void*, RustCallStatus*);
  typedef void (*CallbackInterfaceUniffiBindingsTestsTestTraitInterfaceMethod3)(uint64_t, RustBuffer, RustBuffer*, RustCallStatus*);
  typedef void (*CallbackInterfaceFreeUniffiBindingsTests_TestTraitInterface)(uint64_t);
  struct VTableCallbackInterfaceUniffiBindingsTestsTestTraitInterface {
    CallbackInterfaceUniffiBindingsTestsTestTraitInterfaceMethod0 noop;
    CallbackInterfaceUniffiBindingsTestsTestTraitInterfaceMethod1 get_value;
    CallbackInterfaceUniffiBindingsTestsTestTraitInterfaceMethod2 set_value;
    CallbackInterfaceUniffiBindingsTestsTestTraitInterfaceMethod3 throw_if_equal;
    CallbackInterfaceFreeUniffiBindingsTests_TestTraitInterface uniffi_free;
  };
  void uniffi_uniffi_bindings_tests_fn_init_callback_vtable_testtraitinterface(VTableCallbackInterfaceUniffiBindingsTestsTestTraitInterface*);
  typedef void (*CallbackInterfaceUniffiBindingsTestsTestAsyncCallbackInterfaceMethod0)(uint64_t, ForeignFutureCompletevoid, uint64_t, ForeignFuture*);
  typedef void (*CallbackInterfaceUniffiBindingsTestsTestAsyncCallbackInterfaceMethod1)(uint64_t, ForeignFutureCompleteu32, uint64_t, ForeignFuture*);
  typedef void (*CallbackInterfaceUniffiBindingsTestsTestAsyncCallbackInterfaceMethod2)(uint64_t, uint32_t, ForeignFutureCompletevoid, uint64_t, ForeignFuture*);
  typedef void (*CallbackInterfaceUniffiBindingsTestsTestAsyncCallbackInterfaceMethod3)(uint64_t, RustBuffer, ForeignFutureCompleterust_buffer, uint64_t, ForeignFuture*);
  typedef void (*CallbackInterfaceFreeUniffiBindingsTests_TestAsyncCallbackInterface)(uint64_t);
  struct VTableCallbackInterfaceUniffiBindingsTestsTestAsyncCallbackInterface {
    CallbackInterfaceUniffiBindingsTestsTestAsyncCallbackInterfaceMethod0 noop;
    CallbackInterfaceUniffiBindingsTestsTestAsyncCallbackInterfaceMethod1 get_value;
    CallbackInterfaceUniffiBindingsTestsTestAsyncCallbackInterfaceMethod2 set_value;
    CallbackInterfaceUniffiBindingsTestsTestAsyncCallbackInterfaceMethod3 throw_if_equal;
    CallbackInterfaceFreeUniffiBindingsTests_TestAsyncCallbackInterface uniffi_free;
  };
  void uniffi_uniffi_bindings_tests_fn_init_callback_vtable_testasynccallbackinterface(VTableCallbackInterfaceUniffiBindingsTestsTestAsyncCallbackInterface*);
  typedef void (*CallbackInterfaceUniffiBindingsTestsTestCallbackInterfaceMethod0)(uint64_t, void*, RustCallStatus*);
  typedef void (*CallbackInterfaceUniffiBindingsTestsTestCallbackInterfaceMethod1)(uint64_t, uint32_t*, RustCallStatus*);
  typedef void (*CallbackInterfaceUniffiBindingsTestsTestCallbackInterfaceMethod2)(uint64_t, uint32_t, void*, RustCallStatus*);
  typedef void (*CallbackInterfaceUniffiBindingsTestsTestCallbackInterfaceMethod3)(uint64_t, RustBuffer, RustBuffer*, RustCallStatus*);
  typedef void (*CallbackInterfaceFreeUniffiBindingsTests_TestCallbackInterface)(uint64_t);
  struct VTableCallbackInterfaceUniffiBindingsTestsTestCallbackInterface {
    CallbackInterfaceUniffiBindingsTestsTestCallbackInterfaceMethod0 noop;
    CallbackInterfaceUniffiBindingsTestsTestCallbackInterfaceMethod1 get_value;
    CallbackInterfaceUniffiBindingsTestsTestCallbackInterfaceMethod2 set_value;
    CallbackInterfaceUniffiBindingsTestsTestCallbackInterfaceMethod3 throw_if_equal;
    CallbackInterfaceFreeUniffiBindingsTests_TestCallbackInterface uniffi_free;
  };
  void uniffi_uniffi_bindings_tests_fn_init_callback_vtable_testcallbackinterface(VTableCallbackInterfaceUniffiBindingsTestsTestCallbackInterface*);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_f32(float);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_f64(double);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_i16(int16_t);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_i32(int32_t);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_i64(int64_t);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_i8(int8_t);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_map(RustBuffer);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_obj(void*);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_string(RustBuffer);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_u16(uint16_t);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_u32(uint32_t);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_u64(uint64_t);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_u8(uint8_t);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_vec(RustBuffer);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_throw_error();
  void* uniffi_uniffi_bindings_tests_fn_func_clone_interface(void*, RustCallStatus*);
  void* uniffi_uniffi_bindings_tests_fn_func_create_async_test_trait_interface(uint32_t, RustCallStatus*);
  void* uniffi_uniffi_bindings_tests_fn_func_create_test_trait_interface(uint32_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_func_with_default(RustBuffer, RustCallStatus*);
  void uniffi_uniffi_bindings_tests_fn_func_func_with_error(uint32_t, RustCallStatus*);
  void uniffi_uniffi_bindings_tests_fn_func_func_with_flat_error(uint32_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_func_with_multi_word_arg(RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_get_custom_types_demo(RustCallStatus*);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_invoke_async_test_trait_interface_get_value(void*);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_invoke_async_test_trait_interface_noop(void*);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_invoke_async_test_trait_interface_set_value(void*, uint32_t);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_invoke_async_test_trait_interface_throw_if_equal(void*, RustBuffer);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_invoke_test_async_callback_interface_get_value(uint64_t);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_invoke_test_async_callback_interface_noop(uint64_t);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_invoke_test_async_callback_interface_set_value(uint64_t, uint32_t);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_invoke_test_async_callback_interface_throw_if_equal(uint64_t, RustBuffer);
  uint32_t uniffi_uniffi_bindings_tests_fn_func_invoke_test_callback_interface_get_value(uint64_t, RustCallStatus*);
  void uniffi_uniffi_bindings_tests_fn_func_invoke_test_callback_interface_noop(uint64_t, RustCallStatus*);
  void uniffi_uniffi_bindings_tests_fn_func_invoke_test_callback_interface_set_value(uint64_t, uint32_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_invoke_test_callback_interface_throw_if_equal(uint64_t, RustBuffer, RustCallStatus*);
  uint32_t uniffi_uniffi_bindings_tests_fn_func_invoke_test_trait_interface_get_value(void*, RustCallStatus*);
  void uniffi_uniffi_bindings_tests_fn_func_invoke_test_trait_interface_noop(void*, RustCallStatus*);
  void uniffi_uniffi_bindings_tests_fn_func_invoke_test_trait_interface_set_value(void*, uint32_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_invoke_test_trait_interface_throw_if_equal(void*, RustBuffer, RustCallStatus*);
  int8_t uniffi_uniffi_bindings_tests_fn_func_roundtrip_bool(int8_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_roundtrip_complex_compound(RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_roundtrip_complex_enum(RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_roundtrip_complex_rec(RustBuffer, RustCallStatus*);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_roundtrip_custom_type(uint64_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_roundtrip_enum_no_data(RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_roundtrip_enum_with_data(RustBuffer, RustCallStatus*);
  float uniffi_uniffi_bindings_tests_fn_func_roundtrip_f32(float, RustCallStatus*);
  double uniffi_uniffi_bindings_tests_fn_func_roundtrip_f64(double, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_roundtrip_hash_map(RustBuffer, RustCallStatus*);
  int16_t uniffi_uniffi_bindings_tests_fn_func_roundtrip_i16(int16_t, RustCallStatus*);
  int32_t uniffi_uniffi_bindings_tests_fn_func_roundtrip_i32(int32_t, RustCallStatus*);
  int64_t uniffi_uniffi_bindings_tests_fn_func_roundtrip_i64(int64_t, RustCallStatus*);
  int8_t uniffi_uniffi_bindings_tests_fn_func_roundtrip_i8(int8_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_roundtrip_option(RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_roundtrip_simple_rec(RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_roundtrip_string(RustBuffer, RustCallStatus*);
  int64_t uniffi_uniffi_bindings_tests_fn_func_roundtrip_time_interval_ms(int64_t, RustCallStatus*);
  double uniffi_uniffi_bindings_tests_fn_func_roundtrip_time_interval_sec_dbl(double, RustCallStatus*);
  float uniffi_uniffi_bindings_tests_fn_func_roundtrip_time_interval_sec_flt(float, RustCallStatus*);
  uint16_t uniffi_uniffi_bindings_tests_fn_func_roundtrip_u16(uint16_t, RustCallStatus*);
  uint32_t uniffi_uniffi_bindings_tests_fn_func_roundtrip_u32(uint32_t, RustCallStatus*);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_roundtrip_u64(uint64_t, RustCallStatus*);
  uint8_t uniffi_uniffi_bindings_tests_fn_func_roundtrip_u8(uint8_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_roundtrip_url(RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_roundtrip_vec(RustBuffer, RustCallStatus*);
  double uniffi_uniffi_bindings_tests_fn_func_sum_with_many_types(uint8_t, int8_t, uint16_t, int16_t, uint32_t, int32_t, uint64_t, int64_t, float, double, int8_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_swap_test_interfaces(RustBuffer, RustCallStatus*);
  void uniffi_uniffi_bindings_tests_fn_func_test_func(RustCallStatus*);
  void* uniffi_uniffi_bindings_tests_fn_constructor_asyncinterface_new(RustBuffer, RustCallStatus*);
  uint64_t uniffi_uniffi_bindings_tests_fn_method_asyncinterface_name(void*);
  uint64_t uniffi_uniffi_bindings_tests_fn_method_asynctesttraitinterface_noop(void*);
  uint64_t uniffi_uniffi_bindings_tests_fn_method_asynctesttraitinterface_get_value(void*);
  uint64_t uniffi_uniffi_bindings_tests_fn_method_asynctesttraitinterface_set_value(void*, uint32_t);
  uint64_t uniffi_uniffi_bindings_tests_fn_method_asynctesttraitinterface_throw_if_equal(void*, RustBuffer);
  void* uniffi_uniffi_bindings_tests_fn_constructor_complexmethods_new(RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_method_complexmethods_method_with_default(void*, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_method_complexmethods_method_with_multi_word_arg(void*, RustBuffer, RustCallStatus*);
  void* uniffi_uniffi_bindings_tests_fn_constructor_testinterface_new(uint32_t, RustCallStatus*);
  uint32_t uniffi_uniffi_bindings_tests_fn_method_testinterface_get_value(void*, RustCallStatus*);
  uint32_t uniffi_uniffi_bindings_tests_fn_method_testinterface_ref_count(void*, RustCallStatus*);
  void uniffi_uniffi_bindings_tests_fn_method_testtraitinterface_noop(void*, RustCallStatus*);
  uint32_t uniffi_uniffi_bindings_tests_fn_method_testtraitinterface_get_value(void*, RustCallStatus*);
  void uniffi_uniffi_bindings_tests_fn_method_testtraitinterface_set_value(void*, uint32_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_method_testtraitinterface_throw_if_equal(void*, RustBuffer, RustCallStatus*);
  uint32_t ffi_uniffi_bindings_tests_uniffi_contract_version();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_roundtrip_f32();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_roundtrip_f64();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_roundtrip_i16();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_roundtrip_i32();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_roundtrip_i64();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_roundtrip_i8();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_roundtrip_map();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_roundtrip_obj();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_roundtrip_string();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_roundtrip_u16();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_roundtrip_u32();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_roundtrip_u64();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_roundtrip_u8();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_roundtrip_vec();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_throw_error();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_clone_interface();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_create_async_test_trait_interface();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_create_test_trait_interface();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_func_with_default();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_func_with_error();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_func_with_flat_error();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_func_with_multi_word_arg();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_get_custom_types_demo();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_invoke_async_test_trait_interface_get_value();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_invoke_async_test_trait_interface_noop();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_invoke_async_test_trait_interface_set_value();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_invoke_async_test_trait_interface_throw_if_equal();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_invoke_test_async_callback_interface_get_value();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_invoke_test_async_callback_interface_noop();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_invoke_test_async_callback_interface_set_value();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_invoke_test_async_callback_interface_throw_if_equal();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_invoke_test_callback_interface_get_value();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_invoke_test_callback_interface_noop();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_invoke_test_callback_interface_set_value();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_invoke_test_callback_interface_throw_if_equal();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_invoke_test_trait_interface_get_value();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_invoke_test_trait_interface_noop();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_invoke_test_trait_interface_set_value();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_invoke_test_trait_interface_throw_if_equal();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_bool();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_complex_compound();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_complex_enum();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_complex_rec();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_custom_type();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_enum_no_data();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_enum_with_data();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_f32();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_f64();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_hash_map();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_i16();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_i32();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_i64();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_i8();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_option();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_simple_rec();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_string();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_time_interval_ms();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_time_interval_sec_dbl();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_time_interval_sec_flt();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_u16();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_u32();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_u64();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_u8();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_url();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_vec();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_sum_with_many_types();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_swap_test_interfaces();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_test_func();
  uint16_t uniffi_uniffi_bindings_tests_checksum_constructor_asyncinterface_new();
  uint16_t uniffi_uniffi_bindings_tests_checksum_method_asyncinterface_name();
  uint16_t uniffi_uniffi_bindings_tests_checksum_method_asynctesttraitinterface_noop();
  uint16_t uniffi_uniffi_bindings_tests_checksum_method_asynctesttraitinterface_get_value();
  uint16_t uniffi_uniffi_bindings_tests_checksum_method_asynctesttraitinterface_set_value();
  uint16_t uniffi_uniffi_bindings_tests_checksum_method_asynctesttraitinterface_throw_if_equal();
  uint16_t uniffi_uniffi_bindings_tests_checksum_constructor_complexmethods_new();
  uint16_t uniffi_uniffi_bindings_tests_checksum_method_complexmethods_method_with_default();
  uint16_t uniffi_uniffi_bindings_tests_checksum_method_complexmethods_method_with_multi_word_arg();
  uint16_t uniffi_uniffi_bindings_tests_checksum_constructor_testinterface_new();
  uint16_t uniffi_uniffi_bindings_tests_checksum_method_testinterface_get_value();
  uint16_t uniffi_uniffi_bindings_tests_checksum_method_testinterface_ref_count();
  uint16_t uniffi_uniffi_bindings_tests_checksum_method_testtraitinterface_noop();
  uint16_t uniffi_uniffi_bindings_tests_checksum_method_testtraitinterface_get_value();
  uint16_t uniffi_uniffi_bindings_tests_checksum_method_testtraitinterface_set_value();
  uint16_t uniffi_uniffi_bindings_tests_checksum_method_testtraitinterface_throw_if_equal();
  RustBuffer ffi_uniffi_bindings_tests_collision_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_uniffi_bindings_tests_collision_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_uniffi_bindings_tests_collision_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_uniffi_bindings_tests_collision_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_collision_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_cancel_u8(uint64_t);
  uint8_t ffi_uniffi_bindings_tests_collision_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_collision_rust_future_free_u8(uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_cancel_i8(uint64_t);
  int8_t ffi_uniffi_bindings_tests_collision_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_collision_rust_future_free_i8(uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_cancel_u16(uint64_t);
  uint16_t ffi_uniffi_bindings_tests_collision_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_collision_rust_future_free_u16(uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_cancel_i16(uint64_t);
  int16_t ffi_uniffi_bindings_tests_collision_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_collision_rust_future_free_i16(uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_cancel_u32(uint64_t);
  uint32_t ffi_uniffi_bindings_tests_collision_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_collision_rust_future_free_u32(uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_cancel_i32(uint64_t);
  int32_t ffi_uniffi_bindings_tests_collision_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_collision_rust_future_free_i32(uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_cancel_u64(uint64_t);
  uint64_t ffi_uniffi_bindings_tests_collision_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_collision_rust_future_free_u64(uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_cancel_i64(uint64_t);
  int64_t ffi_uniffi_bindings_tests_collision_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_collision_rust_future_free_i64(uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_cancel_f32(uint64_t);
  float ffi_uniffi_bindings_tests_collision_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_collision_rust_future_free_f32(uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_cancel_f64(uint64_t);
  double ffi_uniffi_bindings_tests_collision_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_collision_rust_future_free_f64(uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_poll_pointer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_cancel_pointer(uint64_t);
  void* ffi_uniffi_bindings_tests_collision_rust_future_complete_pointer(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_collision_rust_future_free_pointer(uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_cancel_rust_buffer(uint64_t);
  RustBuffer ffi_uniffi_bindings_tests_collision_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_collision_rust_future_free_rust_buffer(uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_cancel_void(uint64_t);
  void ffi_uniffi_bindings_tests_collision_rust_future_complete_void(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_collision_rust_future_free_void(uint64_t);
  typedef void (*CallbackInterfaceUniffiBindingsTestsCollisionTestCallbackInterfaceMethod0)(uint64_t, RustBuffer*, RustCallStatus*);
  typedef void (*CallbackInterfaceFreeUniffiBindingsTestsCollision_TestCallbackInterface)(uint64_t);
  struct VTableCallbackInterfaceUniffiBindingsTestsCollisionTestCallbackInterface {
    CallbackInterfaceUniffiBindingsTestsCollisionTestCallbackInterfaceMethod0 get_value;
    CallbackInterfaceFreeUniffiBindingsTestsCollision_TestCallbackInterface uniffi_free;
  };
  void uniffi_uniffi_bindings_tests_collision_fn_init_callback_vtable_testcallbackinterface(VTableCallbackInterfaceUniffiBindingsTestsCollisionTestCallbackInterface*);
  RustBuffer uniffi_uniffi_bindings_tests_collision_fn_func_invoke_collision_callback(uint64_t, RustCallStatus*);
  uint32_t ffi_uniffi_bindings_tests_collision_uniffi_contract_version();
  uint16_t uniffi_uniffi_bindings_tests_collision_checksum_func_invoke_collision_callback();
  RustBuffer ffi_uniffi_bindings_tests_external_types_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_uniffi_bindings_tests_external_types_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_uniffi_bindings_tests_external_types_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_cancel_u8(uint64_t);
  uint8_t ffi_uniffi_bindings_tests_external_types_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rust_future_free_u8(uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_cancel_i8(uint64_t);
  int8_t ffi_uniffi_bindings_tests_external_types_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rust_future_free_i8(uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_cancel_u16(uint64_t);
  uint16_t ffi_uniffi_bindings_tests_external_types_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rust_future_free_u16(uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_cancel_i16(uint64_t);
  int16_t ffi_uniffi_bindings_tests_external_types_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rust_future_free_i16(uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_cancel_u32(uint64_t);
  uint32_t ffi_uniffi_bindings_tests_external_types_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rust_future_free_u32(uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_cancel_i32(uint64_t);
  int32_t ffi_uniffi_bindings_tests_external_types_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rust_future_free_i32(uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_cancel_u64(uint64_t);
  uint64_t ffi_uniffi_bindings_tests_external_types_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rust_future_free_u64(uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_cancel_i64(uint64_t);
  int64_t ffi_uniffi_bindings_tests_external_types_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rust_future_free_i64(uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_cancel_f32(uint64_t);
  float ffi_uniffi_bindings_tests_external_types_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rust_future_free_f32(uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_cancel_f64(uint64_t);
  double ffi_uniffi_bindings_tests_external_types_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rust_future_free_f64(uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_poll_pointer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_cancel_pointer(uint64_t);
  void* ffi_uniffi_bindings_tests_external_types_rust_future_complete_pointer(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rust_future_free_pointer(uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_cancel_rust_buffer(uint64_t);
  RustBuffer ffi_uniffi_bindings_tests_external_types_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rust_future_free_rust_buffer(uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_cancel_void(uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_complete_void(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rust_future_free_void(uint64_t);
  uint64_t uniffi_uniffi_bindings_tests_external_types_fn_func_roundtrip_ext_custom_type(uint64_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_external_types_fn_func_roundtrip_ext_enum(RustBuffer, RustCallStatus*);
  void* uniffi_uniffi_bindings_tests_external_types_fn_func_roundtrip_ext_interface(void*, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_external_types_fn_func_roundtrip_ext_record(RustBuffer, RustCallStatus*);
  uint32_t ffi_uniffi_bindings_tests_external_types_uniffi_contract_version();
  uint16_t uniffi_uniffi_bindings_tests_external_types_checksum_func_roundtrip_ext_custom_type();
  uint16_t uniffi_uniffi_bindings_tests_external_types_checksum_func_roundtrip_ext_enum();
  uint16_t uniffi_uniffi_bindings_tests_external_types_checksum_func_roundtrip_ext_interface();
  uint16_t uniffi_uniffi_bindings_tests_external_types_checksum_func_roundtrip_ext_record();
#endif /* MOZ_UNIFFI_FIXTURES */
}
/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set ts=8 sts=2 et sw=2 tw=80: */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

// Define pointer types

const static mozilla::uniffi::UniFFIPointerType kContextIdContextIdComponentPointerType {
  "context_id::ContextIDComponent"_ns,
  uniffi_context_id_fn_clone_contextidcomponent,
  uniffi_context_id_fn_free_contextidcomponent,
};
class FfiValueObjectHandleContextIdContextIdComponent {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleContextIdContextIdComponent() = default;
  explicit FfiValueObjectHandleContextIdContextIdComponent(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleContextIdContextIdComponent(const FfiValueObjectHandleContextIdContextIdComponent&) = delete;
  FfiValueObjectHandleContextIdContextIdComponent& operator=(const FfiValueObjectHandleContextIdContextIdComponent&) = delete;

  FfiValueObjectHandleContextIdContextIdComponent& operator=(FfiValueObjectHandleContextIdContextIdComponent&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kContextIdContextIdComponentPointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  // LowerReceiver is used for method receivers.  For non-trait interfaces, it works exactly the
  // same as `Lower`
  void LowerReciever(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    Lower(aValue, aError);
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kContextIdContextIdComponentPointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleContextIdContextIdComponent FromRust(void* aValue) {
    return FfiValueObjectHandleContextIdContextIdComponent(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_context_id_fn_free_contextidcomponent)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleContextIdContextIdComponent() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kRelevancyRelevancyStorePointerType {
  "relevancy::RelevancyStore"_ns,
  uniffi_relevancy_fn_clone_relevancystore,
  uniffi_relevancy_fn_free_relevancystore,
};
class FfiValueObjectHandleRelevancyRelevancyStore {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleRelevancyRelevancyStore() = default;
  explicit FfiValueObjectHandleRelevancyRelevancyStore(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleRelevancyRelevancyStore(const FfiValueObjectHandleRelevancyRelevancyStore&) = delete;
  FfiValueObjectHandleRelevancyRelevancyStore& operator=(const FfiValueObjectHandleRelevancyRelevancyStore&) = delete;

  FfiValueObjectHandleRelevancyRelevancyStore& operator=(FfiValueObjectHandleRelevancyRelevancyStore&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kRelevancyRelevancyStorePointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  // LowerReceiver is used for method receivers.  For non-trait interfaces, it works exactly the
  // same as `Lower`
  void LowerReciever(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    Lower(aValue, aError);
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kRelevancyRelevancyStorePointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleRelevancyRelevancyStore FromRust(void* aValue) {
    return FfiValueObjectHandleRelevancyRelevancyStore(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_relevancy_fn_free_relevancystore)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleRelevancyRelevancyStore() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kRemoteSettingsRemoteSettingsPointerType {
  "remote_settings::RemoteSettings"_ns,
  uniffi_remote_settings_fn_clone_remotesettings,
  uniffi_remote_settings_fn_free_remotesettings,
};
class FfiValueObjectHandleRemoteSettingsRemoteSettings {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleRemoteSettingsRemoteSettings() = default;
  explicit FfiValueObjectHandleRemoteSettingsRemoteSettings(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleRemoteSettingsRemoteSettings(const FfiValueObjectHandleRemoteSettingsRemoteSettings&) = delete;
  FfiValueObjectHandleRemoteSettingsRemoteSettings& operator=(const FfiValueObjectHandleRemoteSettingsRemoteSettings&) = delete;

  FfiValueObjectHandleRemoteSettingsRemoteSettings& operator=(FfiValueObjectHandleRemoteSettingsRemoteSettings&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kRemoteSettingsRemoteSettingsPointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  // LowerReceiver is used for method receivers.  For non-trait interfaces, it works exactly the
  // same as `Lower`
  void LowerReciever(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    Lower(aValue, aError);
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kRemoteSettingsRemoteSettingsPointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleRemoteSettingsRemoteSettings FromRust(void* aValue) {
    return FfiValueObjectHandleRemoteSettingsRemoteSettings(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_remote_settings_fn_free_remotesettings)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleRemoteSettingsRemoteSettings() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kRemoteSettingsRemoteSettingsClientPointerType {
  "remote_settings::RemoteSettingsClient"_ns,
  uniffi_remote_settings_fn_clone_remotesettingsclient,
  uniffi_remote_settings_fn_free_remotesettingsclient,
};
class FfiValueObjectHandleRemoteSettingsRemoteSettingsClient {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleRemoteSettingsRemoteSettingsClient() = default;
  explicit FfiValueObjectHandleRemoteSettingsRemoteSettingsClient(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleRemoteSettingsRemoteSettingsClient(const FfiValueObjectHandleRemoteSettingsRemoteSettingsClient&) = delete;
  FfiValueObjectHandleRemoteSettingsRemoteSettingsClient& operator=(const FfiValueObjectHandleRemoteSettingsRemoteSettingsClient&) = delete;

  FfiValueObjectHandleRemoteSettingsRemoteSettingsClient& operator=(FfiValueObjectHandleRemoteSettingsRemoteSettingsClient&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kRemoteSettingsRemoteSettingsClientPointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  // LowerReceiver is used for method receivers.  For non-trait interfaces, it works exactly the
  // same as `Lower`
  void LowerReciever(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    Lower(aValue, aError);
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kRemoteSettingsRemoteSettingsClientPointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleRemoteSettingsRemoteSettingsClient FromRust(void* aValue) {
    return FfiValueObjectHandleRemoteSettingsRemoteSettingsClient(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_remote_settings_fn_free_remotesettingsclient)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleRemoteSettingsRemoteSettingsClient() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kRemoteSettingsRemoteSettingsServicePointerType {
  "remote_settings::RemoteSettingsService"_ns,
  uniffi_remote_settings_fn_clone_remotesettingsservice,
  uniffi_remote_settings_fn_free_remotesettingsservice,
};
class FfiValueObjectHandleRemoteSettingsRemoteSettingsService {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService() = default;
  explicit FfiValueObjectHandleRemoteSettingsRemoteSettingsService(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService(const FfiValueObjectHandleRemoteSettingsRemoteSettingsService&) = delete;
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService& operator=(const FfiValueObjectHandleRemoteSettingsRemoteSettingsService&) = delete;

  FfiValueObjectHandleRemoteSettingsRemoteSettingsService& operator=(FfiValueObjectHandleRemoteSettingsRemoteSettingsService&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kRemoteSettingsRemoteSettingsServicePointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  // LowerReceiver is used for method receivers.  For non-trait interfaces, it works exactly the
  // same as `Lower`
  void LowerReciever(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    Lower(aValue, aError);
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kRemoteSettingsRemoteSettingsServicePointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleRemoteSettingsRemoteSettingsService FromRust(void* aValue) {
    return FfiValueObjectHandleRemoteSettingsRemoteSettingsService(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_remote_settings_fn_free_remotesettingsservice)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleRemoteSettingsRemoteSettingsService() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kSearchSearchEngineSelectorPointerType {
  "search::SearchEngineSelector"_ns,
  uniffi_search_fn_clone_searchengineselector,
  uniffi_search_fn_free_searchengineselector,
};
class FfiValueObjectHandleSearchSearchEngineSelector {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleSearchSearchEngineSelector() = default;
  explicit FfiValueObjectHandleSearchSearchEngineSelector(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleSearchSearchEngineSelector(const FfiValueObjectHandleSearchSearchEngineSelector&) = delete;
  FfiValueObjectHandleSearchSearchEngineSelector& operator=(const FfiValueObjectHandleSearchSearchEngineSelector&) = delete;

  FfiValueObjectHandleSearchSearchEngineSelector& operator=(FfiValueObjectHandleSearchSearchEngineSelector&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kSearchSearchEngineSelectorPointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  // LowerReceiver is used for method receivers.  For non-trait interfaces, it works exactly the
  // same as `Lower`
  void LowerReciever(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    Lower(aValue, aError);
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kSearchSearchEngineSelectorPointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleSearchSearchEngineSelector FromRust(void* aValue) {
    return FfiValueObjectHandleSearchSearchEngineSelector(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_search_fn_free_searchengineselector)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleSearchSearchEngineSelector() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kSuggestSuggestStorePointerType {
  "suggest::SuggestStore"_ns,
  uniffi_suggest_fn_clone_suggeststore,
  uniffi_suggest_fn_free_suggeststore,
};
class FfiValueObjectHandleSuggestSuggestStore {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleSuggestSuggestStore() = default;
  explicit FfiValueObjectHandleSuggestSuggestStore(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleSuggestSuggestStore(const FfiValueObjectHandleSuggestSuggestStore&) = delete;
  FfiValueObjectHandleSuggestSuggestStore& operator=(const FfiValueObjectHandleSuggestSuggestStore&) = delete;

  FfiValueObjectHandleSuggestSuggestStore& operator=(FfiValueObjectHandleSuggestSuggestStore&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kSuggestSuggestStorePointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  // LowerReceiver is used for method receivers.  For non-trait interfaces, it works exactly the
  // same as `Lower`
  void LowerReciever(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    Lower(aValue, aError);
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kSuggestSuggestStorePointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleSuggestSuggestStore FromRust(void* aValue) {
    return FfiValueObjectHandleSuggestSuggestStore(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_suggest_fn_free_suggeststore)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleSuggestSuggestStore() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kSuggestSuggestStoreBuilderPointerType {
  "suggest::SuggestStoreBuilder"_ns,
  uniffi_suggest_fn_clone_suggeststorebuilder,
  uniffi_suggest_fn_free_suggeststorebuilder,
};
class FfiValueObjectHandleSuggestSuggestStoreBuilder {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleSuggestSuggestStoreBuilder() = default;
  explicit FfiValueObjectHandleSuggestSuggestStoreBuilder(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleSuggestSuggestStoreBuilder(const FfiValueObjectHandleSuggestSuggestStoreBuilder&) = delete;
  FfiValueObjectHandleSuggestSuggestStoreBuilder& operator=(const FfiValueObjectHandleSuggestSuggestStoreBuilder&) = delete;

  FfiValueObjectHandleSuggestSuggestStoreBuilder& operator=(FfiValueObjectHandleSuggestSuggestStoreBuilder&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kSuggestSuggestStoreBuilderPointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  // LowerReceiver is used for method receivers.  For non-trait interfaces, it works exactly the
  // same as `Lower`
  void LowerReciever(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    Lower(aValue, aError);
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kSuggestSuggestStoreBuilderPointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleSuggestSuggestStoreBuilder FromRust(void* aValue) {
    return FfiValueObjectHandleSuggestSuggestStoreBuilder(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_suggest_fn_free_suggeststorebuilder)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleSuggestSuggestStoreBuilder() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kTabsRemoteCommandStorePointerType {
  "tabs::RemoteCommandStore"_ns,
  uniffi_tabs_fn_clone_remotecommandstore,
  uniffi_tabs_fn_free_remotecommandstore,
};
class FfiValueObjectHandleTabsRemoteCommandStore {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleTabsRemoteCommandStore() = default;
  explicit FfiValueObjectHandleTabsRemoteCommandStore(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleTabsRemoteCommandStore(const FfiValueObjectHandleTabsRemoteCommandStore&) = delete;
  FfiValueObjectHandleTabsRemoteCommandStore& operator=(const FfiValueObjectHandleTabsRemoteCommandStore&) = delete;

  FfiValueObjectHandleTabsRemoteCommandStore& operator=(FfiValueObjectHandleTabsRemoteCommandStore&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kTabsRemoteCommandStorePointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  // LowerReceiver is used for method receivers.  For non-trait interfaces, it works exactly the
  // same as `Lower`
  void LowerReciever(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    Lower(aValue, aError);
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kTabsRemoteCommandStorePointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleTabsRemoteCommandStore FromRust(void* aValue) {
    return FfiValueObjectHandleTabsRemoteCommandStore(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_tabs_fn_free_remotecommandstore)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleTabsRemoteCommandStore() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kTabsTabsBridgedEnginePointerType {
  "tabs::TabsBridgedEngine"_ns,
  uniffi_tabs_fn_clone_tabsbridgedengine,
  uniffi_tabs_fn_free_tabsbridgedengine,
};
class FfiValueObjectHandleTabsTabsBridgedEngine {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleTabsTabsBridgedEngine() = default;
  explicit FfiValueObjectHandleTabsTabsBridgedEngine(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleTabsTabsBridgedEngine(const FfiValueObjectHandleTabsTabsBridgedEngine&) = delete;
  FfiValueObjectHandleTabsTabsBridgedEngine& operator=(const FfiValueObjectHandleTabsTabsBridgedEngine&) = delete;

  FfiValueObjectHandleTabsTabsBridgedEngine& operator=(FfiValueObjectHandleTabsTabsBridgedEngine&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kTabsTabsBridgedEnginePointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  // LowerReceiver is used for method receivers.  For non-trait interfaces, it works exactly the
  // same as `Lower`
  void LowerReciever(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    Lower(aValue, aError);
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kTabsTabsBridgedEnginePointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleTabsTabsBridgedEngine FromRust(void* aValue) {
    return FfiValueObjectHandleTabsTabsBridgedEngine(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_tabs_fn_free_tabsbridgedengine)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleTabsTabsBridgedEngine() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kTabsTabsStorePointerType {
  "tabs::TabsStore"_ns,
  uniffi_tabs_fn_clone_tabsstore,
  uniffi_tabs_fn_free_tabsstore,
};
class FfiValueObjectHandleTabsTabsStore {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleTabsTabsStore() = default;
  explicit FfiValueObjectHandleTabsTabsStore(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleTabsTabsStore(const FfiValueObjectHandleTabsTabsStore&) = delete;
  FfiValueObjectHandleTabsTabsStore& operator=(const FfiValueObjectHandleTabsTabsStore&) = delete;

  FfiValueObjectHandleTabsTabsStore& operator=(FfiValueObjectHandleTabsTabsStore&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kTabsTabsStorePointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  // LowerReceiver is used for method receivers.  For non-trait interfaces, it works exactly the
  // same as `Lower`
  void LowerReciever(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    Lower(aValue, aError);
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kTabsTabsStorePointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleTabsTabsStore FromRust(void* aValue) {
    return FfiValueObjectHandleTabsTabsStore(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_tabs_fn_free_tabsstore)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleTabsTabsStore() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kWebextstorageWebExtStorageBridgedEnginePointerType {
  "webextstorage::WebExtStorageBridgedEngine"_ns,
  uniffi_webext_storage_fn_clone_webextstoragebridgedengine,
  uniffi_webext_storage_fn_free_webextstoragebridgedengine,
};
class FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine() = default;
  explicit FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine(const FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine&) = delete;
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine& operator=(const FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine&) = delete;

  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine& operator=(FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kWebextstorageWebExtStorageBridgedEnginePointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  // LowerReceiver is used for method receivers.  For non-trait interfaces, it works exactly the
  // same as `Lower`
  void LowerReciever(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    Lower(aValue, aError);
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kWebextstorageWebExtStorageBridgedEnginePointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine FromRust(void* aValue) {
    return FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_webext_storage_fn_free_webextstoragebridgedengine)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kWebextstorageWebExtStorageStorePointerType {
  "webextstorage::WebExtStorageStore"_ns,
  uniffi_webext_storage_fn_clone_webextstoragestore,
  uniffi_webext_storage_fn_free_webextstoragestore,
};
class FfiValueObjectHandleWebextstorageWebExtStorageStore {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleWebextstorageWebExtStorageStore() = default;
  explicit FfiValueObjectHandleWebextstorageWebExtStorageStore(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleWebextstorageWebExtStorageStore(const FfiValueObjectHandleWebextstorageWebExtStorageStore&) = delete;
  FfiValueObjectHandleWebextstorageWebExtStorageStore& operator=(const FfiValueObjectHandleWebextstorageWebExtStorageStore&) = delete;

  FfiValueObjectHandleWebextstorageWebExtStorageStore& operator=(FfiValueObjectHandleWebextstorageWebExtStorageStore&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kWebextstorageWebExtStorageStorePointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  // LowerReceiver is used for method receivers.  For non-trait interfaces, it works exactly the
  // same as `Lower`
  void LowerReciever(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    Lower(aValue, aError);
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kWebextstorageWebExtStorageStorePointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleWebextstorageWebExtStorageStore FromRust(void* aValue) {
    return FfiValueObjectHandleWebextstorageWebExtStorageStore(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_webext_storage_fn_free_webextstoragestore)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleWebextstorageWebExtStorageStore() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};

#ifdef MOZ_UNIFFI_FIXTURES
const static mozilla::uniffi::UniFFIPointerType kUniffiBindingsTestsTestInterfacePointerType {
  "uniffi_bindings_tests::TestInterface"_ns,
  uniffi_uniffi_bindings_tests_fn_clone_testinterface,
  uniffi_uniffi_bindings_tests_fn_free_testinterface,
};
class FfiValueObjectHandleUniffiBindingsTestsTestInterface {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleUniffiBindingsTestsTestInterface() = default;
  explicit FfiValueObjectHandleUniffiBindingsTestsTestInterface(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleUniffiBindingsTestsTestInterface(const FfiValueObjectHandleUniffiBindingsTestsTestInterface&) = delete;
  FfiValueObjectHandleUniffiBindingsTestsTestInterface& operator=(const FfiValueObjectHandleUniffiBindingsTestsTestInterface&) = delete;

  FfiValueObjectHandleUniffiBindingsTestsTestInterface& operator=(FfiValueObjectHandleUniffiBindingsTestsTestInterface&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kUniffiBindingsTestsTestInterfacePointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  // LowerReceiver is used for method receivers.  For non-trait interfaces, it works exactly the
  // same as `Lower`
  void LowerReciever(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    Lower(aValue, aError);
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kUniffiBindingsTestsTestInterfacePointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleUniffiBindingsTestsTestInterface FromRust(void* aValue) {
    return FfiValueObjectHandleUniffiBindingsTestsTestInterface(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_uniffi_bindings_tests_fn_free_testinterface)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleUniffiBindingsTestsTestInterface() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kUniffiBindingsTestsAsyncInterfacePointerType {
  "uniffi_bindings_tests::AsyncInterface"_ns,
  uniffi_uniffi_bindings_tests_fn_clone_asyncinterface,
  uniffi_uniffi_bindings_tests_fn_free_asyncinterface,
};
class FfiValueObjectHandleUniffiBindingsTestsAsyncInterface {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleUniffiBindingsTestsAsyncInterface() = default;
  explicit FfiValueObjectHandleUniffiBindingsTestsAsyncInterface(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleUniffiBindingsTestsAsyncInterface(const FfiValueObjectHandleUniffiBindingsTestsAsyncInterface&) = delete;
  FfiValueObjectHandleUniffiBindingsTestsAsyncInterface& operator=(const FfiValueObjectHandleUniffiBindingsTestsAsyncInterface&) = delete;

  FfiValueObjectHandleUniffiBindingsTestsAsyncInterface& operator=(FfiValueObjectHandleUniffiBindingsTestsAsyncInterface&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kUniffiBindingsTestsAsyncInterfacePointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  // LowerReceiver is used for method receivers.  For non-trait interfaces, it works exactly the
  // same as `Lower`
  void LowerReciever(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    Lower(aValue, aError);
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kUniffiBindingsTestsAsyncInterfacePointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleUniffiBindingsTestsAsyncInterface FromRust(void* aValue) {
    return FfiValueObjectHandleUniffiBindingsTestsAsyncInterface(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_uniffi_bindings_tests_fn_free_asyncinterface)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleUniffiBindingsTestsAsyncInterface() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kUniffiBindingsTestsAsyncTestTraitInterfacePointerType {
  "uniffi_bindings_tests::AsyncTestTraitInterface"_ns,
  uniffi_uniffi_bindings_tests_fn_clone_asynctesttraitinterface,
  uniffi_uniffi_bindings_tests_fn_free_asynctesttraitinterface,
};
// Forward declare the free function, which is defined later on in `CallbackInterfaces.cpp`
extern "C" void callback_free_uniffi_bindings_tests_async_test_trait_interface(uint64_t uniffiHandle);

// Trait interface FFI value class.  This is a hybrid between the one for interfaces and callback
// interface version
class FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface {
 private:
  // Did we lower a callback interface, rather than lift an object interface?
  // This is weird, but it's a needed work until something like
  // https://github.com/mozilla/uniffi-rs/pull/1823 lands.
  bool mLoweredCallbackInterface = false;
  // The raw FFI value is a pointer.
  // For callback interfaces, the uint64_t handle gets casted to a pointer.  Callback interface
  // handles are incremented by one at a time, so even on a 32-bit system this
  // shouldn't overflow.
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface() = default;
  explicit FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface(const FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface&) = delete;
  FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface& operator=(const FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface&) = delete;

  FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface& operator=(FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    mLoweredCallbackInterface = aOther.mLoweredCallbackInterface;
    aOther.mValue = nullptr;
    aOther.mLoweredCallbackInterface = false;
    return *this;
  }

  // Lower treats `aValue` as a callback interface
  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsDouble()) {
      aError.ThrowTypeError("Bad argument type"_ns);
      return;
    }
    double floatValue = aValue.GetAsDouble();
    uint64_t intValue = static_cast<uint64_t>(floatValue);
    if (intValue != floatValue) {
      aError.ThrowTypeError("Not an integer"_ns);
      return;
    }
    FreeHandle();
    mValue = reinterpret_cast<void *>(intValue);
    mLoweredCallbackInterface = true;
  }

  // LowerReceiver is used for method receivers.  It treats `aValue` as an object pointer.
  void LowerReciever(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kUniffiBindingsTestsAsyncTestTraitInterfacePointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
    mLoweredCallbackInterface = false;
  }

  // Lift treats `aDest` as a regular interface
  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kUniffiBindingsTestsAsyncTestTraitInterfacePointerType);
    mValue = nullptr;
    mLoweredCallbackInterface = false;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    mLoweredCallbackInterface = false;
    return temp;
  }

  static FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface FromRust(void* aValue) {
    return FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface(aValue);
  }

  void FreeHandle() {
    // This behavior depends on if we lowered a callback interface handle or lifted an interface
    // pointer.
    if (mLoweredCallbackInterface && reinterpret_cast<uintptr_t>(mValue) != 0) {
                                     printf("FREEING CB %p\n", mValue);
        callback_free_uniffi_bindings_tests_async_test_trait_interface(reinterpret_cast<uintptr_t>(mValue));
        mValue = reinterpret_cast<void *>(0);
    } else if (!mLoweredCallbackInterface && mValue != nullptr) {
                                     printf("FREEING interface %p\n", mValue);
      RustCallStatus callStatus{};
      (uniffi_uniffi_bindings_tests_fn_free_asynctesttraitinterface)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
    mValue = nullptr;
    mLoweredCallbackInterface = false;
  }

  ~FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kUniffiBindingsTestsComplexMethodsPointerType {
  "uniffi_bindings_tests::ComplexMethods"_ns,
  uniffi_uniffi_bindings_tests_fn_clone_complexmethods,
  uniffi_uniffi_bindings_tests_fn_free_complexmethods,
};
class FfiValueObjectHandleUniffiBindingsTestsComplexMethods {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleUniffiBindingsTestsComplexMethods() = default;
  explicit FfiValueObjectHandleUniffiBindingsTestsComplexMethods(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleUniffiBindingsTestsComplexMethods(const FfiValueObjectHandleUniffiBindingsTestsComplexMethods&) = delete;
  FfiValueObjectHandleUniffiBindingsTestsComplexMethods& operator=(const FfiValueObjectHandleUniffiBindingsTestsComplexMethods&) = delete;

  FfiValueObjectHandleUniffiBindingsTestsComplexMethods& operator=(FfiValueObjectHandleUniffiBindingsTestsComplexMethods&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kUniffiBindingsTestsComplexMethodsPointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  // LowerReceiver is used for method receivers.  For non-trait interfaces, it works exactly the
  // same as `Lower`
  void LowerReciever(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    Lower(aValue, aError);
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kUniffiBindingsTestsComplexMethodsPointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleUniffiBindingsTestsComplexMethods FromRust(void* aValue) {
    return FfiValueObjectHandleUniffiBindingsTestsComplexMethods(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_uniffi_bindings_tests_fn_free_complexmethods)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleUniffiBindingsTestsComplexMethods() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kUniffiBindingsTestsTestTraitInterfacePointerType {
  "uniffi_bindings_tests::TestTraitInterface"_ns,
  uniffi_uniffi_bindings_tests_fn_clone_testtraitinterface,
  uniffi_uniffi_bindings_tests_fn_free_testtraitinterface,
};
// Forward declare the free function, which is defined later on in `CallbackInterfaces.cpp`
extern "C" void callback_free_uniffi_bindings_tests_test_trait_interface(uint64_t uniffiHandle);

// Trait interface FFI value class.  This is a hybrid between the one for interfaces and callback
// interface version
class FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface {
 private:
  // Did we lower a callback interface, rather than lift an object interface?
  // This is weird, but it's a needed work until something like
  // https://github.com/mozilla/uniffi-rs/pull/1823 lands.
  bool mLoweredCallbackInterface = false;
  // The raw FFI value is a pointer.
  // For callback interfaces, the uint64_t handle gets casted to a pointer.  Callback interface
  // handles are incremented by one at a time, so even on a 32-bit system this
  // shouldn't overflow.
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface() = default;
  explicit FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface(const FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface&) = delete;
  FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface& operator=(const FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface&) = delete;

  FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface& operator=(FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    mLoweredCallbackInterface = aOther.mLoweredCallbackInterface;
    aOther.mValue = nullptr;
    aOther.mLoweredCallbackInterface = false;
    return *this;
  }

  // Lower treats `aValue` as a callback interface
  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsDouble()) {
      aError.ThrowTypeError("Bad argument type"_ns);
      return;
    }
    double floatValue = aValue.GetAsDouble();
    uint64_t intValue = static_cast<uint64_t>(floatValue);
    if (intValue != floatValue) {
      aError.ThrowTypeError("Not an integer"_ns);
      return;
    }
    FreeHandle();
    mValue = reinterpret_cast<void *>(intValue);
    mLoweredCallbackInterface = true;
  }

  // LowerReceiver is used for method receivers.  It treats `aValue` as an object pointer.
  void LowerReciever(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kUniffiBindingsTestsTestTraitInterfacePointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
    mLoweredCallbackInterface = false;
  }

  // Lift treats `aDest` as a regular interface
  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kUniffiBindingsTestsTestTraitInterfacePointerType);
    mValue = nullptr;
    mLoweredCallbackInterface = false;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    mLoweredCallbackInterface = false;
    return temp;
  }

  static FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface FromRust(void* aValue) {
    return FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface(aValue);
  }

  void FreeHandle() {
    // This behavior depends on if we lowered a callback interface handle or lifted an interface
    // pointer.
    if (mLoweredCallbackInterface && reinterpret_cast<uintptr_t>(mValue) != 0) {
                                     printf("FREEING CB %p\n", mValue);
        callback_free_uniffi_bindings_tests_test_trait_interface(reinterpret_cast<uintptr_t>(mValue));
        mValue = reinterpret_cast<void *>(0);
    } else if (!mLoweredCallbackInterface && mValue != nullptr) {
                                     printf("FREEING interface %p\n", mValue);
      RustCallStatus callStatus{};
      (uniffi_uniffi_bindings_tests_fn_free_testtraitinterface)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
    mValue = nullptr;
    mLoweredCallbackInterface = false;
  }

  ~FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
#endif /* MOZ_UNIFFI_FIXTURES */

Maybe<already_AddRefed<UniFFIPointer>> ReadPointer(const GlobalObject& aGlobal, uint64_t aId, const ArrayBuffer& aArrayBuff, long aPosition, ErrorResult& aError) {
  const UniFFIPointerType* type;
  switch (aId) {

    case 1: {
      type = &kContextIdContextIdComponentPointerType;
      break;
    }
    case 2: {
      type = &kRelevancyRelevancyStorePointerType;
      break;
    }
    case 3: {
      type = &kRemoteSettingsRemoteSettingsPointerType;
      break;
    }
    case 4: {
      type = &kRemoteSettingsRemoteSettingsClientPointerType;
      break;
    }
    case 5: {
      type = &kRemoteSettingsRemoteSettingsServicePointerType;
      break;
    }
    case 6: {
      type = &kSearchSearchEngineSelectorPointerType;
      break;
    }
    case 7: {
      type = &kSuggestSuggestStorePointerType;
      break;
    }
    case 8: {
      type = &kSuggestSuggestStoreBuilderPointerType;
      break;
    }
    case 9: {
      type = &kTabsRemoteCommandStorePointerType;
      break;
    }
    case 10: {
      type = &kTabsTabsBridgedEnginePointerType;
      break;
    }
    case 11: {
      type = &kTabsTabsStorePointerType;
      break;
    }
    case 12: {
      type = &kWebextstorageWebExtStorageBridgedEnginePointerType;
      break;
    }
    case 13: {
      type = &kWebextstorageWebExtStorageStorePointerType;
      break;
    }

#ifdef MOZ_UNIFFI_FIXTURES
    case 14: {
      type = &kUniffiBindingsTestsTestInterfacePointerType;
      break;
    }
    case 15: {
      type = &kUniffiBindingsTestsAsyncInterfacePointerType;
      break;
    }
    case 16: {
      type = &kUniffiBindingsTestsAsyncTestTraitInterfacePointerType;
      break;
    }
    case 17: {
      type = &kUniffiBindingsTestsComplexMethodsPointerType;
      break;
    }
    case 18: {
      type = &kUniffiBindingsTestsTestTraitInterfacePointerType;
      break;
    }
#endif /* MOZ_UNIFFI_FIXTURES */
    default:
      return Nothing();
  }
  return Some(UniFFIPointer::Read(aArrayBuff, aPosition, type, aError));
}

bool WritePointer(const GlobalObject& aGlobal, uint64_t aId, const UniFFIPointer& aPtr, const ArrayBuffer& aArrayBuff, long aPosition, ErrorResult& aError) {
  const UniFFIPointerType* type;
  switch (aId) {

    case 1: {
      type = &kContextIdContextIdComponentPointerType;
      break;
    }
    case 2: {
      type = &kRelevancyRelevancyStorePointerType;
      break;
    }
    case 3: {
      type = &kRemoteSettingsRemoteSettingsPointerType;
      break;
    }
    case 4: {
      type = &kRemoteSettingsRemoteSettingsClientPointerType;
      break;
    }
    case 5: {
      type = &kRemoteSettingsRemoteSettingsServicePointerType;
      break;
    }
    case 6: {
      type = &kSearchSearchEngineSelectorPointerType;
      break;
    }
    case 7: {
      type = &kSuggestSuggestStorePointerType;
      break;
    }
    case 8: {
      type = &kSuggestSuggestStoreBuilderPointerType;
      break;
    }
    case 9: {
      type = &kTabsRemoteCommandStorePointerType;
      break;
    }
    case 10: {
      type = &kTabsTabsBridgedEnginePointerType;
      break;
    }
    case 11: {
      type = &kTabsTabsStorePointerType;
      break;
    }
    case 12: {
      type = &kWebextstorageWebExtStorageBridgedEnginePointerType;
      break;
    }
    case 13: {
      type = &kWebextstorageWebExtStorageStorePointerType;
      break;
    }

#ifdef MOZ_UNIFFI_FIXTURES
    case 14: {
      type = &kUniffiBindingsTestsTestInterfacePointerType;
      break;
    }
    case 15: {
      type = &kUniffiBindingsTestsAsyncInterfacePointerType;
      break;
    }
    case 16: {
      type = &kUniffiBindingsTestsAsyncTestTraitInterfacePointerType;
      break;
    }
    case 17: {
      type = &kUniffiBindingsTestsComplexMethodsPointerType;
      break;
    }
    case 18: {
      type = &kUniffiBindingsTestsTestTraitInterfacePointerType;
      break;
    }
#endif /* MOZ_UNIFFI_FIXTURES */
    default:
      return false;
  }
  aPtr.Write(aArrayBuff, aPosition, type, aError);
  return true;
}
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */


// Callback interface FfiValueClasses
//
// These need to come first so they're defined for the scaffolding call code


// Forward declare the free function, which is defined later on in `CallbackInterfaces.cpp`
extern "C" void callback_free_context_id_context_id_callback(uint64_t uniffiHandle);

// FfiValue class for these callback interface handles.  This works like the
// `FfiValueInt<uint64_t>`, except it has extra code to cleanup the callback handles.
class FfiValueCallbackInterfacecontext_id_ContextIdCallback {
 private:
  // Was this value lowered?  If so, that means we own the handle and are responsible for cleaning
  // it up if we don't pass it to Rust because other values failed to lower
  bool mLowered = false;
  uint64_t mValue = 0;

 public:
  FfiValueCallbackInterfacecontext_id_ContextIdCallback() = default;
  explicit FfiValueCallbackInterfacecontext_id_ContextIdCallback(uint64_t aValue) : mValue(aValue) {}

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsDouble()) {
      aError.ThrowTypeError("Bad argument type"_ns);
      return;
    }
    double floatValue = aValue.GetAsDouble();

    uint64_t intValue = static_cast<uint64_t>(floatValue);
    if (intValue != floatValue) {
      aError.ThrowTypeError("Not an integer"_ns);
      return;
    }
    ReleaseHandleIfSet();
    mValue = intValue;
    mLowered = true;
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsDouble() = mValue;
    mValue = 0;
    mLowered = false;
  }

  uint64_t IntoRust() {
    auto handle = mValue;
    mValue = 0;
    mLowered = false;
    return handle;
  }

  static FfiValueCallbackInterfacecontext_id_ContextIdCallback FromRust(uint64_t aValue) { return FfiValueCallbackInterfacecontext_id_ContextIdCallback(aValue); };

  void ReleaseHandleIfSet() {
    // A non-zero value indicates that we own a callback handle that was never passed to Rust or
    // lifted to JS and needs to be freed.
    if (mValue != 0 && mLowered) {
        callback_free_context_id_context_id_callback(mValue);
        mValue = 0;
        mLowered = false;
    }
  }

  ~FfiValueCallbackInterfacecontext_id_ContextIdCallback() {
    ReleaseHandleIfSet();
  }
};

// Forward declare the free function, which is defined later on in `CallbackInterfaces.cpp`
extern "C" void callback_free_errorsupport_application_error_reporter(uint64_t uniffiHandle);

// FfiValue class for these callback interface handles.  This works like the
// `FfiValueInt<uint64_t>`, except it has extra code to cleanup the callback handles.
class FfiValueCallbackInterfaceerrorsupport_ApplicationErrorReporter {
 private:
  // Was this value lowered?  If so, that means we own the handle and are responsible for cleaning
  // it up if we don't pass it to Rust because other values failed to lower
  bool mLowered = false;
  uint64_t mValue = 0;

 public:
  FfiValueCallbackInterfaceerrorsupport_ApplicationErrorReporter() = default;
  explicit FfiValueCallbackInterfaceerrorsupport_ApplicationErrorReporter(uint64_t aValue) : mValue(aValue) {}

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsDouble()) {
      aError.ThrowTypeError("Bad argument type"_ns);
      return;
    }
    double floatValue = aValue.GetAsDouble();

    uint64_t intValue = static_cast<uint64_t>(floatValue);
    if (intValue != floatValue) {
      aError.ThrowTypeError("Not an integer"_ns);
      return;
    }
    ReleaseHandleIfSet();
    mValue = intValue;
    mLowered = true;
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsDouble() = mValue;
    mValue = 0;
    mLowered = false;
  }

  uint64_t IntoRust() {
    auto handle = mValue;
    mValue = 0;
    mLowered = false;
    return handle;
  }

  static FfiValueCallbackInterfaceerrorsupport_ApplicationErrorReporter FromRust(uint64_t aValue) { return FfiValueCallbackInterfaceerrorsupport_ApplicationErrorReporter(aValue); };

  void ReleaseHandleIfSet() {
    // A non-zero value indicates that we own a callback handle that was never passed to Rust or
    // lifted to JS and needs to be freed.
    if (mValue != 0 && mLowered) {
        callback_free_errorsupport_application_error_reporter(mValue);
        mValue = 0;
        mLowered = false;
    }
  }

  ~FfiValueCallbackInterfaceerrorsupport_ApplicationErrorReporter() {
    ReleaseHandleIfSet();
  }
};

#ifdef MOZ_UNIFFI_FIXTURES

// Forward declare the free function, which is defined later on in `CallbackInterfaces.cpp`
extern "C" void callback_free_uniffi_bindings_tests_test_async_callback_interface(uint64_t uniffiHandle);

// FfiValue class for these callback interface handles.  This works like the
// `FfiValueInt<uint64_t>`, except it has extra code to cleanup the callback handles.
class FfiValueCallbackInterfaceuniffi_bindings_tests_TestAsyncCallbackInterface {
 private:
  // Was this value lowered?  If so, that means we own the handle and are responsible for cleaning
  // it up if we don't pass it to Rust because other values failed to lower
  bool mLowered = false;
  uint64_t mValue = 0;

 public:
  FfiValueCallbackInterfaceuniffi_bindings_tests_TestAsyncCallbackInterface() = default;
  explicit FfiValueCallbackInterfaceuniffi_bindings_tests_TestAsyncCallbackInterface(uint64_t aValue) : mValue(aValue) {}

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsDouble()) {
      aError.ThrowTypeError("Bad argument type"_ns);
      return;
    }
    double floatValue = aValue.GetAsDouble();

    uint64_t intValue = static_cast<uint64_t>(floatValue);
    if (intValue != floatValue) {
      aError.ThrowTypeError("Not an integer"_ns);
      return;
    }
    ReleaseHandleIfSet();
    mValue = intValue;
    mLowered = true;
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsDouble() = mValue;
    mValue = 0;
    mLowered = false;
  }

  uint64_t IntoRust() {
    auto handle = mValue;
    mValue = 0;
    mLowered = false;
    return handle;
  }

  static FfiValueCallbackInterfaceuniffi_bindings_tests_TestAsyncCallbackInterface FromRust(uint64_t aValue) { return FfiValueCallbackInterfaceuniffi_bindings_tests_TestAsyncCallbackInterface(aValue); };

  void ReleaseHandleIfSet() {
    // A non-zero value indicates that we own a callback handle that was never passed to Rust or
    // lifted to JS and needs to be freed.
    if (mValue != 0 && mLowered) {
        callback_free_uniffi_bindings_tests_test_async_callback_interface(mValue);
        mValue = 0;
        mLowered = false;
    }
  }

  ~FfiValueCallbackInterfaceuniffi_bindings_tests_TestAsyncCallbackInterface() {
    ReleaseHandleIfSet();
  }
};

// Forward declare the free function, which is defined later on in `CallbackInterfaces.cpp`
extern "C" void callback_free_uniffi_bindings_tests_test_callback_interface(uint64_t uniffiHandle);

// FfiValue class for these callback interface handles.  This works like the
// `FfiValueInt<uint64_t>`, except it has extra code to cleanup the callback handles.
class FfiValueCallbackInterfaceuniffi_bindings_tests_TestCallbackInterface {
 private:
  // Was this value lowered?  If so, that means we own the handle and are responsible for cleaning
  // it up if we don't pass it to Rust because other values failed to lower
  bool mLowered = false;
  uint64_t mValue = 0;

 public:
  FfiValueCallbackInterfaceuniffi_bindings_tests_TestCallbackInterface() = default;
  explicit FfiValueCallbackInterfaceuniffi_bindings_tests_TestCallbackInterface(uint64_t aValue) : mValue(aValue) {}

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsDouble()) {
      aError.ThrowTypeError("Bad argument type"_ns);
      return;
    }
    double floatValue = aValue.GetAsDouble();

    uint64_t intValue = static_cast<uint64_t>(floatValue);
    if (intValue != floatValue) {
      aError.ThrowTypeError("Not an integer"_ns);
      return;
    }
    ReleaseHandleIfSet();
    mValue = intValue;
    mLowered = true;
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsDouble() = mValue;
    mValue = 0;
    mLowered = false;
  }

  uint64_t IntoRust() {
    auto handle = mValue;
    mValue = 0;
    mLowered = false;
    return handle;
  }

  static FfiValueCallbackInterfaceuniffi_bindings_tests_TestCallbackInterface FromRust(uint64_t aValue) { return FfiValueCallbackInterfaceuniffi_bindings_tests_TestCallbackInterface(aValue); };

  void ReleaseHandleIfSet() {
    // A non-zero value indicates that we own a callback handle that was never passed to Rust or
    // lifted to JS and needs to be freed.
    if (mValue != 0 && mLowered) {
        callback_free_uniffi_bindings_tests_test_callback_interface(mValue);
        mValue = 0;
        mLowered = false;
    }
  }

  ~FfiValueCallbackInterfaceuniffi_bindings_tests_TestCallbackInterface() {
    ReleaseHandleIfSet();
  }
};

// Forward declare the free function, which is defined later on in `CallbackInterfaces.cpp`
extern "C" void callback_free_uniffi_bindings_tests_collision_test_callback_interface(uint64_t uniffiHandle);

// FfiValue class for these callback interface handles.  This works like the
// `FfiValueInt<uint64_t>`, except it has extra code to cleanup the callback handles.
class FfiValueCallbackInterfaceuniffi_bindings_tests_collision_TestCallbackInterface {
 private:
  // Was this value lowered?  If so, that means we own the handle and are responsible for cleaning
  // it up if we don't pass it to Rust because other values failed to lower
  bool mLowered = false;
  uint64_t mValue = 0;

 public:
  FfiValueCallbackInterfaceuniffi_bindings_tests_collision_TestCallbackInterface() = default;
  explicit FfiValueCallbackInterfaceuniffi_bindings_tests_collision_TestCallbackInterface(uint64_t aValue) : mValue(aValue) {}

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsDouble()) {
      aError.ThrowTypeError("Bad argument type"_ns);
      return;
    }
    double floatValue = aValue.GetAsDouble();

    uint64_t intValue = static_cast<uint64_t>(floatValue);
    if (intValue != floatValue) {
      aError.ThrowTypeError("Not an integer"_ns);
      return;
    }
    ReleaseHandleIfSet();
    mValue = intValue;
    mLowered = true;
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsDouble() = mValue;
    mValue = 0;
    mLowered = false;
  }

  uint64_t IntoRust() {
    auto handle = mValue;
    mValue = 0;
    mLowered = false;
    return handle;
  }

  static FfiValueCallbackInterfaceuniffi_bindings_tests_collision_TestCallbackInterface FromRust(uint64_t aValue) { return FfiValueCallbackInterfaceuniffi_bindings_tests_collision_TestCallbackInterface(aValue); };

  void ReleaseHandleIfSet() {
    // A non-zero value indicates that we own a callback handle that was never passed to Rust or
    // lifted to JS and needs to be freed.
    if (mValue != 0 && mLowered) {
        callback_free_uniffi_bindings_tests_collision_test_callback_interface(mValue);
        mValue = 0;
        mLowered = false;
    }
  }

  ~FfiValueCallbackInterfaceuniffi_bindings_tests_collision_TestCallbackInterface() {
    ReleaseHandleIfSet();
  }
};
#endif /* MOZ_UNIFFI_FIXTURES */
/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set ts=8 sts=2 et sw=2 tw=80: */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

// Define scaffolding call classes for each combination of return/argument types

class ScaffoldingCallHandlerUniffiContextIdFnConstructorContextidcomponentNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mInitContextId{};
  FfiValueInt<int64_t> mCreationTimestampS{};
  FfiValueInt<int8_t> mRunningInTestAutomation{};
  FfiValueCallbackInterfacecontext_id_ContextIdCallback mCallback{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleContextIdContextIdComponent mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mInitContextId.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mCreationTimestampS.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mRunningInTestAutomation.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
    mCallback.Lower(aArgs[3], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleContextIdContextIdComponent::FromRust(
      uniffi_context_id_fn_constructor_contextidcomponent_new(
        mInitContextId.IntoRust(),
        mCreationTimestampS.IntoRust(),
        mRunningInTestAutomation.IntoRust(),
        mCallback.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiContextIdFnMethodContextidcomponentForceRotation : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleContextIdContextIdComponent mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_context_id_fn_method_contextidcomponent_force_rotation(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiContextIdFnMethodContextidcomponentRequest : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleContextIdContextIdComponent mUniffiPtr{};
  FfiValueInt<uint8_t> mRotationDaysInS{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mRotationDaysInS.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_context_id_fn_method_contextidcomponent_request(
        mUniffiPtr.IntoRust(),
        mRotationDaysInS.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiContextIdFnMethodContextidcomponentUnsetCallback : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleContextIdContextIdComponent mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_context_id_fn_method_contextidcomponent_unset_callback(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiErrorSupportFnFuncSetApplicationErrorReporter : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueCallbackInterfaceerrorsupport_ApplicationErrorReporter mErrorReporter{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mErrorReporter.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_error_support_fn_func_set_application_error_reporter(
      mErrorReporter.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiErrorSupportFnFuncUnsetApplicationErrorReporter : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_error_support_fn_func_unset_application_error_reporter(
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnFuncScore : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mInterestVector{};
  FfiValueRustBuffer mContentCategories{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueFloat<double> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mInterestVector.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mContentCategories.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueFloat<double>::FromRust(
      uniffi_relevancy_fn_func_score(
        mInterestVector.IntoRust(),
        mContentCategories.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnConstructorRelevancystoreNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mDbPath{};
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService mRemoteSettings{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleRelevancyRelevancyStore mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mDbPath.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mRemoteSettings.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleRelevancyRelevancyStore::FromRust(
      uniffi_relevancy_fn_constructor_relevancystore_new(
        mDbPath.IntoRust(),
        mRemoteSettings.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreBanditInit : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRelevancyRelevancyStore mUniffiPtr{};
  FfiValueRustBuffer mBandit{};
  FfiValueRustBuffer mArms{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mBandit.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mArms.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_relevancy_fn_method_relevancystore_bandit_init(
      mUniffiPtr.IntoRust(),
      mBandit.IntoRust(),
      mArms.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreBanditSelect : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRelevancyRelevancyStore mUniffiPtr{};
  FfiValueRustBuffer mBandit{};
  FfiValueRustBuffer mArms{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mBandit.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mArms.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_relevancy_fn_method_relevancystore_bandit_select(
        mUniffiPtr.IntoRust(),
        mBandit.IntoRust(),
        mArms.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreBanditUpdate : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRelevancyRelevancyStore mUniffiPtr{};
  FfiValueRustBuffer mBandit{};
  FfiValueRustBuffer mArm{};
  FfiValueInt<int8_t> mSelected{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mBandit.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mArm.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
    mSelected.Lower(aArgs[3], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_relevancy_fn_method_relevancystore_bandit_update(
      mUniffiPtr.IntoRust(),
      mBandit.IntoRust(),
      mArm.IntoRust(),
      mSelected.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreClose : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRelevancyRelevancyStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_relevancy_fn_method_relevancystore_close(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreEnsureInterestDataPopulated : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRelevancyRelevancyStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_relevancy_fn_method_relevancystore_ensure_interest_data_populated(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreGetBanditData : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRelevancyRelevancyStore mUniffiPtr{};
  FfiValueRustBuffer mBandit{};
  FfiValueRustBuffer mArm{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mBandit.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mArm.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_relevancy_fn_method_relevancystore_get_bandit_data(
        mUniffiPtr.IntoRust(),
        mBandit.IntoRust(),
        mArm.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreIngest : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRelevancyRelevancyStore mUniffiPtr{};
  FfiValueRustBuffer mTopUrlsByFrecency{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mTopUrlsByFrecency.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_relevancy_fn_method_relevancystore_ingest(
        mUniffiPtr.IntoRust(),
        mTopUrlsByFrecency.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreInterrupt : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRelevancyRelevancyStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_relevancy_fn_method_relevancystore_interrupt(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreUserInterestVector : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRelevancyRelevancyStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_relevancy_fn_method_relevancystore_user_interest_vector(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnConstructorRemotesettingsNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mRemoteSettingsConfig{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettings mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mRemoteSettingsConfig.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleRemoteSettingsRemoteSettings::FromRust(
      uniffi_remote_settings_fn_constructor_remotesettings_new(
        mRemoteSettingsConfig.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsDownloadAttachmentToPath : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettings mUniffiPtr{};
  FfiValueRustBuffer mAttachmentId{};
  FfiValueRustBuffer mPath{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mAttachmentId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mPath.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_remote_settings_fn_method_remotesettings_download_attachment_to_path(
      mUniffiPtr.IntoRust(),
      mAttachmentId.IntoRust(),
      mPath.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsGetRecords : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettings mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_remote_settings_fn_method_remotesettings_get_records(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsGetRecordsSince : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettings mUniffiPtr{};
  FfiValueInt<uint64_t> mTimestamp{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mTimestamp.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_remote_settings_fn_method_remotesettings_get_records_since(
        mUniffiPtr.IntoRust(),
        mTimestamp.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientCollectionName : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsClient mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_remote_settings_fn_method_remotesettingsclient_collection_name(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientGetAttachment : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsClient mUniffiPtr{};
  FfiValueRustBuffer mRecord{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mRecord.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_remote_settings_fn_method_remotesettingsclient_get_attachment(
        mUniffiPtr.IntoRust(),
        mRecord.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientGetRecords : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsClient mUniffiPtr{};
  FfiValueInt<int8_t> mSyncIfEmpty{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mSyncIfEmpty.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_remote_settings_fn_method_remotesettingsclient_get_records(
        mUniffiPtr.IntoRust(),
        mSyncIfEmpty.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientGetRecordsMap : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsClient mUniffiPtr{};
  FfiValueInt<int8_t> mSyncIfEmpty{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mSyncIfEmpty.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_remote_settings_fn_method_remotesettingsclient_get_records_map(
        mUniffiPtr.IntoRust(),
        mSyncIfEmpty.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientShutdown : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsClient mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_remote_settings_fn_method_remotesettingsclient_shutdown(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientSync : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsClient mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_remote_settings_fn_method_remotesettingsclient_sync(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnConstructorRemotesettingsserviceNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mStorageDir{};
  FfiValueRustBuffer mConfig{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mStorageDir.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mConfig.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleRemoteSettingsRemoteSettingsService::FromRust(
      uniffi_remote_settings_fn_constructor_remotesettingsservice_new(
        mStorageDir.IntoRust(),
        mConfig.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsserviceMakeClient : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService mUniffiPtr{};
  FfiValueRustBuffer mCollectionName{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsClient mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mCollectionName.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleRemoteSettingsRemoteSettingsClient::FromRust(
      uniffi_remote_settings_fn_method_remotesettingsservice_make_client(
        mUniffiPtr.IntoRust(),
        mCollectionName.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsserviceSync : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_remote_settings_fn_method_remotesettingsservice_sync(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsserviceUpdateConfig : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService mUniffiPtr{};
  FfiValueRustBuffer mConfig{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mConfig.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_remote_settings_fn_method_remotesettingsservice_update_config(
      mUniffiPtr.IntoRust(),
      mConfig.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiSearchFnConstructorSearchengineselectorNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleSearchSearchEngineSelector mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleSearchSearchEngineSelector::FromRust(
      uniffi_search_fn_constructor_searchengineselector_new(
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSearchFnMethodSearchengineselectorClearSearchConfig : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSearchSearchEngineSelector mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_search_fn_method_searchengineselector_clear_search_config(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiSearchFnMethodSearchengineselectorFilterEngineConfiguration : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSearchSearchEngineSelector mUniffiPtr{};
  FfiValueRustBuffer mUserEnvironment{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mUserEnvironment.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_search_fn_method_searchengineselector_filter_engine_configuration(
        mUniffiPtr.IntoRust(),
        mUserEnvironment.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSearchFnMethodSearchengineselectorSetConfigOverrides : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSearchSearchEngineSelector mUniffiPtr{};
  FfiValueRustBuffer mOverrides{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mOverrides.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_search_fn_method_searchengineselector_set_config_overrides(
      mUniffiPtr.IntoRust(),
      mOverrides.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiSearchFnMethodSearchengineselectorSetSearchConfig : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSearchSearchEngineSelector mUniffiPtr{};
  FfiValueRustBuffer mConfiguration{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mConfiguration.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_search_fn_method_searchengineselector_set_search_config(
      mUniffiPtr.IntoRust(),
      mConfiguration.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiSearchFnMethodSearchengineselectorUseRemoteSettingsServer : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSearchSearchEngineSelector mUniffiPtr{};
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService mService{};
  FfiValueInt<int8_t> mApplyEngineOverrides{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mService.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mApplyEngineOverrides.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_search_fn_method_searchengineselector_use_remote_settings_server(
      mUniffiPtr.IntoRust(),
      mService.IntoRust(),
      mApplyEngineOverrides.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnFuncRawSuggestionUrlMatches : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mRawUrl{};
  FfiValueRustBuffer mCookedUrl{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mRawUrl.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mCookedUrl.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_suggest_fn_func_raw_suggestion_url_matches(
        mRawUrl.IntoRust(),
        mCookedUrl.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnConstructorSuggeststoreNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mPath{};
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService mRemoteSettingsService{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPath.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mRemoteSettingsService.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleSuggestSuggestStore::FromRust(
      uniffi_suggest_fn_constructor_suggeststore_new(
        mPath.IntoRust(),
        mRemoteSettingsService.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreAnyDismissedSuggestions : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_suggest_fn_method_suggeststore_any_dismissed_suggestions(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreClear : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_suggest_fn_method_suggeststore_clear(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreClearDismissedSuggestions : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_suggest_fn_method_suggeststore_clear_dismissed_suggestions(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreDismissByKey : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};
  FfiValueRustBuffer mKey{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mKey.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_suggest_fn_method_suggeststore_dismiss_by_key(
      mUniffiPtr.IntoRust(),
      mKey.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreDismissBySuggestion : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};
  FfiValueRustBuffer mSuggestion{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mSuggestion.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_suggest_fn_method_suggeststore_dismiss_by_suggestion(
      mUniffiPtr.IntoRust(),
      mSuggestion.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreDismissSuggestion : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};
  FfiValueRustBuffer mSuggestionUrl{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mSuggestionUrl.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_suggest_fn_method_suggeststore_dismiss_suggestion(
      mUniffiPtr.IntoRust(),
      mSuggestionUrl.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreFetchGeonameAlternates : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};
  FfiValueRustBuffer mGeoname{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mGeoname.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_suggest_fn_method_suggeststore_fetch_geoname_alternates(
        mUniffiPtr.IntoRust(),
        mGeoname.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreFetchGeonames : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};
  FfiValueRustBuffer mQuery{};
  FfiValueInt<int8_t> mMatchNamePrefix{};
  FfiValueRustBuffer mFilter{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mQuery.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mMatchNamePrefix.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
    mFilter.Lower(aArgs[3], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_suggest_fn_method_suggeststore_fetch_geonames(
        mUniffiPtr.IntoRust(),
        mQuery.IntoRust(),
        mMatchNamePrefix.IntoRust(),
        mFilter.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreFetchGlobalConfig : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_suggest_fn_method_suggeststore_fetch_global_config(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreFetchProviderConfig : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};
  FfiValueRustBuffer mProvider{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mProvider.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_suggest_fn_method_suggeststore_fetch_provider_config(
        mUniffiPtr.IntoRust(),
        mProvider.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreIngest : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};
  FfiValueRustBuffer mConstraints{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mConstraints.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_suggest_fn_method_suggeststore_ingest(
        mUniffiPtr.IntoRust(),
        mConstraints.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreInterrupt : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};
  FfiValueRustBuffer mKind{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mKind.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_suggest_fn_method_suggeststore_interrupt(
      mUniffiPtr.IntoRust(),
      mKind.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreIsDismissedByKey : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};
  FfiValueRustBuffer mKey{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mKey.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_suggest_fn_method_suggeststore_is_dismissed_by_key(
        mUniffiPtr.IntoRust(),
        mKey.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreIsDismissedBySuggestion : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};
  FfiValueRustBuffer mSuggestion{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mSuggestion.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_suggest_fn_method_suggeststore_is_dismissed_by_suggestion(
        mUniffiPtr.IntoRust(),
        mSuggestion.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreQuery : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};
  FfiValueRustBuffer mQuery{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mQuery.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_suggest_fn_method_suggeststore_query(
        mUniffiPtr.IntoRust(),
        mQuery.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreQueryWithMetrics : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};
  FfiValueRustBuffer mQuery{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mQuery.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_suggest_fn_method_suggeststore_query_with_metrics(
        mUniffiPtr.IntoRust(),
        mQuery.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnConstructorSuggeststorebuilderNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleSuggestSuggestStoreBuilder::FromRust(
      uniffi_suggest_fn_constructor_suggeststorebuilder_new(
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderBuild : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleSuggestSuggestStore::FromRust(
      uniffi_suggest_fn_method_suggeststorebuilder_build(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderCachePath : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiPtr{};
  FfiValueRustBuffer mPath{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mPath.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleSuggestSuggestStoreBuilder::FromRust(
      uniffi_suggest_fn_method_suggeststorebuilder_cache_path(
        mUniffiPtr.IntoRust(),
        mPath.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderDataPath : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiPtr{};
  FfiValueRustBuffer mPath{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mPath.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleSuggestSuggestStoreBuilder::FromRust(
      uniffi_suggest_fn_method_suggeststorebuilder_data_path(
        mUniffiPtr.IntoRust(),
        mPath.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderLoadExtension : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiPtr{};
  FfiValueRustBuffer mLibrary{};
  FfiValueRustBuffer mEntryPoint{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mLibrary.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mEntryPoint.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleSuggestSuggestStoreBuilder::FromRust(
      uniffi_suggest_fn_method_suggeststorebuilder_load_extension(
        mUniffiPtr.IntoRust(),
        mLibrary.IntoRust(),
        mEntryPoint.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderRemoteSettingsBucketName : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiPtr{};
  FfiValueRustBuffer mBucketName{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mBucketName.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleSuggestSuggestStoreBuilder::FromRust(
      uniffi_suggest_fn_method_suggeststorebuilder_remote_settings_bucket_name(
        mUniffiPtr.IntoRust(),
        mBucketName.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderRemoteSettingsServer : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiPtr{};
  FfiValueRustBuffer mServer{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mServer.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleSuggestSuggestStoreBuilder::FromRust(
      uniffi_suggest_fn_method_suggeststorebuilder_remote_settings_server(
        mUniffiPtr.IntoRust(),
        mServer.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderRemoteSettingsService : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiPtr{};
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService mRsService{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mRsService.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleSuggestSuggestStoreBuilder::FromRust(
      uniffi_suggest_fn_method_suggeststorebuilder_remote_settings_service(
        mUniffiPtr.IntoRust(),
        mRsService.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodRemotecommandstoreAddRemoteCommand : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsRemoteCommandStore mUniffiPtr{};
  FfiValueRustBuffer mDeviceId{};
  FfiValueRustBuffer mCommand{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mDeviceId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mCommand.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_tabs_fn_method_remotecommandstore_add_remote_command(
        mUniffiPtr.IntoRust(),
        mDeviceId.IntoRust(),
        mCommand.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodRemotecommandstoreAddRemoteCommandAt : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsRemoteCommandStore mUniffiPtr{};
  FfiValueRustBuffer mDeviceId{};
  FfiValueRustBuffer mCommand{};
  FfiValueInt<int64_t> mWhen{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mDeviceId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mCommand.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
    mWhen.Lower(aArgs[3], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_tabs_fn_method_remotecommandstore_add_remote_command_at(
        mUniffiPtr.IntoRust(),
        mDeviceId.IntoRust(),
        mCommand.IntoRust(),
        mWhen.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodRemotecommandstoreGetUnsentCommands : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsRemoteCommandStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_tabs_fn_method_remotecommandstore_get_unsent_commands(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodRemotecommandstoreRemoveRemoteCommand : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsRemoteCommandStore mUniffiPtr{};
  FfiValueRustBuffer mDeviceId{};
  FfiValueRustBuffer mCommand{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mDeviceId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mCommand.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_tabs_fn_method_remotecommandstore_remove_remote_command(
        mUniffiPtr.IntoRust(),
        mDeviceId.IntoRust(),
        mCommand.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodRemotecommandstoreSetPendingCommandSent : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsRemoteCommandStore mUniffiPtr{};
  FfiValueRustBuffer mCommand{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mCommand.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_tabs_fn_method_remotecommandstore_set_pending_command_sent(
        mUniffiPtr.IntoRust(),
        mCommand.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineApply : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_tabs_fn_method_tabsbridgedengine_apply(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineEnsureCurrentSyncId : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mUniffiPtr{};
  FfiValueRustBuffer mNewSyncId{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mNewSyncId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_tabs_fn_method_tabsbridgedengine_ensure_current_sync_id(
        mUniffiPtr.IntoRust(),
        mNewSyncId.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineLastSync : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int64_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int64_t>::FromRust(
      uniffi_tabs_fn_method_tabsbridgedengine_last_sync(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedenginePrepareForSync : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mUniffiPtr{};
  FfiValueRustBuffer mClientData{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mClientData.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsbridgedengine_prepare_for_sync(
      mUniffiPtr.IntoRust(),
      mClientData.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineReset : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsbridgedengine_reset(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineResetSyncId : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_tabs_fn_method_tabsbridgedengine_reset_sync_id(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineSetLastSync : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mUniffiPtr{};
  FfiValueInt<int64_t> mLastSync{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mLastSync.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsbridgedengine_set_last_sync(
      mUniffiPtr.IntoRust(),
      mLastSync.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineSetUploaded : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mUniffiPtr{};
  FfiValueInt<int64_t> mNewTimestamp{};
  FfiValueRustBuffer mUploadedIds{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mNewTimestamp.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mUploadedIds.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsbridgedengine_set_uploaded(
      mUniffiPtr.IntoRust(),
      mNewTimestamp.IntoRust(),
      mUploadedIds.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineStoreIncoming : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mUniffiPtr{};
  FfiValueRustBuffer mIncomingEnvelopesAsJson{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mIncomingEnvelopesAsJson.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsbridgedengine_store_incoming(
      mUniffiPtr.IntoRust(),
      mIncomingEnvelopesAsJson.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineSyncFinished : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsbridgedengine_sync_finished(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineSyncId : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_tabs_fn_method_tabsbridgedengine_sync_id(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineSyncStarted : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsbridgedengine_sync_started(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineWipe : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsbridgedengine_wipe(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiTabsFnConstructorTabsstoreNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mPath{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleTabsTabsStore mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPath.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleTabsTabsStore::FromRust(
      uniffi_tabs_fn_constructor_tabsstore_new(
        mPath.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreBridgedEngine : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleTabsTabsBridgedEngine::FromRust(
      uniffi_tabs_fn_method_tabsstore_bridged_engine(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreCloseConnection : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsstore_close_connection(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreGetAll : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_tabs_fn_method_tabsstore_get_all(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreNewRemoteCommandStore : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleTabsRemoteCommandStore mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleTabsRemoteCommandStore::FromRust(
      uniffi_tabs_fn_method_tabsstore_new_remote_command_store(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreRegisterWithSyncManager : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsstore_register_with_sync_manager(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreSetLocalTabs : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsStore mUniffiPtr{};
  FfiValueRustBuffer mRemoteTabs{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mRemoteTabs.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsstore_set_local_tabs(
      mUniffiPtr.IntoRust(),
      mRemoteTabs.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineApply : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_webext_storage_fn_method_webextstoragebridgedengine_apply(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineEnsureCurrentSyncId : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mUniffiPtr{};
  FfiValueRustBuffer mNewSyncId{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mNewSyncId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_webext_storage_fn_method_webextstoragebridgedengine_ensure_current_sync_id(
        mUniffiPtr.IntoRust(),
        mNewSyncId.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineLastSync : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int64_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int64_t>::FromRust(
      uniffi_webext_storage_fn_method_webextstoragebridgedengine_last_sync(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedenginePrepareForSync : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mUniffiPtr{};
  FfiValueRustBuffer mClientData{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mClientData.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_webext_storage_fn_method_webextstoragebridgedengine_prepare_for_sync(
      mUniffiPtr.IntoRust(),
      mClientData.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineReset : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_webext_storage_fn_method_webextstoragebridgedengine_reset(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineResetSyncId : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_webext_storage_fn_method_webextstoragebridgedengine_reset_sync_id(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineSetLastSync : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mUniffiPtr{};
  FfiValueInt<int64_t> mLastSync{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mLastSync.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_webext_storage_fn_method_webextstoragebridgedengine_set_last_sync(
      mUniffiPtr.IntoRust(),
      mLastSync.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineSetUploaded : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mUniffiPtr{};
  FfiValueInt<int64_t> mServerModifiedMillis{};
  FfiValueRustBuffer mGuids{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mServerModifiedMillis.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mGuids.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_webext_storage_fn_method_webextstoragebridgedengine_set_uploaded(
      mUniffiPtr.IntoRust(),
      mServerModifiedMillis.IntoRust(),
      mGuids.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineStoreIncoming : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mUniffiPtr{};
  FfiValueRustBuffer mIncoming{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mIncoming.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_webext_storage_fn_method_webextstoragebridgedengine_store_incoming(
      mUniffiPtr.IntoRust(),
      mIncoming.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineSyncFinished : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_webext_storage_fn_method_webextstoragebridgedengine_sync_finished(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineSyncId : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_webext_storage_fn_method_webextstoragebridgedengine_sync_id(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineSyncStarted : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_webext_storage_fn_method_webextstoragebridgedengine_sync_started(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineWipe : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_webext_storage_fn_method_webextstoragebridgedengine_wipe(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnConstructorWebextstoragestoreNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mPath{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageStore mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPath.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleWebextstorageWebExtStorageStore::FromRust(
      uniffi_webext_storage_fn_constructor_webextstoragestore_new(
        mPath.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreBridgedEngine : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine::FromRust(
      uniffi_webext_storage_fn_method_webextstoragestore_bridged_engine(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreClear : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageStore mUniffiPtr{};
  FfiValueRustBuffer mExtId{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mExtId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_webext_storage_fn_method_webextstoragestore_clear(
        mUniffiPtr.IntoRust(),
        mExtId.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreClose : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_webext_storage_fn_method_webextstoragestore_close(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreGet : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageStore mUniffiPtr{};
  FfiValueRustBuffer mExtId{};
  FfiValueRustBuffer mKeys{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mExtId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mKeys.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_webext_storage_fn_method_webextstoragestore_get(
        mUniffiPtr.IntoRust(),
        mExtId.IntoRust(),
        mKeys.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreGetBytesInUse : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageStore mUniffiPtr{};
  FfiValueRustBuffer mExtId{};
  FfiValueRustBuffer mKeys{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint64_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mExtId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mKeys.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint64_t>::FromRust(
      uniffi_webext_storage_fn_method_webextstoragestore_get_bytes_in_use(
        mUniffiPtr.IntoRust(),
        mExtId.IntoRust(),
        mKeys.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreGetSyncedChanges : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_webext_storage_fn_method_webextstoragestore_get_synced_changes(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreRemove : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageStore mUniffiPtr{};
  FfiValueRustBuffer mExtId{};
  FfiValueRustBuffer mKeys{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mExtId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mKeys.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_webext_storage_fn_method_webextstoragestore_remove(
        mUniffiPtr.IntoRust(),
        mExtId.IntoRust(),
        mKeys.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreSet : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageStore mUniffiPtr{};
  FfiValueRustBuffer mExtId{};
  FfiValueRustBuffer mVal{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mExtId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mVal.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_webext_storage_fn_method_webextstoragestore_set(
        mUniffiPtr.IntoRust(),
        mExtId.IntoRust(),
        mVal.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};

#ifdef MOZ_UNIFFI_FIXTURES
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripF32 : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripF32() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_f32,
        ffi_uniffi_bindings_tests_rust_future_free_f32
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueFloat<float> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueFloat<float> mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_f32(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueFloat<float>::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_f32(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripF64 : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripF64() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_f64,
        ffi_uniffi_bindings_tests_rust_future_free_f64
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueFloat<double> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueFloat<double> mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_f64(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueFloat<double>::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_f64(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripI16 : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripI16() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_i16,
        ffi_uniffi_bindings_tests_rust_future_free_i16
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueInt<int16_t> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueInt<int16_t> mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_i16(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int16_t>::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_i16(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripI32 : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripI32() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_i32,
        ffi_uniffi_bindings_tests_rust_future_free_i32
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueInt<int32_t> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueInt<int32_t> mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_i32(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int32_t>::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_i32(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripI64 : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripI64() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_i64,
        ffi_uniffi_bindings_tests_rust_future_free_i64
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueInt<int64_t> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueInt<int64_t> mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_i64(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int64_t>::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_i64(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripI8 : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripI8() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_i8,
        ffi_uniffi_bindings_tests_rust_future_free_i8
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueInt<int8_t> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueInt<int8_t> mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_i8(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_i8(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripMap : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripMap() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_rust_buffer,
        ffi_uniffi_bindings_tests_rust_future_free_rust_buffer
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueRustBuffer mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueRustBuffer mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_map(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_rust_buffer(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripObj : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripObj() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_pointer,
        ffi_uniffi_bindings_tests_rust_future_free_pointer
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueObjectHandleUniffiBindingsTestsAsyncInterface mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueObjectHandleUniffiBindingsTestsAsyncInterface mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_obj(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleUniffiBindingsTestsAsyncInterface::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_pointer(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripString : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripString() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_rust_buffer,
        ffi_uniffi_bindings_tests_rust_future_free_rust_buffer
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueRustBuffer mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueRustBuffer mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_string(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_rust_buffer(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripU16 : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripU16() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_u16,
        ffi_uniffi_bindings_tests_rust_future_free_u16
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueInt<uint16_t> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueInt<uint16_t> mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_u16(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint16_t>::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_u16(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripU32 : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripU32() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_u32,
        ffi_uniffi_bindings_tests_rust_future_free_u32
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueInt<uint32_t> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueInt<uint32_t> mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_u32(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint32_t>::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_u32(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripU64 : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripU64() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_u64,
        ffi_uniffi_bindings_tests_rust_future_free_u64
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueInt<uint64_t> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueInt<uint64_t> mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_u64(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint64_t>::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_u64(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripU8 : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripU8() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_u8,
        ffi_uniffi_bindings_tests_rust_future_free_u8
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueInt<uint8_t> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueInt<uint8_t> mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_u8(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint8_t>::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_u8(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripVec : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripVec() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_rust_buffer,
        ffi_uniffi_bindings_tests_rust_future_free_rust_buffer
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueRustBuffer mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueRustBuffer mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_vec(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_rust_buffer(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncThrowError : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncThrowError() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_void,
        ffi_uniffi_bindings_tests_rust_future_free_void
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_throw_error(
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    ffi_uniffi_bindings_tests_rust_future_complete_void(mFutureHandle, aOutStatus);
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncCloneInterface : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestInterface mInt{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestInterface mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mInt.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleUniffiBindingsTestsTestInterface::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_clone_interface(
        mInt.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncCreateAsyncTestTraitInterface : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint32_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mValue.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_create_async_test_trait_interface(
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncCreateTestTraitInterface : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint32_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mValue.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_create_test_trait_interface(
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncFuncWithDefault : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mArg{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mArg.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_func_with_default(
        mArg.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncFuncWithError : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint32_t> mInput{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mInput.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_uniffi_bindings_tests_fn_func_func_with_error(
      mInput.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncFuncWithFlatError : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint32_t> mInput{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mInput.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_uniffi_bindings_tests_fn_func_func_with_flat_error(
      mInput.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncFuncWithMultiWordArg : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mTheArgument{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mTheArgument.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_func_with_multi_word_arg(
        mTheArgument.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncGetCustomTypesDemo : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_get_custom_types_demo(
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeAsyncTestTraitInterfaceGetValue : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeAsyncTestTraitInterfaceGetValue() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_u32,
        ffi_uniffi_bindings_tests_rust_future_free_u32
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueInt<uint32_t> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface mInt{};
    mInt.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_invoke_async_test_trait_interface_get_value(
      mInt.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint32_t>::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_u32(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeAsyncTestTraitInterfaceNoop : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeAsyncTestTraitInterfaceNoop() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_void,
        ffi_uniffi_bindings_tests_rust_future_free_void
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface mInt{};
    mInt.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_invoke_async_test_trait_interface_noop(
      mInt.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    ffi_uniffi_bindings_tests_rust_future_complete_void(mFutureHandle, aOutStatus);
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeAsyncTestTraitInterfaceSetValue : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeAsyncTestTraitInterfaceSetValue() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_void,
        ffi_uniffi_bindings_tests_rust_future_free_void
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface mInt{};
    mInt.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    FfiValueInt<uint32_t> mValue{};
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_invoke_async_test_trait_interface_set_value(
      mInt.IntoRust(),
      mValue.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    ffi_uniffi_bindings_tests_rust_future_complete_void(mFutureHandle, aOutStatus);
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeAsyncTestTraitInterfaceThrowIfEqual : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeAsyncTestTraitInterfaceThrowIfEqual() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_rust_buffer,
        ffi_uniffi_bindings_tests_rust_future_free_rust_buffer
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueRustBuffer mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface mInt{};
    mInt.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    FfiValueRustBuffer mNumbers{};
    mNumbers.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_invoke_async_test_trait_interface_throw_if_equal(
      mInt.IntoRust(),
      mNumbers.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_rust_buffer(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestAsyncCallbackInterfaceGetValue : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestAsyncCallbackInterfaceGetValue() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_u32,
        ffi_uniffi_bindings_tests_rust_future_free_u32
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueInt<uint32_t> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueCallbackInterfaceuniffi_bindings_tests_TestAsyncCallbackInterface mCbi{};
    mCbi.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_invoke_test_async_callback_interface_get_value(
      mCbi.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint32_t>::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_u32(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestAsyncCallbackInterfaceNoop : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestAsyncCallbackInterfaceNoop() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_void,
        ffi_uniffi_bindings_tests_rust_future_free_void
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueCallbackInterfaceuniffi_bindings_tests_TestAsyncCallbackInterface mCbi{};
    mCbi.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_invoke_test_async_callback_interface_noop(
      mCbi.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    ffi_uniffi_bindings_tests_rust_future_complete_void(mFutureHandle, aOutStatus);
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestAsyncCallbackInterfaceSetValue : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestAsyncCallbackInterfaceSetValue() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_void,
        ffi_uniffi_bindings_tests_rust_future_free_void
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueCallbackInterfaceuniffi_bindings_tests_TestAsyncCallbackInterface mCbi{};
    mCbi.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    FfiValueInt<uint32_t> mValue{};
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_invoke_test_async_callback_interface_set_value(
      mCbi.IntoRust(),
      mValue.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    ffi_uniffi_bindings_tests_rust_future_complete_void(mFutureHandle, aOutStatus);
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestAsyncCallbackInterfaceThrowIfEqual : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestAsyncCallbackInterfaceThrowIfEqual() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_rust_buffer,
        ffi_uniffi_bindings_tests_rust_future_free_rust_buffer
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueRustBuffer mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueCallbackInterfaceuniffi_bindings_tests_TestAsyncCallbackInterface mCbi{};
    mCbi.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    FfiValueRustBuffer mNumbers{};
    mNumbers.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_invoke_test_async_callback_interface_throw_if_equal(
      mCbi.IntoRust(),
      mNumbers.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_rust_buffer(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestCallbackInterfaceGetValue : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueCallbackInterfaceuniffi_bindings_tests_TestCallbackInterface mCbi{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint32_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mCbi.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint32_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_invoke_test_callback_interface_get_value(
        mCbi.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestCallbackInterfaceNoop : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueCallbackInterfaceuniffi_bindings_tests_TestCallbackInterface mCbi{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mCbi.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_uniffi_bindings_tests_fn_func_invoke_test_callback_interface_noop(
      mCbi.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestCallbackInterfaceSetValue : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueCallbackInterfaceuniffi_bindings_tests_TestCallbackInterface mCbi{};
  FfiValueInt<uint32_t> mValue{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mCbi.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_uniffi_bindings_tests_fn_func_invoke_test_callback_interface_set_value(
      mCbi.IntoRust(),
      mValue.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestCallbackInterfaceThrowIfEqual : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueCallbackInterfaceuniffi_bindings_tests_TestCallbackInterface mCbi{};
  FfiValueRustBuffer mNumbers{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mCbi.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mNumbers.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_invoke_test_callback_interface_throw_if_equal(
        mCbi.IntoRust(),
        mNumbers.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestTraitInterfaceGetValue : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface mInt{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint32_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mInt.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint32_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_invoke_test_trait_interface_get_value(
        mInt.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestTraitInterfaceNoop : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface mInt{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mInt.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_uniffi_bindings_tests_fn_func_invoke_test_trait_interface_noop(
      mInt.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestTraitInterfaceSetValue : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface mInt{};
  FfiValueInt<uint32_t> mValue{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mInt.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_uniffi_bindings_tests_fn_func_invoke_test_trait_interface_set_value(
      mInt.IntoRust(),
      mValue.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestTraitInterfaceThrowIfEqual : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface mInt{};
  FfiValueRustBuffer mNumbers{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mInt.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mNumbers.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_invoke_test_trait_interface_throw_if_equal(
        mInt.IntoRust(),
        mNumbers.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripBool : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<int8_t> mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_bool(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripComplexCompound : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_complex_compound(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripComplexEnum : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mEn{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mEn.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_complex_enum(
        mEn.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripComplexRec : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mRec{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mRec.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_complex_rec(
        mRec.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripCustomType : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint64_t> mHandle{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint64_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mHandle.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint64_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_custom_type(
        mHandle.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripEnumNoData : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mEn{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mEn.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_enum_no_data(
        mEn.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripEnumWithData : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mEn{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mEn.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_enum_with_data(
        mEn.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripF32 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueFloat<float> mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueFloat<float> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueFloat<float>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_f32(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripF64 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueFloat<double> mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueFloat<double> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueFloat<double>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_f64(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripHashMap : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_hash_map(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripI16 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<int16_t> mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int16_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int16_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_i16(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripI32 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<int32_t> mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int32_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int32_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_i32(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripI64 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<int64_t> mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int64_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int64_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_i64(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripI8 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<int8_t> mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_i8(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripOption : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_option(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripSimpleRec : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mRec{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mRec.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_simple_rec(
        mRec.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripString : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_string(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripTimeIntervalMs : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<int64_t> mTime{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int64_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mTime.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int64_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_time_interval_ms(
        mTime.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripTimeIntervalSecDbl : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueFloat<double> mTime{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueFloat<double> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mTime.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueFloat<double>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_time_interval_sec_dbl(
        mTime.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripTimeIntervalSecFlt : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueFloat<float> mTime{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueFloat<float> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mTime.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueFloat<float>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_time_interval_sec_flt(
        mTime.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripU16 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint16_t> mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint16_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint16_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_u16(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripU32 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint32_t> mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint32_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint32_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_u32(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripU64 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint64_t> mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint64_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint64_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_u64(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripU8 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint8_t> mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint8_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_u8(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripUrl : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mUrl{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUrl.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_url(
        mUrl.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripVec : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_vec(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncSumWithManyTypes : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint8_t> mA{};
  FfiValueInt<int8_t> mB{};
  FfiValueInt<uint16_t> mC{};
  FfiValueInt<int16_t> mD{};
  FfiValueInt<uint32_t> mE{};
  FfiValueInt<int32_t> mF{};
  FfiValueInt<uint64_t> mG{};
  FfiValueInt<int64_t> mH{};
  FfiValueFloat<float> mI{};
  FfiValueFloat<double> mJ{};
  FfiValueInt<int8_t> mNegate{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueFloat<double> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mB.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mC.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
    mD.Lower(aArgs[3], aError);
    if (aError.Failed()) {
      return;
    }
    mE.Lower(aArgs[4], aError);
    if (aError.Failed()) {
      return;
    }
    mF.Lower(aArgs[5], aError);
    if (aError.Failed()) {
      return;
    }
    mG.Lower(aArgs[6], aError);
    if (aError.Failed()) {
      return;
    }
    mH.Lower(aArgs[7], aError);
    if (aError.Failed()) {
      return;
    }
    mI.Lower(aArgs[8], aError);
    if (aError.Failed()) {
      return;
    }
    mJ.Lower(aArgs[9], aError);
    if (aError.Failed()) {
      return;
    }
    mNegate.Lower(aArgs[10], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueFloat<double>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_sum_with_many_types(
        mA.IntoRust(),
        mB.IntoRust(),
        mC.IntoRust(),
        mD.IntoRust(),
        mE.IntoRust(),
        mF.IntoRust(),
        mG.IntoRust(),
        mH.IntoRust(),
        mI.IntoRust(),
        mJ.IntoRust(),
        mNegate.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncSwapTestInterfaces : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mInterfaces{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mInterfaces.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_swap_test_interfaces(
        mInterfaces.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncTestFunc : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_uniffi_bindings_tests_fn_func_test_func(
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnConstructorTestinterfaceNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint32_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestInterface mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mValue.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleUniffiBindingsTestsTestInterface::FromRust(
      uniffi_uniffi_bindings_tests_fn_constructor_testinterface_new(
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodTestinterfaceGetValue : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestInterface mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint32_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint32_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_method_testinterface_get_value(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodTestinterfaceRefCount : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestInterface mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint32_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint32_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_method_testinterface_ref_count(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnConstructorAsyncinterfaceNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mName{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleUniffiBindingsTestsAsyncInterface mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mName.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleUniffiBindingsTestsAsyncInterface::FromRust(
      uniffi_uniffi_bindings_tests_fn_constructor_asyncinterface_new(
        mName.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodAsyncinterfaceName : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodAsyncinterfaceName() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_rust_buffer,
        ffi_uniffi_bindings_tests_rust_future_free_rust_buffer
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueRustBuffer mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueObjectHandleUniffiBindingsTestsAsyncInterface mUniffiPtr{};
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_method_asyncinterface_name(
      mUniffiPtr.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_rust_buffer(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodAsynctesttraitinterfaceNoop : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodAsynctesttraitinterfaceNoop() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_void,
        ffi_uniffi_bindings_tests_rust_future_free_void
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface mUniffiPtr{};
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_method_asynctesttraitinterface_noop(
      mUniffiPtr.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    ffi_uniffi_bindings_tests_rust_future_complete_void(mFutureHandle, aOutStatus);
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodAsynctesttraitinterfaceGetValue : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodAsynctesttraitinterfaceGetValue() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_u32,
        ffi_uniffi_bindings_tests_rust_future_free_u32
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueInt<uint32_t> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface mUniffiPtr{};
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_method_asynctesttraitinterface_get_value(
      mUniffiPtr.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint32_t>::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_u32(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodAsynctesttraitinterfaceSetValue : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodAsynctesttraitinterfaceSetValue() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_void,
        ffi_uniffi_bindings_tests_rust_future_free_void
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface mUniffiPtr{};
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    FfiValueInt<uint32_t> mValue{};
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_method_asynctesttraitinterface_set_value(
      mUniffiPtr.IntoRust(),
      mValue.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    ffi_uniffi_bindings_tests_rust_future_complete_void(mFutureHandle, aOutStatus);
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodAsynctesttraitinterfaceThrowIfEqual : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodAsynctesttraitinterfaceThrowIfEqual() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_rust_buffer,
        ffi_uniffi_bindings_tests_rust_future_free_rust_buffer
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueRustBuffer mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueObjectHandleUniffiBindingsTestsAsyncTestTraitInterface mUniffiPtr{};
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    FfiValueRustBuffer mNumbers{};
    mNumbers.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_method_asynctesttraitinterface_throw_if_equal(
      mUniffiPtr.IntoRust(),
      mNumbers.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_rust_buffer(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnConstructorComplexmethodsNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleUniffiBindingsTestsComplexMethods mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleUniffiBindingsTestsComplexMethods::FromRust(
      uniffi_uniffi_bindings_tests_fn_constructor_complexmethods_new(
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodComplexmethodsMethodWithDefault : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleUniffiBindingsTestsComplexMethods mUniffiPtr{};
  FfiValueRustBuffer mArg{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mArg.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_method_complexmethods_method_with_default(
        mUniffiPtr.IntoRust(),
        mArg.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodComplexmethodsMethodWithMultiWordArg : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleUniffiBindingsTestsComplexMethods mUniffiPtr{};
  FfiValueRustBuffer mTheArgument{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mTheArgument.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_method_complexmethods_method_with_multi_word_arg(
        mUniffiPtr.IntoRust(),
        mTheArgument.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodTesttraitinterfaceNoop : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_uniffi_bindings_tests_fn_method_testtraitinterface_noop(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodTesttraitinterfaceGetValue : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint32_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint32_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_method_testtraitinterface_get_value(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodTesttraitinterfaceSetValue : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface mUniffiPtr{};
  FfiValueInt<uint32_t> mValue{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_uniffi_bindings_tests_fn_method_testtraitinterface_set_value(
      mUniffiPtr.IntoRust(),
      mValue.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodTesttraitinterfaceThrowIfEqual : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestTraitInterface mUniffiPtr{};
  FfiValueRustBuffer mNumbers{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.LowerReciever(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mNumbers.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_method_testtraitinterface_throw_if_equal(
        mUniffiPtr.IntoRust(),
        mNumbers.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsCollisionFnFuncInvokeCollisionCallback : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueCallbackInterfaceuniffi_bindings_tests_collision_TestCallbackInterface mCb{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mCb.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_collision_fn_func_invoke_collision_callback(
        mCb.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsExternalTypesFnFuncRoundtripExtCustomType : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint64_t> mCustom{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint64_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mCustom.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint64_t>::FromRust(
      uniffi_uniffi_bindings_tests_external_types_fn_func_roundtrip_ext_custom_type(
        mCustom.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsExternalTypesFnFuncRoundtripExtEnum : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mEn{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mEn.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_external_types_fn_func_roundtrip_ext_enum(
        mEn.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsExternalTypesFnFuncRoundtripExtInterface : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestInterface mInt{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestInterface mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mInt.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleUniffiBindingsTestsTestInterface::FromRust(
      uniffi_uniffi_bindings_tests_external_types_fn_func_roundtrip_ext_interface(
        mInt.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsExternalTypesFnFuncRoundtripExtRecord : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mRec{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mRec.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_external_types_fn_func_roundtrip_ext_record(
        mRec.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
#endif /* MOZ_UNIFFI_FIXTURES */

UniquePtr<UniffiSyncCallHandler> GetSyncCallHandler(uint64_t aId) {
  switch (aId) {

    case 1: {
      return MakeUnique<ScaffoldingCallHandlerUniffiContextIdFnConstructorContextidcomponentNew>();
    }
    case 2: {
      return MakeUnique<ScaffoldingCallHandlerUniffiContextIdFnMethodContextidcomponentForceRotation>();
    }
    case 3: {
      return MakeUnique<ScaffoldingCallHandlerUniffiContextIdFnMethodContextidcomponentRequest>();
    }
    case 4: {
      return MakeUnique<ScaffoldingCallHandlerUniffiContextIdFnMethodContextidcomponentUnsetCallback>();
    }
    case 5: {
      return MakeUnique<ScaffoldingCallHandlerUniffiErrorSupportFnFuncSetApplicationErrorReporter>();
    }
    case 6: {
      return MakeUnique<ScaffoldingCallHandlerUniffiErrorSupportFnFuncUnsetApplicationErrorReporter>();
    }
    case 7: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnFuncScore>();
    }
    case 8: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnConstructorRelevancystoreNew>();
    }
    case 9: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreBanditInit>();
    }
    case 10: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreBanditSelect>();
    }
    case 11: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreBanditUpdate>();
    }
    case 12: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreClose>();
    }
    case 13: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreEnsureInterestDataPopulated>();
    }
    case 14: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreGetBanditData>();
    }
    case 15: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreIngest>();
    }
    case 16: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreInterrupt>();
    }
    case 17: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreUserInterestVector>();
    }
    case 18: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnConstructorRemotesettingsNew>();
    }
    case 19: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsDownloadAttachmentToPath>();
    }
    case 20: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsGetRecords>();
    }
    case 21: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsGetRecordsSince>();
    }
    case 22: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientCollectionName>();
    }
    case 23: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientGetAttachment>();
    }
    case 24: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientGetRecords>();
    }
    case 25: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientGetRecordsMap>();
    }
    case 26: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientShutdown>();
    }
    case 27: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientSync>();
    }
    case 28: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnConstructorRemotesettingsserviceNew>();
    }
    case 29: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsserviceMakeClient>();
    }
    case 30: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsserviceSync>();
    }
    case 31: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsserviceUpdateConfig>();
    }
    case 32: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSearchFnConstructorSearchengineselectorNew>();
    }
    case 33: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSearchFnMethodSearchengineselectorClearSearchConfig>();
    }
    case 34: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSearchFnMethodSearchengineselectorFilterEngineConfiguration>();
    }
    case 35: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSearchFnMethodSearchengineselectorSetConfigOverrides>();
    }
    case 36: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSearchFnMethodSearchengineselectorSetSearchConfig>();
    }
    case 37: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSearchFnMethodSearchengineselectorUseRemoteSettingsServer>();
    }
    case 38: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnFuncRawSuggestionUrlMatches>();
    }
    case 39: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnConstructorSuggeststoreNew>();
    }
    case 40: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreAnyDismissedSuggestions>();
    }
    case 41: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreClear>();
    }
    case 42: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreClearDismissedSuggestions>();
    }
    case 43: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreDismissByKey>();
    }
    case 44: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreDismissBySuggestion>();
    }
    case 45: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreDismissSuggestion>();
    }
    case 46: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreFetchGeonameAlternates>();
    }
    case 47: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreFetchGeonames>();
    }
    case 48: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreFetchGlobalConfig>();
    }
    case 49: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreFetchProviderConfig>();
    }
    case 50: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreIngest>();
    }
    case 51: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreInterrupt>();
    }
    case 52: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreIsDismissedByKey>();
    }
    case 53: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreIsDismissedBySuggestion>();
    }
    case 54: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreQuery>();
    }
    case 55: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreQueryWithMetrics>();
    }
    case 56: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnConstructorSuggeststorebuilderNew>();
    }
    case 57: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderBuild>();
    }
    case 58: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderCachePath>();
    }
    case 59: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderDataPath>();
    }
    case 60: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderLoadExtension>();
    }
    case 61: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderRemoteSettingsBucketName>();
    }
    case 62: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderRemoteSettingsServer>();
    }
    case 63: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderRemoteSettingsService>();
    }
    case 64: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodRemotecommandstoreAddRemoteCommand>();
    }
    case 65: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodRemotecommandstoreAddRemoteCommandAt>();
    }
    case 66: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodRemotecommandstoreGetUnsentCommands>();
    }
    case 67: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodRemotecommandstoreRemoveRemoteCommand>();
    }
    case 68: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodRemotecommandstoreSetPendingCommandSent>();
    }
    case 69: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineApply>();
    }
    case 70: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineEnsureCurrentSyncId>();
    }
    case 71: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineLastSync>();
    }
    case 72: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedenginePrepareForSync>();
    }
    case 73: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineReset>();
    }
    case 74: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineResetSyncId>();
    }
    case 75: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineSetLastSync>();
    }
    case 76: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineSetUploaded>();
    }
    case 77: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineStoreIncoming>();
    }
    case 78: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineSyncFinished>();
    }
    case 79: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineSyncId>();
    }
    case 80: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineSyncStarted>();
    }
    case 81: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineWipe>();
    }
    case 82: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnConstructorTabsstoreNew>();
    }
    case 83: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreBridgedEngine>();
    }
    case 84: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreCloseConnection>();
    }
    case 85: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreGetAll>();
    }
    case 86: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreNewRemoteCommandStore>();
    }
    case 87: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreRegisterWithSyncManager>();
    }
    case 88: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreSetLocalTabs>();
    }
    case 89: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineApply>();
    }
    case 90: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineEnsureCurrentSyncId>();
    }
    case 91: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineLastSync>();
    }
    case 92: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedenginePrepareForSync>();
    }
    case 93: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineReset>();
    }
    case 94: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineResetSyncId>();
    }
    case 95: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineSetLastSync>();
    }
    case 96: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineSetUploaded>();
    }
    case 97: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineStoreIncoming>();
    }
    case 98: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineSyncFinished>();
    }
    case 99: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineSyncId>();
    }
    case 100: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineSyncStarted>();
    }
    case 101: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineWipe>();
    }
    case 102: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnConstructorWebextstoragestoreNew>();
    }
    case 103: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreBridgedEngine>();
    }
    case 104: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreClear>();
    }
    case 105: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreClose>();
    }
    case 106: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreGet>();
    }
    case 107: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreGetBytesInUse>();
    }
    case 108: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreGetSyncedChanges>();
    }
    case 109: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreRemove>();
    }
    case 110: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreSet>();
    }

#ifdef MOZ_UNIFFI_FIXTURES
    case 126: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncCloneInterface>();
    }
    case 127: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncCreateAsyncTestTraitInterface>();
    }
    case 128: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncCreateTestTraitInterface>();
    }
    case 129: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncFuncWithDefault>();
    }
    case 130: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncFuncWithError>();
    }
    case 131: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncFuncWithFlatError>();
    }
    case 132: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncFuncWithMultiWordArg>();
    }
    case 133: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncGetCustomTypesDemo>();
    }
    case 142: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestCallbackInterfaceGetValue>();
    }
    case 143: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestCallbackInterfaceNoop>();
    }
    case 144: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestCallbackInterfaceSetValue>();
    }
    case 145: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestCallbackInterfaceThrowIfEqual>();
    }
    case 146: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestTraitInterfaceGetValue>();
    }
    case 147: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestTraitInterfaceNoop>();
    }
    case 148: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestTraitInterfaceSetValue>();
    }
    case 149: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestTraitInterfaceThrowIfEqual>();
    }
    case 150: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripBool>();
    }
    case 151: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripComplexCompound>();
    }
    case 152: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripComplexEnum>();
    }
    case 153: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripComplexRec>();
    }
    case 154: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripCustomType>();
    }
    case 155: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripEnumNoData>();
    }
    case 156: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripEnumWithData>();
    }
    case 157: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripF32>();
    }
    case 158: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripF64>();
    }
    case 159: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripHashMap>();
    }
    case 160: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripI16>();
    }
    case 161: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripI32>();
    }
    case 162: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripI64>();
    }
    case 163: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripI8>();
    }
    case 164: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripOption>();
    }
    case 165: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripSimpleRec>();
    }
    case 166: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripString>();
    }
    case 167: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripTimeIntervalMs>();
    }
    case 168: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripTimeIntervalSecDbl>();
    }
    case 169: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripTimeIntervalSecFlt>();
    }
    case 170: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripU16>();
    }
    case 171: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripU32>();
    }
    case 172: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripU64>();
    }
    case 173: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripU8>();
    }
    case 174: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripUrl>();
    }
    case 175: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripVec>();
    }
    case 176: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncSumWithManyTypes>();
    }
    case 177: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncSwapTestInterfaces>();
    }
    case 178: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncTestFunc>();
    }
    case 179: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnConstructorTestinterfaceNew>();
    }
    case 180: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodTestinterfaceGetValue>();
    }
    case 181: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodTestinterfaceRefCount>();
    }
    case 182: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnConstructorAsyncinterfaceNew>();
    }
    case 188: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnConstructorComplexmethodsNew>();
    }
    case 189: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodComplexmethodsMethodWithDefault>();
    }
    case 190: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodComplexmethodsMethodWithMultiWordArg>();
    }
    case 191: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodTesttraitinterfaceNoop>();
    }
    case 192: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodTesttraitinterfaceGetValue>();
    }
    case 193: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodTesttraitinterfaceSetValue>();
    }
    case 194: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodTesttraitinterfaceThrowIfEqual>();
    }
    case 195: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsCollisionFnFuncInvokeCollisionCallback>();
    }
    case 196: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsExternalTypesFnFuncRoundtripExtCustomType>();
    }
    case 197: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsExternalTypesFnFuncRoundtripExtEnum>();
    }
    case 198: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsExternalTypesFnFuncRoundtripExtInterface>();
    }
    case 199: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsExternalTypesFnFuncRoundtripExtRecord>();
    }
#endif /* MOZ_UNIFFI_FIXTURES */

    default:
      return nullptr;
  }
}

UniquePtr<UniffiAsyncCallHandler> GetAsyncCallHandler(uint64_t aId) {
  switch (aId) {


#ifdef MOZ_UNIFFI_FIXTURES
    case 111: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripF32>();
    }
    case 112: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripF64>();
    }
    case 113: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripI16>();
    }
    case 114: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripI32>();
    }
    case 115: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripI64>();
    }
    case 116: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripI8>();
    }
    case 117: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripMap>();
    }
    case 118: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripObj>();
    }
    case 119: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripString>();
    }
    case 120: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripU16>();
    }
    case 121: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripU32>();
    }
    case 122: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripU64>();
    }
    case 123: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripU8>();
    }
    case 124: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripVec>();
    }
    case 125: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncThrowError>();
    }
    case 134: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeAsyncTestTraitInterfaceGetValue>();
    }
    case 135: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeAsyncTestTraitInterfaceNoop>();
    }
    case 136: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeAsyncTestTraitInterfaceSetValue>();
    }
    case 137: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeAsyncTestTraitInterfaceThrowIfEqual>();
    }
    case 138: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestAsyncCallbackInterfaceGetValue>();
    }
    case 139: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestAsyncCallbackInterfaceNoop>();
    }
    case 140: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestAsyncCallbackInterfaceSetValue>();
    }
    case 141: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestAsyncCallbackInterfaceThrowIfEqual>();
    }
    case 183: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodAsyncinterfaceName>();
    }
    case 184: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodAsynctesttraitinterfaceNoop>();
    }
    case 185: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodAsynctesttraitinterfaceGetValue>();
    }
    case 186: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodAsynctesttraitinterfaceSetValue>();
    }
    case 187: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodAsynctesttraitinterfaceThrowIfEqual>();
    }
#endif /* MOZ_UNIFFI_FIXTURES */

    default:
      return nullptr;
  }
}
/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set ts=8 sts=2 et sw=2 tw=80: */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */


#ifdef MOZ_UNIFFI_FIXTURES

class AsyncCallbackMethodHandlerBaseVoid : public AsyncCallbackMethodHandlerBase {
public:
  AsyncCallbackMethodHandlerBaseVoid(
    const char* aUniffiMethodName,
    uint64_t aUniffiHandle,
    ForeignFutureCompletevoid aUniffiCompleteCallback,
    uint64_t aUniffiCallbackData
  )
    : AsyncCallbackMethodHandlerBase(aUniffiMethodName, aUniffiHandle),
      mUniffiCompleteCallback(aUniffiCompleteCallback),
      mUniffiCallbackData(aUniffiCallbackData) {}

private:
  ForeignFutureCompletevoid mUniffiCompleteCallback;
  uint64_t mUniffiCallbackData;

public:
  // Invoke the callback method using a JS handler
  void HandleReturn(const RootedDictionary<UniFFIScaffoldingCallResult>& aCallResult,
                    ErrorResult& aRv) override {
    if (!mUniffiCompleteCallback) {
      MOZ_ASSERT_UNREACHABLE("HandleReturn called multiple times");
      return;
    }

    ForeignFutureResultVoid result{};
    result.call_status.code = RUST_CALL_INTERNAL_ERROR;
    switch (aCallResult.mCode) {
      case UniFFIScaffoldingCallCode::Success: {
        
        result.call_status.code = RUST_CALL_SUCCESS;
        break;
      }

      case UniFFIScaffoldingCallCode::Error: {
        if (!aCallResult.mData.WasPassed()) {
          MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[AsyncCallbackMethodHandlerBaseVoid] No data passed"));
          break;
        }
        FfiValueRustBuffer errorBuf;
        errorBuf.Lower(aCallResult.mData.Value(), aRv);
        if (aRv.Failed()) {
          MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[AsyncCallbackMethodHandlerBaseVoid] Failed to lower error buffer"));
          break;
        }

        result.call_status.error_buf = errorBuf.IntoRust();
        result.call_status.code = RUST_CALL_ERROR;
        break;
      }

      default: {
        break;
      }
    }
    mUniffiCompleteCallback(mUniffiCallbackData, result);
    mUniffiCompleteCallback = nullptr;
  }

protected:
  ~AsyncCallbackMethodHandlerBaseVoid() {
    if (mUniffiCompleteCallback) {
      MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[AsyncCallbackMethodHandlerBaseVoid] promise never completed"));
      ForeignFutureResultVoid result{};
      result.call_status.code = RUST_CALL_INTERNAL_ERROR;
      mUniffiCompleteCallback(mUniffiCallbackData, result);
    }
  }
};

class AsyncCallbackMethodHandlerBaseUInt32 : public AsyncCallbackMethodHandlerBase {
public:
  AsyncCallbackMethodHandlerBaseUInt32(
    const char* aUniffiMethodName,
    uint64_t aUniffiHandle,
    ForeignFutureCompleteu32 aUniffiCompleteCallback,
    uint64_t aUniffiCallbackData
  )
    : AsyncCallbackMethodHandlerBase(aUniffiMethodName, aUniffiHandle),
      mUniffiCompleteCallback(aUniffiCompleteCallback),
      mUniffiCallbackData(aUniffiCallbackData) {}

private:
  ForeignFutureCompleteu32 mUniffiCompleteCallback;
  uint64_t mUniffiCallbackData;

public:
  // Invoke the callback method using a JS handler
  void HandleReturn(const RootedDictionary<UniFFIScaffoldingCallResult>& aCallResult,
                    ErrorResult& aRv) override {
    if (!mUniffiCompleteCallback) {
      MOZ_ASSERT_UNREACHABLE("HandleReturn called multiple times");
      return;
    }

    ForeignFutureResultU32 result{};
    result.call_status.code = RUST_CALL_INTERNAL_ERROR;
    switch (aCallResult.mCode) {
      case UniFFIScaffoldingCallCode::Success: {
        
        if (!aCallResult.mData.WasPassed()) {
          MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[AsyncCallbackMethodHandlerBaseUInt32] No data passed"));
          break;
        }
        FfiValueInt<uint32_t> returnValue;
        returnValue.Lower(aCallResult.mData.Value(), aRv);
        if (aRv.Failed()) {
          MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[AsyncCallbackMethodHandlerBaseUInt32] Failed to lower return value"));
          break;
        }

        result.return_value = returnValue.IntoRust();
        
        result.call_status.code = RUST_CALL_SUCCESS;
        break;
      }

      case UniFFIScaffoldingCallCode::Error: {
        if (!aCallResult.mData.WasPassed()) {
          MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[AsyncCallbackMethodHandlerBaseUInt32] No data passed"));
          break;
        }
        FfiValueRustBuffer errorBuf;
        errorBuf.Lower(aCallResult.mData.Value(), aRv);
        if (aRv.Failed()) {
          MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[AsyncCallbackMethodHandlerBaseUInt32] Failed to lower error buffer"));
          break;
        }

        result.call_status.error_buf = errorBuf.IntoRust();
        result.call_status.code = RUST_CALL_ERROR;
        break;
      }

      default: {
        break;
      }
    }
    mUniffiCompleteCallback(mUniffiCallbackData, result);
    mUniffiCompleteCallback = nullptr;
  }

protected:
  ~AsyncCallbackMethodHandlerBaseUInt32() {
    if (mUniffiCompleteCallback) {
      MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[AsyncCallbackMethodHandlerBaseUInt32] promise never completed"));
      ForeignFutureResultU32 result{};
      result.call_status.code = RUST_CALL_INTERNAL_ERROR;
      mUniffiCompleteCallback(mUniffiCallbackData, result);
    }
  }
};

class AsyncCallbackMethodHandlerBaseRustBuffer : public AsyncCallbackMethodHandlerBase {
public:
  AsyncCallbackMethodHandlerBaseRustBuffer(
    const char* aUniffiMethodName,
    uint64_t aUniffiHandle,
    ForeignFutureCompleterust_buffer aUniffiCompleteCallback,
    uint64_t aUniffiCallbackData
  )
    : AsyncCallbackMethodHandlerBase(aUniffiMethodName, aUniffiHandle),
      mUniffiCompleteCallback(aUniffiCompleteCallback),
      mUniffiCallbackData(aUniffiCallbackData) {}

private:
  ForeignFutureCompleterust_buffer mUniffiCompleteCallback;
  uint64_t mUniffiCallbackData;

public:
  // Invoke the callback method using a JS handler
  void HandleReturn(const RootedDictionary<UniFFIScaffoldingCallResult>& aCallResult,
                    ErrorResult& aRv) override {
    if (!mUniffiCompleteCallback) {
      MOZ_ASSERT_UNREACHABLE("HandleReturn called multiple times");
      return;
    }

    ForeignFutureResultRustBuffer result{};
    result.call_status.code = RUST_CALL_INTERNAL_ERROR;
    switch (aCallResult.mCode) {
      case UniFFIScaffoldingCallCode::Success: {
        
        if (!aCallResult.mData.WasPassed()) {
          MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[AsyncCallbackMethodHandlerBaseRustBuffer] No data passed"));
          break;
        }
        FfiValueRustBuffer returnValue;
        returnValue.Lower(aCallResult.mData.Value(), aRv);
        if (aRv.Failed()) {
          MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[AsyncCallbackMethodHandlerBaseRustBuffer] Failed to lower return value"));
          break;
        }

        result.return_value = returnValue.IntoRust();
        
        result.call_status.code = RUST_CALL_SUCCESS;
        break;
      }

      case UniFFIScaffoldingCallCode::Error: {
        if (!aCallResult.mData.WasPassed()) {
          MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[AsyncCallbackMethodHandlerBaseRustBuffer] No data passed"));
          break;
        }
        FfiValueRustBuffer errorBuf;
        errorBuf.Lower(aCallResult.mData.Value(), aRv);
        if (aRv.Failed()) {
          MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[AsyncCallbackMethodHandlerBaseRustBuffer] Failed to lower error buffer"));
          break;
        }

        result.call_status.error_buf = errorBuf.IntoRust();
        result.call_status.code = RUST_CALL_ERROR;
        break;
      }

      default: {
        break;
      }
    }
    mUniffiCompleteCallback(mUniffiCallbackData, result);
    mUniffiCompleteCallback = nullptr;
  }

protected:
  ~AsyncCallbackMethodHandlerBaseRustBuffer() {
    if (mUniffiCompleteCallback) {
      MOZ_LOG(gUniffiLogger, LogLevel::Error, ("[AsyncCallbackMethodHandlerBaseRustBuffer] promise never completed"));
      ForeignFutureResultRustBuffer result{};
      result.call_status.code = RUST_CALL_INTERNAL_ERROR;
      mUniffiCompleteCallback(mUniffiCallbackData, result);
    }
  }
};
#endif /* MOZ_UNIFFI_FIXTURES */

// Callback interface method handlers, vtables, etc.

static StaticRefPtr<dom::UniFFICallbackHandler> gUniffiCallbackHandlerContextIdContextIdCallback;

class CallbackInterfaceMethodContextIdContextIdCallbackPersist final : public AsyncCallbackMethodHandlerBase {
private:
  // Rust arguments
  FfiValueRustBuffer mContextId{};
  FfiValueInt<int64_t> mCreationDate{};

public:
  CallbackInterfaceMethodContextIdContextIdCallbackPersist(
      uint64_t aUniffiHandle,
      RustBuffer aContextId,
      int64_t aCreationDate)
    : AsyncCallbackMethodHandlerBase(
        "ContextIdCallback.callback_interface_context_id_context_id_callback_persist",
        aUniffiHandle
    ), mContextId(FfiValueRustBuffer::FromRust(aContextId)), mCreationDate(FfiValueInt<int64_t>::FromRust(aCreationDate))
  {
  }

  MOZ_CAN_RUN_SCRIPT
  already_AddRefed<dom::Promise>
  MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;

    // Setup
    if (!uniffiArgs.AppendElements(2, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return nullptr;
    }

    // Convert each argument
    mContextId.Lift(
      aCx,
      &uniffiArgs[0],
      aError);
    if (aError.Failed()) {
      return nullptr;
    }
    mCreationDate.Lift(
      aCx,
      &uniffiArgs[1],
      aError);
    if (aError.Failed()) {
      return nullptr;
    }

    RefPtr<dom::Promise> result = aJsHandler->CallAsync(mUniffiHandle.IntoRust(), 0, uniffiArgs, aError);
    
    return nullptr;
  }
};


// Sync callback methods are always wrapped to be fire-and-forget style async callbacks.  This means
// we schedule the callback asynchronously and ignore the return value and any exceptions thrown.
extern "C" void callback_interface_context_id_context_id_callback_persist(
  uint64_t aUniffiHandle,
  RustBuffer aContextId,
  int64_t aCreationDate,
  void* aUniffiOutReturn,
  RustCallStatus* uniffiOutStatus
) {
  UniquePtr<AsyncCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodContextIdContextIdCallbackPersist>(aUniffiHandle, aContextId, aCreationDate);
  AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(std::move(handler), &gUniffiCallbackHandlerContextIdContextIdCallback);
}


class CallbackInterfaceMethodContextIdContextIdCallbackRotated final : public AsyncCallbackMethodHandlerBase {
private:
  // Rust arguments
  FfiValueRustBuffer mOldContextId{};

public:
  CallbackInterfaceMethodContextIdContextIdCallbackRotated(
      uint64_t aUniffiHandle,
      RustBuffer aOldContextId)
    : AsyncCallbackMethodHandlerBase(
        "ContextIdCallback.callback_interface_context_id_context_id_callback_rotated",
        aUniffiHandle
    ), mOldContextId(FfiValueRustBuffer::FromRust(aOldContextId))
  {
  }

  MOZ_CAN_RUN_SCRIPT
  already_AddRefed<dom::Promise>
  MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;

    // Setup
    if (!uniffiArgs.AppendElements(1, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return nullptr;
    }

    // Convert each argument
    mOldContextId.Lift(
      aCx,
      &uniffiArgs[0],
      aError);
    if (aError.Failed()) {
      return nullptr;
    }

    RefPtr<dom::Promise> result = aJsHandler->CallAsync(mUniffiHandle.IntoRust(), 1, uniffiArgs, aError);
    
    return nullptr;
  }
};


// Sync callback methods are always wrapped to be fire-and-forget style async callbacks.  This means
// we schedule the callback asynchronously and ignore the return value and any exceptions thrown.
extern "C" void callback_interface_context_id_context_id_callback_rotated(
  uint64_t aUniffiHandle,
  RustBuffer aOldContextId,
  void* aUniffiOutReturn,
  RustCallStatus* uniffiOutStatus
) {
  UniquePtr<AsyncCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodContextIdContextIdCallbackRotated>(aUniffiHandle, aOldContextId);
  AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(std::move(handler), &gUniffiCallbackHandlerContextIdContextIdCallback);
}


extern "C" void callback_free_context_id_context_id_callback(uint64_t uniffiHandle) {
   // Callback object handles are keys in a map stored in the JS handler. To
   // handle the free call, schedule a fire-and-forget JS call to remove the key.
   AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(
      MakeUnique<CallbackFreeHandler>("ContextIdCallback.uniffi_free", uniffiHandle),
      &gUniffiCallbackHandlerContextIdContextIdCallback);
}

static VTableCallbackInterfaceContextIdContextIdCallback kUniffiVtableContextIdContextIdCallback {
  callback_interface_context_id_context_id_callback_persist,
  callback_interface_context_id_context_id_callback_rotated,
  callback_free_context_id_context_id_callback
};
static StaticRefPtr<dom::UniFFICallbackHandler> gUniffiCallbackHandlerErrorsupportApplicationErrorReporter;

class CallbackInterfaceMethodErrorsupportApplicationErrorReporterReportError final : public AsyncCallbackMethodHandlerBase {
private:
  // Rust arguments
  FfiValueRustBuffer mTypeName{};
  FfiValueRustBuffer mMessage{};

public:
  CallbackInterfaceMethodErrorsupportApplicationErrorReporterReportError(
      uint64_t aUniffiHandle,
      RustBuffer aTypeName,
      RustBuffer aMessage)
    : AsyncCallbackMethodHandlerBase(
        "ApplicationErrorReporter.callback_interface_errorsupport_application_error_reporter_report_error",
        aUniffiHandle
    ), mTypeName(FfiValueRustBuffer::FromRust(aTypeName)), mMessage(FfiValueRustBuffer::FromRust(aMessage))
  {
  }

  MOZ_CAN_RUN_SCRIPT
  already_AddRefed<dom::Promise>
  MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;

    // Setup
    if (!uniffiArgs.AppendElements(2, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return nullptr;
    }

    // Convert each argument
    mTypeName.Lift(
      aCx,
      &uniffiArgs[0],
      aError);
    if (aError.Failed()) {
      return nullptr;
    }
    mMessage.Lift(
      aCx,
      &uniffiArgs[1],
      aError);
    if (aError.Failed()) {
      return nullptr;
    }

    RefPtr<dom::Promise> result = aJsHandler->CallAsync(mUniffiHandle.IntoRust(), 0, uniffiArgs, aError);
    
    return nullptr;
  }
};


// Sync callback methods are always wrapped to be fire-and-forget style async callbacks.  This means
// we schedule the callback asynchronously and ignore the return value and any exceptions thrown.
extern "C" void callback_interface_errorsupport_application_error_reporter_report_error(
  uint64_t aUniffiHandle,
  RustBuffer aTypeName,
  RustBuffer aMessage,
  void* aUniffiOutReturn,
  RustCallStatus* uniffiOutStatus
) {
  UniquePtr<AsyncCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodErrorsupportApplicationErrorReporterReportError>(aUniffiHandle, aTypeName, aMessage);
  AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(std::move(handler), &gUniffiCallbackHandlerErrorsupportApplicationErrorReporter);
}


class CallbackInterfaceMethodErrorsupportApplicationErrorReporterReportBreadcrumb final : public AsyncCallbackMethodHandlerBase {
private:
  // Rust arguments
  FfiValueRustBuffer mMessage{};
  FfiValueRustBuffer mModule{};
  FfiValueInt<uint32_t> mLine{};
  FfiValueInt<uint32_t> mColumn{};

public:
  CallbackInterfaceMethodErrorsupportApplicationErrorReporterReportBreadcrumb(
      uint64_t aUniffiHandle,
      RustBuffer aMessage,
      RustBuffer aModule,
      uint32_t aLine,
      uint32_t aColumn)
    : AsyncCallbackMethodHandlerBase(
        "ApplicationErrorReporter.callback_interface_errorsupport_application_error_reporter_report_breadcrumb",
        aUniffiHandle
    ), mMessage(FfiValueRustBuffer::FromRust(aMessage)), mModule(FfiValueRustBuffer::FromRust(aModule)), mLine(FfiValueInt<uint32_t>::FromRust(aLine)), mColumn(FfiValueInt<uint32_t>::FromRust(aColumn))
  {
  }

  MOZ_CAN_RUN_SCRIPT
  already_AddRefed<dom::Promise>
  MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;

    // Setup
    if (!uniffiArgs.AppendElements(4, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return nullptr;
    }

    // Convert each argument
    mMessage.Lift(
      aCx,
      &uniffiArgs[0],
      aError);
    if (aError.Failed()) {
      return nullptr;
    }
    mModule.Lift(
      aCx,
      &uniffiArgs[1],
      aError);
    if (aError.Failed()) {
      return nullptr;
    }
    mLine.Lift(
      aCx,
      &uniffiArgs[2],
      aError);
    if (aError.Failed()) {
      return nullptr;
    }
    mColumn.Lift(
      aCx,
      &uniffiArgs[3],
      aError);
    if (aError.Failed()) {
      return nullptr;
    }

    RefPtr<dom::Promise> result = aJsHandler->CallAsync(mUniffiHandle.IntoRust(), 1, uniffiArgs, aError);
    
    return nullptr;
  }
};


// Sync callback methods are always wrapped to be fire-and-forget style async callbacks.  This means
// we schedule the callback asynchronously and ignore the return value and any exceptions thrown.
extern "C" void callback_interface_errorsupport_application_error_reporter_report_breadcrumb(
  uint64_t aUniffiHandle,
  RustBuffer aMessage,
  RustBuffer aModule,
  uint32_t aLine,
  uint32_t aColumn,
  void* aUniffiOutReturn,
  RustCallStatus* uniffiOutStatus
) {
  UniquePtr<AsyncCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodErrorsupportApplicationErrorReporterReportBreadcrumb>(aUniffiHandle, aMessage, aModule, aLine, aColumn);
  AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(std::move(handler), &gUniffiCallbackHandlerErrorsupportApplicationErrorReporter);
}


extern "C" void callback_free_errorsupport_application_error_reporter(uint64_t uniffiHandle) {
   // Callback object handles are keys in a map stored in the JS handler. To
   // handle the free call, schedule a fire-and-forget JS call to remove the key.
   AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(
      MakeUnique<CallbackFreeHandler>("ApplicationErrorReporter.uniffi_free", uniffiHandle),
      &gUniffiCallbackHandlerErrorsupportApplicationErrorReporter);
}

static VTableCallbackInterfaceErrorsupportApplicationErrorReporter kUniffiVtableErrorsupportApplicationErrorReporter {
  callback_interface_errorsupport_application_error_reporter_report_error,
  callback_interface_errorsupport_application_error_reporter_report_breadcrumb,
  callback_free_errorsupport_application_error_reporter
};

#ifdef MOZ_UNIFFI_FIXTURES
static StaticRefPtr<dom::UniFFICallbackHandler> gUniffiCallbackHandlerUniffiBindingsTestsTestAsyncCallbackInterface;

class CallbackInterfaceMethodUniffiBindingsTestsTestAsyncCallbackInterfaceNoop final : public AsyncCallbackMethodHandlerBaseVoid {
private:
  // Rust arguments

public:
  CallbackInterfaceMethodUniffiBindingsTestsTestAsyncCallbackInterfaceNoop(
      uint64_t aUniffiHandle,
      ForeignFutureCompletevoid aUniffiCompleteCallback,
      uint64_t aUniffiCallbackData)
    : AsyncCallbackMethodHandlerBaseVoid(
        "TestAsyncCallbackInterface.callback_interface_uniffi_bindings_tests_test_async_callback_interface_noop",
        aUniffiHandle,
        aUniffiCompleteCallback,
        aUniffiCallbackData
    )
  {
  }

  MOZ_CAN_RUN_SCRIPT
  already_AddRefed<dom::Promise>
  MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;

    // Setup
    if (!uniffiArgs.AppendElements(0, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return nullptr;
    }

    // Convert each argument

    RefPtr<dom::Promise> result = aJsHandler->CallAsync(mUniffiHandle.IntoRust(), 0, uniffiArgs, aError);
    return result.forget();
  }
};

extern "C" void callback_interface_uniffi_bindings_tests_test_async_callback_interface_noop(
  uint64_t aUniffiHandle,
  ForeignFutureCompletevoid aUniffiForeignFutureCallback,
  uint64_t aUniffiForeignFutureCallbackData,
  // This can be used to detected when the future is dropped from the Rust side and cancel the
  // async task on the foreign side.  However, there's no way to do that in JS, so we just ignore
  // it.
  ForeignFuture *aUniffiOutForeignFuture
) {
  UniquePtr<AsyncCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodUniffiBindingsTestsTestAsyncCallbackInterfaceNoop>(
        aUniffiHandle,
        aUniffiForeignFutureCallback,
        aUniffiForeignFutureCallbackData);
  // Now that everything is set up, schedule the call in the JS main thread.
  AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(std::move(handler), &gUniffiCallbackHandlerUniffiBindingsTestsTestAsyncCallbackInterface);
}

class CallbackInterfaceMethodUniffiBindingsTestsTestAsyncCallbackInterfaceGetValue final : public AsyncCallbackMethodHandlerBaseUInt32 {
private:
  // Rust arguments

public:
  CallbackInterfaceMethodUniffiBindingsTestsTestAsyncCallbackInterfaceGetValue(
      uint64_t aUniffiHandle,
      ForeignFutureCompleteu32 aUniffiCompleteCallback,
      uint64_t aUniffiCallbackData)
    : AsyncCallbackMethodHandlerBaseUInt32(
        "TestAsyncCallbackInterface.callback_interface_uniffi_bindings_tests_test_async_callback_interface_get_value",
        aUniffiHandle,
        aUniffiCompleteCallback,
        aUniffiCallbackData
    )
  {
  }

  MOZ_CAN_RUN_SCRIPT
  already_AddRefed<dom::Promise>
  MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;

    // Setup
    if (!uniffiArgs.AppendElements(0, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return nullptr;
    }

    // Convert each argument

    RefPtr<dom::Promise> result = aJsHandler->CallAsync(mUniffiHandle.IntoRust(), 1, uniffiArgs, aError);
    return result.forget();
  }
};

extern "C" void callback_interface_uniffi_bindings_tests_test_async_callback_interface_get_value(
  uint64_t aUniffiHandle,
  ForeignFutureCompleteu32 aUniffiForeignFutureCallback,
  uint64_t aUniffiForeignFutureCallbackData,
  // This can be used to detected when the future is dropped from the Rust side and cancel the
  // async task on the foreign side.  However, there's no way to do that in JS, so we just ignore
  // it.
  ForeignFuture *aUniffiOutForeignFuture
) {
  UniquePtr<AsyncCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodUniffiBindingsTestsTestAsyncCallbackInterfaceGetValue>(
        aUniffiHandle,
        aUniffiForeignFutureCallback,
        aUniffiForeignFutureCallbackData);
  // Now that everything is set up, schedule the call in the JS main thread.
  AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(std::move(handler), &gUniffiCallbackHandlerUniffiBindingsTestsTestAsyncCallbackInterface);
}

class CallbackInterfaceMethodUniffiBindingsTestsTestAsyncCallbackInterfaceSetValue final : public AsyncCallbackMethodHandlerBaseVoid {
private:
  // Rust arguments
  FfiValueInt<uint32_t> mValue{};

public:
  CallbackInterfaceMethodUniffiBindingsTestsTestAsyncCallbackInterfaceSetValue(
      uint64_t aUniffiHandle,
      uint32_t aValue,
      ForeignFutureCompletevoid aUniffiCompleteCallback,
      uint64_t aUniffiCallbackData)
    : AsyncCallbackMethodHandlerBaseVoid(
        "TestAsyncCallbackInterface.callback_interface_uniffi_bindings_tests_test_async_callback_interface_set_value",
        aUniffiHandle,
        aUniffiCompleteCallback,
        aUniffiCallbackData
    ), mValue(FfiValueInt<uint32_t>::FromRust(aValue))
  {
  }

  MOZ_CAN_RUN_SCRIPT
  already_AddRefed<dom::Promise>
  MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;

    // Setup
    if (!uniffiArgs.AppendElements(1, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return nullptr;
    }

    // Convert each argument
    mValue.Lift(
      aCx,
      &uniffiArgs[0],
      aError);
    if (aError.Failed()) {
      return nullptr;
    }

    RefPtr<dom::Promise> result = aJsHandler->CallAsync(mUniffiHandle.IntoRust(), 2, uniffiArgs, aError);
    return result.forget();
  }
};

extern "C" void callback_interface_uniffi_bindings_tests_test_async_callback_interface_set_value(
  uint64_t aUniffiHandle,
  uint32_t aValue,
  ForeignFutureCompletevoid aUniffiForeignFutureCallback,
  uint64_t aUniffiForeignFutureCallbackData,
  // This can be used to detected when the future is dropped from the Rust side and cancel the
  // async task on the foreign side.  However, there's no way to do that in JS, so we just ignore
  // it.
  ForeignFuture *aUniffiOutForeignFuture
) {
  UniquePtr<AsyncCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodUniffiBindingsTestsTestAsyncCallbackInterfaceSetValue>(
        aUniffiHandle,
        aValue,
        aUniffiForeignFutureCallback,
        aUniffiForeignFutureCallbackData);
  // Now that everything is set up, schedule the call in the JS main thread.
  AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(std::move(handler), &gUniffiCallbackHandlerUniffiBindingsTestsTestAsyncCallbackInterface);
}

class CallbackInterfaceMethodUniffiBindingsTestsTestAsyncCallbackInterfaceThrowIfEqual final : public AsyncCallbackMethodHandlerBaseRustBuffer {
private:
  // Rust arguments
  FfiValueRustBuffer mNumbers{};

public:
  CallbackInterfaceMethodUniffiBindingsTestsTestAsyncCallbackInterfaceThrowIfEqual(
      uint64_t aUniffiHandle,
      RustBuffer aNumbers,
      ForeignFutureCompleterust_buffer aUniffiCompleteCallback,
      uint64_t aUniffiCallbackData)
    : AsyncCallbackMethodHandlerBaseRustBuffer(
        "TestAsyncCallbackInterface.callback_interface_uniffi_bindings_tests_test_async_callback_interface_throw_if_equal",
        aUniffiHandle,
        aUniffiCompleteCallback,
        aUniffiCallbackData
    ), mNumbers(FfiValueRustBuffer::FromRust(aNumbers))
  {
  }

  MOZ_CAN_RUN_SCRIPT
  already_AddRefed<dom::Promise>
  MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;

    // Setup
    if (!uniffiArgs.AppendElements(1, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return nullptr;
    }

    // Convert each argument
    mNumbers.Lift(
      aCx,
      &uniffiArgs[0],
      aError);
    if (aError.Failed()) {
      return nullptr;
    }

    RefPtr<dom::Promise> result = aJsHandler->CallAsync(mUniffiHandle.IntoRust(), 3, uniffiArgs, aError);
    return result.forget();
  }
};

extern "C" void callback_interface_uniffi_bindings_tests_test_async_callback_interface_throw_if_equal(
  uint64_t aUniffiHandle,
  RustBuffer aNumbers,
  ForeignFutureCompleterust_buffer aUniffiForeignFutureCallback,
  uint64_t aUniffiForeignFutureCallbackData,
  // This can be used to detected when the future is dropped from the Rust side and cancel the
  // async task on the foreign side.  However, there's no way to do that in JS, so we just ignore
  // it.
  ForeignFuture *aUniffiOutForeignFuture
) {
  UniquePtr<AsyncCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodUniffiBindingsTestsTestAsyncCallbackInterfaceThrowIfEqual>(
        aUniffiHandle,
        aNumbers,
        aUniffiForeignFutureCallback,
        aUniffiForeignFutureCallbackData);
  // Now that everything is set up, schedule the call in the JS main thread.
  AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(std::move(handler), &gUniffiCallbackHandlerUniffiBindingsTestsTestAsyncCallbackInterface);
}

extern "C" void callback_free_uniffi_bindings_tests_test_async_callback_interface(uint64_t uniffiHandle) {
   // Callback object handles are keys in a map stored in the JS handler. To
   // handle the free call, schedule a fire-and-forget JS call to remove the key.
   AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(
      MakeUnique<CallbackFreeHandler>("TestAsyncCallbackInterface.uniffi_free", uniffiHandle),
      &gUniffiCallbackHandlerUniffiBindingsTestsTestAsyncCallbackInterface);
}

static VTableCallbackInterfaceUniffiBindingsTestsTestAsyncCallbackInterface kUniffiVtableUniffiBindingsTestsTestAsyncCallbackInterface {
  callback_interface_uniffi_bindings_tests_test_async_callback_interface_noop,
  callback_interface_uniffi_bindings_tests_test_async_callback_interface_get_value,
  callback_interface_uniffi_bindings_tests_test_async_callback_interface_set_value,
  callback_interface_uniffi_bindings_tests_test_async_callback_interface_throw_if_equal,
  callback_free_uniffi_bindings_tests_test_async_callback_interface
};
static StaticRefPtr<dom::UniFFICallbackHandler> gUniffiCallbackHandlerUniffiBindingsTestsTestCallbackInterface;

class CallbackInterfaceMethodUniffiBindingsTestsTestCallbackInterfaceNoop final : public AsyncCallbackMethodHandlerBase {
private:
  // Rust arguments

public:
  CallbackInterfaceMethodUniffiBindingsTestsTestCallbackInterfaceNoop(
      uint64_t aUniffiHandle)
    : AsyncCallbackMethodHandlerBase(
        "TestCallbackInterface.callback_interface_uniffi_bindings_tests_test_callback_interface_noop",
        aUniffiHandle
    )
  {
  }

  MOZ_CAN_RUN_SCRIPT
  already_AddRefed<dom::Promise>
  MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;

    // Setup
    if (!uniffiArgs.AppendElements(0, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return nullptr;
    }

    // Convert each argument

    RefPtr<dom::Promise> result = aJsHandler->CallAsync(mUniffiHandle.IntoRust(), 0, uniffiArgs, aError);
    
    return nullptr;
  }
};


// Sync callback methods are always wrapped to be fire-and-forget style async callbacks.  This means
// we schedule the callback asynchronously and ignore the return value and any exceptions thrown.
extern "C" void callback_interface_uniffi_bindings_tests_test_callback_interface_noop(
  uint64_t aUniffiHandle,
  void* aUniffiOutReturn,
  RustCallStatus* uniffiOutStatus
) {
  UniquePtr<AsyncCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodUniffiBindingsTestsTestCallbackInterfaceNoop>(aUniffiHandle);
  AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(std::move(handler), &gUniffiCallbackHandlerUniffiBindingsTestsTestCallbackInterface);
}


class CallbackInterfaceMethodUniffiBindingsTestsTestCallbackInterfaceGetValue final : public AsyncCallbackMethodHandlerBase {
private:
  // Rust arguments

public:
  CallbackInterfaceMethodUniffiBindingsTestsTestCallbackInterfaceGetValue(
      uint64_t aUniffiHandle)
    : AsyncCallbackMethodHandlerBase(
        "TestCallbackInterface.callback_interface_uniffi_bindings_tests_test_callback_interface_get_value",
        aUniffiHandle
    )
  {
  }

  MOZ_CAN_RUN_SCRIPT
  already_AddRefed<dom::Promise>
  MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;

    // Setup
    if (!uniffiArgs.AppendElements(0, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return nullptr;
    }

    // Convert each argument

    RefPtr<dom::Promise> result = aJsHandler->CallAsync(mUniffiHandle.IntoRust(), 1, uniffiArgs, aError);
    
    return nullptr;
  }
};


// Sync callback methods are always wrapped to be fire-and-forget style async callbacks.  This means
// we schedule the callback asynchronously and ignore the return value and any exceptions thrown.
extern "C" void callback_interface_uniffi_bindings_tests_test_callback_interface_get_value(
  uint64_t aUniffiHandle,
  uint32_t* aUniffiOutReturn,
  RustCallStatus* uniffiOutStatus
) {
  UniquePtr<AsyncCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodUniffiBindingsTestsTestCallbackInterfaceGetValue>(aUniffiHandle);
  AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(std::move(handler), &gUniffiCallbackHandlerUniffiBindingsTestsTestCallbackInterface);
}


class CallbackInterfaceMethodUniffiBindingsTestsTestCallbackInterfaceSetValue final : public AsyncCallbackMethodHandlerBase {
private:
  // Rust arguments
  FfiValueInt<uint32_t> mValue{};

public:
  CallbackInterfaceMethodUniffiBindingsTestsTestCallbackInterfaceSetValue(
      uint64_t aUniffiHandle,
      uint32_t aValue)
    : AsyncCallbackMethodHandlerBase(
        "TestCallbackInterface.callback_interface_uniffi_bindings_tests_test_callback_interface_set_value",
        aUniffiHandle
    ), mValue(FfiValueInt<uint32_t>::FromRust(aValue))
  {
  }

  MOZ_CAN_RUN_SCRIPT
  already_AddRefed<dom::Promise>
  MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;

    // Setup
    if (!uniffiArgs.AppendElements(1, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return nullptr;
    }

    // Convert each argument
    mValue.Lift(
      aCx,
      &uniffiArgs[0],
      aError);
    if (aError.Failed()) {
      return nullptr;
    }

    RefPtr<dom::Promise> result = aJsHandler->CallAsync(mUniffiHandle.IntoRust(), 2, uniffiArgs, aError);
    
    return nullptr;
  }
};


// Sync callback methods are always wrapped to be fire-and-forget style async callbacks.  This means
// we schedule the callback asynchronously and ignore the return value and any exceptions thrown.
extern "C" void callback_interface_uniffi_bindings_tests_test_callback_interface_set_value(
  uint64_t aUniffiHandle,
  uint32_t aValue,
  void* aUniffiOutReturn,
  RustCallStatus* uniffiOutStatus
) {
  UniquePtr<AsyncCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodUniffiBindingsTestsTestCallbackInterfaceSetValue>(aUniffiHandle, aValue);
  AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(std::move(handler), &gUniffiCallbackHandlerUniffiBindingsTestsTestCallbackInterface);
}


class CallbackInterfaceMethodUniffiBindingsTestsTestCallbackInterfaceThrowIfEqual final : public AsyncCallbackMethodHandlerBase {
private:
  // Rust arguments
  FfiValueRustBuffer mNumbers{};

public:
  CallbackInterfaceMethodUniffiBindingsTestsTestCallbackInterfaceThrowIfEqual(
      uint64_t aUniffiHandle,
      RustBuffer aNumbers)
    : AsyncCallbackMethodHandlerBase(
        "TestCallbackInterface.callback_interface_uniffi_bindings_tests_test_callback_interface_throw_if_equal",
        aUniffiHandle
    ), mNumbers(FfiValueRustBuffer::FromRust(aNumbers))
  {
  }

  MOZ_CAN_RUN_SCRIPT
  already_AddRefed<dom::Promise>
  MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;

    // Setup
    if (!uniffiArgs.AppendElements(1, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return nullptr;
    }

    // Convert each argument
    mNumbers.Lift(
      aCx,
      &uniffiArgs[0],
      aError);
    if (aError.Failed()) {
      return nullptr;
    }

    RefPtr<dom::Promise> result = aJsHandler->CallAsync(mUniffiHandle.IntoRust(), 3, uniffiArgs, aError);
    
    return nullptr;
  }
};


// Sync callback methods are always wrapped to be fire-and-forget style async callbacks.  This means
// we schedule the callback asynchronously and ignore the return value and any exceptions thrown.
extern "C" void callback_interface_uniffi_bindings_tests_test_callback_interface_throw_if_equal(
  uint64_t aUniffiHandle,
  RustBuffer aNumbers,
  RustBuffer* aUniffiOutReturn,
  RustCallStatus* uniffiOutStatus
) {
  UniquePtr<AsyncCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodUniffiBindingsTestsTestCallbackInterfaceThrowIfEqual>(aUniffiHandle, aNumbers);
  AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(std::move(handler), &gUniffiCallbackHandlerUniffiBindingsTestsTestCallbackInterface);
}


extern "C" void callback_free_uniffi_bindings_tests_test_callback_interface(uint64_t uniffiHandle) {
   // Callback object handles are keys in a map stored in the JS handler. To
   // handle the free call, schedule a fire-and-forget JS call to remove the key.
   AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(
      MakeUnique<CallbackFreeHandler>("TestCallbackInterface.uniffi_free", uniffiHandle),
      &gUniffiCallbackHandlerUniffiBindingsTestsTestCallbackInterface);
}

static VTableCallbackInterfaceUniffiBindingsTestsTestCallbackInterface kUniffiVtableUniffiBindingsTestsTestCallbackInterface {
  callback_interface_uniffi_bindings_tests_test_callback_interface_noop,
  callback_interface_uniffi_bindings_tests_test_callback_interface_get_value,
  callback_interface_uniffi_bindings_tests_test_callback_interface_set_value,
  callback_interface_uniffi_bindings_tests_test_callback_interface_throw_if_equal,
  callback_free_uniffi_bindings_tests_test_callback_interface
};
static StaticRefPtr<dom::UniFFICallbackHandler> gUniffiCallbackHandlerUniffiBindingsTestsAsyncTestTraitInterface;

class CallbackInterfaceMethodUniffiBindingsTestsAsyncTestTraitInterfaceNoop final : public AsyncCallbackMethodHandlerBaseVoid {
private:
  // Rust arguments

public:
  CallbackInterfaceMethodUniffiBindingsTestsAsyncTestTraitInterfaceNoop(
      uint64_t aUniffiHandle,
      ForeignFutureCompletevoid aUniffiCompleteCallback,
      uint64_t aUniffiCallbackData)
    : AsyncCallbackMethodHandlerBaseVoid(
        "AsyncTestTraitInterface.callback_interface_uniffi_bindings_tests_async_test_trait_interface_noop",
        aUniffiHandle,
        aUniffiCompleteCallback,
        aUniffiCallbackData
    )
  {
  }

  MOZ_CAN_RUN_SCRIPT
  already_AddRefed<dom::Promise>
  MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;

    // Setup
    if (!uniffiArgs.AppendElements(0, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return nullptr;
    }

    // Convert each argument

    RefPtr<dom::Promise> result = aJsHandler->CallAsync(mUniffiHandle.IntoRust(), 0, uniffiArgs, aError);
    return result.forget();
  }
};

extern "C" void callback_interface_uniffi_bindings_tests_async_test_trait_interface_noop(
  uint64_t aUniffiHandle,
  ForeignFutureCompletevoid aUniffiForeignFutureCallback,
  uint64_t aUniffiForeignFutureCallbackData,
  // This can be used to detected when the future is dropped from the Rust side and cancel the
  // async task on the foreign side.  However, there's no way to do that in JS, so we just ignore
  // it.
  ForeignFuture *aUniffiOutForeignFuture
) {
  UniquePtr<AsyncCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodUniffiBindingsTestsAsyncTestTraitInterfaceNoop>(
        aUniffiHandle,
        aUniffiForeignFutureCallback,
        aUniffiForeignFutureCallbackData);
  // Now that everything is set up, schedule the call in the JS main thread.
  AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(std::move(handler), &gUniffiCallbackHandlerUniffiBindingsTestsAsyncTestTraitInterface);
}

class CallbackInterfaceMethodUniffiBindingsTestsAsyncTestTraitInterfaceGetValue final : public AsyncCallbackMethodHandlerBaseUInt32 {
private:
  // Rust arguments

public:
  CallbackInterfaceMethodUniffiBindingsTestsAsyncTestTraitInterfaceGetValue(
      uint64_t aUniffiHandle,
      ForeignFutureCompleteu32 aUniffiCompleteCallback,
      uint64_t aUniffiCallbackData)
    : AsyncCallbackMethodHandlerBaseUInt32(
        "AsyncTestTraitInterface.callback_interface_uniffi_bindings_tests_async_test_trait_interface_get_value",
        aUniffiHandle,
        aUniffiCompleteCallback,
        aUniffiCallbackData
    )
  {
  }

  MOZ_CAN_RUN_SCRIPT
  already_AddRefed<dom::Promise>
  MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;

    // Setup
    if (!uniffiArgs.AppendElements(0, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return nullptr;
    }

    // Convert each argument

    RefPtr<dom::Promise> result = aJsHandler->CallAsync(mUniffiHandle.IntoRust(), 1, uniffiArgs, aError);
    return result.forget();
  }
};

extern "C" void callback_interface_uniffi_bindings_tests_async_test_trait_interface_get_value(
  uint64_t aUniffiHandle,
  ForeignFutureCompleteu32 aUniffiForeignFutureCallback,
  uint64_t aUniffiForeignFutureCallbackData,
  // This can be used to detected when the future is dropped from the Rust side and cancel the
  // async task on the foreign side.  However, there's no way to do that in JS, so we just ignore
  // it.
  ForeignFuture *aUniffiOutForeignFuture
) {
  UniquePtr<AsyncCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodUniffiBindingsTestsAsyncTestTraitInterfaceGetValue>(
        aUniffiHandle,
        aUniffiForeignFutureCallback,
        aUniffiForeignFutureCallbackData);
  // Now that everything is set up, schedule the call in the JS main thread.
  AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(std::move(handler), &gUniffiCallbackHandlerUniffiBindingsTestsAsyncTestTraitInterface);
}

class CallbackInterfaceMethodUniffiBindingsTestsAsyncTestTraitInterfaceSetValue final : public AsyncCallbackMethodHandlerBaseVoid {
private:
  // Rust arguments
  FfiValueInt<uint32_t> mValue{};

public:
  CallbackInterfaceMethodUniffiBindingsTestsAsyncTestTraitInterfaceSetValue(
      uint64_t aUniffiHandle,
      uint32_t aValue,
      ForeignFutureCompletevoid aUniffiCompleteCallback,
      uint64_t aUniffiCallbackData)
    : AsyncCallbackMethodHandlerBaseVoid(
        "AsyncTestTraitInterface.callback_interface_uniffi_bindings_tests_async_test_trait_interface_set_value",
        aUniffiHandle,
        aUniffiCompleteCallback,
        aUniffiCallbackData
    ), mValue(FfiValueInt<uint32_t>::FromRust(aValue))
  {
  }

  MOZ_CAN_RUN_SCRIPT
  already_AddRefed<dom::Promise>
  MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;

    // Setup
    if (!uniffiArgs.AppendElements(1, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return nullptr;
    }

    // Convert each argument
    mValue.Lift(
      aCx,
      &uniffiArgs[0],
      aError);
    if (aError.Failed()) {
      return nullptr;
    }

    RefPtr<dom::Promise> result = aJsHandler->CallAsync(mUniffiHandle.IntoRust(), 2, uniffiArgs, aError);
    return result.forget();
  }
};

extern "C" void callback_interface_uniffi_bindings_tests_async_test_trait_interface_set_value(
  uint64_t aUniffiHandle,
  uint32_t aValue,
  ForeignFutureCompletevoid aUniffiForeignFutureCallback,
  uint64_t aUniffiForeignFutureCallbackData,
  // This can be used to detected when the future is dropped from the Rust side and cancel the
  // async task on the foreign side.  However, there's no way to do that in JS, so we just ignore
  // it.
  ForeignFuture *aUniffiOutForeignFuture
) {
  UniquePtr<AsyncCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodUniffiBindingsTestsAsyncTestTraitInterfaceSetValue>(
        aUniffiHandle,
        aValue,
        aUniffiForeignFutureCallback,
        aUniffiForeignFutureCallbackData);
  // Now that everything is set up, schedule the call in the JS main thread.
  AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(std::move(handler), &gUniffiCallbackHandlerUniffiBindingsTestsAsyncTestTraitInterface);
}

class CallbackInterfaceMethodUniffiBindingsTestsAsyncTestTraitInterfaceThrowIfEqual final : public AsyncCallbackMethodHandlerBaseRustBuffer {
private:
  // Rust arguments
  FfiValueRustBuffer mNumbers{};

public:
  CallbackInterfaceMethodUniffiBindingsTestsAsyncTestTraitInterfaceThrowIfEqual(
      uint64_t aUniffiHandle,
      RustBuffer aNumbers,
      ForeignFutureCompleterust_buffer aUniffiCompleteCallback,
      uint64_t aUniffiCallbackData)
    : AsyncCallbackMethodHandlerBaseRustBuffer(
        "AsyncTestTraitInterface.callback_interface_uniffi_bindings_tests_async_test_trait_interface_throw_if_equal",
        aUniffiHandle,
        aUniffiCompleteCallback,
        aUniffiCallbackData
    ), mNumbers(FfiValueRustBuffer::FromRust(aNumbers))
  {
  }

  MOZ_CAN_RUN_SCRIPT
  already_AddRefed<dom::Promise>
  MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;

    // Setup
    if (!uniffiArgs.AppendElements(1, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return nullptr;
    }

    // Convert each argument
    mNumbers.Lift(
      aCx,
      &uniffiArgs[0],
      aError);
    if (aError.Failed()) {
      return nullptr;
    }

    RefPtr<dom::Promise> result = aJsHandler->CallAsync(mUniffiHandle.IntoRust(), 3, uniffiArgs, aError);
    return result.forget();
  }
};

extern "C" void callback_interface_uniffi_bindings_tests_async_test_trait_interface_throw_if_equal(
  uint64_t aUniffiHandle,
  RustBuffer aNumbers,
  ForeignFutureCompleterust_buffer aUniffiForeignFutureCallback,
  uint64_t aUniffiForeignFutureCallbackData,
  // This can be used to detected when the future is dropped from the Rust side and cancel the
  // async task on the foreign side.  However, there's no way to do that in JS, so we just ignore
  // it.
  ForeignFuture *aUniffiOutForeignFuture
) {
  UniquePtr<AsyncCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodUniffiBindingsTestsAsyncTestTraitInterfaceThrowIfEqual>(
        aUniffiHandle,
        aNumbers,
        aUniffiForeignFutureCallback,
        aUniffiForeignFutureCallbackData);
  // Now that everything is set up, schedule the call in the JS main thread.
  AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(std::move(handler), &gUniffiCallbackHandlerUniffiBindingsTestsAsyncTestTraitInterface);
}

extern "C" void callback_free_uniffi_bindings_tests_async_test_trait_interface(uint64_t uniffiHandle) {
   // Callback object handles are keys in a map stored in the JS handler. To
   // handle the free call, schedule a fire-and-forget JS call to remove the key.
   AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(
      MakeUnique<CallbackFreeHandler>("AsyncTestTraitInterface.uniffi_free", uniffiHandle),
      &gUniffiCallbackHandlerUniffiBindingsTestsAsyncTestTraitInterface);
}

static VTableCallbackInterfaceUniffiBindingsTestsAsyncTestTraitInterface kUniffiVtableUniffiBindingsTestsAsyncTestTraitInterface {
  callback_interface_uniffi_bindings_tests_async_test_trait_interface_noop,
  callback_interface_uniffi_bindings_tests_async_test_trait_interface_get_value,
  callback_interface_uniffi_bindings_tests_async_test_trait_interface_set_value,
  callback_interface_uniffi_bindings_tests_async_test_trait_interface_throw_if_equal,
  callback_free_uniffi_bindings_tests_async_test_trait_interface
};
static StaticRefPtr<dom::UniFFICallbackHandler> gUniffiCallbackHandlerUniffiBindingsTestsTestTraitInterface;

class CallbackInterfaceMethodUniffiBindingsTestsTestTraitInterfaceNoop final : public AsyncCallbackMethodHandlerBase {
private:
  // Rust arguments

public:
  CallbackInterfaceMethodUniffiBindingsTestsTestTraitInterfaceNoop(
      uint64_t aUniffiHandle)
    : AsyncCallbackMethodHandlerBase(
        "TestTraitInterface.callback_interface_uniffi_bindings_tests_test_trait_interface_noop",
        aUniffiHandle
    )
  {
  }

  MOZ_CAN_RUN_SCRIPT
  already_AddRefed<dom::Promise>
  MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;

    // Setup
    if (!uniffiArgs.AppendElements(0, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return nullptr;
    }

    // Convert each argument

    RefPtr<dom::Promise> result = aJsHandler->CallAsync(mUniffiHandle.IntoRust(), 0, uniffiArgs, aError);
    
    return nullptr;
  }
};


// Sync callback methods are always wrapped to be fire-and-forget style async callbacks.  This means
// we schedule the callback asynchronously and ignore the return value and any exceptions thrown.
extern "C" void callback_interface_uniffi_bindings_tests_test_trait_interface_noop(
  uint64_t aUniffiHandle,
  void* aUniffiOutReturn,
  RustCallStatus* uniffiOutStatus
) {
  UniquePtr<AsyncCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodUniffiBindingsTestsTestTraitInterfaceNoop>(aUniffiHandle);
  AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(std::move(handler), &gUniffiCallbackHandlerUniffiBindingsTestsTestTraitInterface);
}


class CallbackInterfaceMethodUniffiBindingsTestsTestTraitInterfaceGetValue final : public AsyncCallbackMethodHandlerBase {
private:
  // Rust arguments

public:
  CallbackInterfaceMethodUniffiBindingsTestsTestTraitInterfaceGetValue(
      uint64_t aUniffiHandle)
    : AsyncCallbackMethodHandlerBase(
        "TestTraitInterface.callback_interface_uniffi_bindings_tests_test_trait_interface_get_value",
        aUniffiHandle
    )
  {
  }

  MOZ_CAN_RUN_SCRIPT
  already_AddRefed<dom::Promise>
  MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;

    // Setup
    if (!uniffiArgs.AppendElements(0, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return nullptr;
    }

    // Convert each argument

    RefPtr<dom::Promise> result = aJsHandler->CallAsync(mUniffiHandle.IntoRust(), 1, uniffiArgs, aError);
    
    return nullptr;
  }
};


// Sync callback methods are always wrapped to be fire-and-forget style async callbacks.  This means
// we schedule the callback asynchronously and ignore the return value and any exceptions thrown.
extern "C" void callback_interface_uniffi_bindings_tests_test_trait_interface_get_value(
  uint64_t aUniffiHandle,
  uint32_t* aUniffiOutReturn,
  RustCallStatus* uniffiOutStatus
) {
  UniquePtr<AsyncCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodUniffiBindingsTestsTestTraitInterfaceGetValue>(aUniffiHandle);
  AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(std::move(handler), &gUniffiCallbackHandlerUniffiBindingsTestsTestTraitInterface);
}


class CallbackInterfaceMethodUniffiBindingsTestsTestTraitInterfaceSetValue final : public AsyncCallbackMethodHandlerBase {
private:
  // Rust arguments
  FfiValueInt<uint32_t> mValue{};

public:
  CallbackInterfaceMethodUniffiBindingsTestsTestTraitInterfaceSetValue(
      uint64_t aUniffiHandle,
      uint32_t aValue)
    : AsyncCallbackMethodHandlerBase(
        "TestTraitInterface.callback_interface_uniffi_bindings_tests_test_trait_interface_set_value",
        aUniffiHandle
    ), mValue(FfiValueInt<uint32_t>::FromRust(aValue))
  {
  }

  MOZ_CAN_RUN_SCRIPT
  already_AddRefed<dom::Promise>
  MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;

    // Setup
    if (!uniffiArgs.AppendElements(1, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return nullptr;
    }

    // Convert each argument
    mValue.Lift(
      aCx,
      &uniffiArgs[0],
      aError);
    if (aError.Failed()) {
      return nullptr;
    }

    RefPtr<dom::Promise> result = aJsHandler->CallAsync(mUniffiHandle.IntoRust(), 2, uniffiArgs, aError);
    
    return nullptr;
  }
};


// Sync callback methods are always wrapped to be fire-and-forget style async callbacks.  This means
// we schedule the callback asynchronously and ignore the return value and any exceptions thrown.
extern "C" void callback_interface_uniffi_bindings_tests_test_trait_interface_set_value(
  uint64_t aUniffiHandle,
  uint32_t aValue,
  void* aUniffiOutReturn,
  RustCallStatus* uniffiOutStatus
) {
  UniquePtr<AsyncCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodUniffiBindingsTestsTestTraitInterfaceSetValue>(aUniffiHandle, aValue);
  AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(std::move(handler), &gUniffiCallbackHandlerUniffiBindingsTestsTestTraitInterface);
}


class CallbackInterfaceMethodUniffiBindingsTestsTestTraitInterfaceThrowIfEqual final : public AsyncCallbackMethodHandlerBase {
private:
  // Rust arguments
  FfiValueRustBuffer mNumbers{};

public:
  CallbackInterfaceMethodUniffiBindingsTestsTestTraitInterfaceThrowIfEqual(
      uint64_t aUniffiHandle,
      RustBuffer aNumbers)
    : AsyncCallbackMethodHandlerBase(
        "TestTraitInterface.callback_interface_uniffi_bindings_tests_test_trait_interface_throw_if_equal",
        aUniffiHandle
    ), mNumbers(FfiValueRustBuffer::FromRust(aNumbers))
  {
  }

  MOZ_CAN_RUN_SCRIPT
  already_AddRefed<dom::Promise>
  MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;

    // Setup
    if (!uniffiArgs.AppendElements(1, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return nullptr;
    }

    // Convert each argument
    mNumbers.Lift(
      aCx,
      &uniffiArgs[0],
      aError);
    if (aError.Failed()) {
      return nullptr;
    }

    RefPtr<dom::Promise> result = aJsHandler->CallAsync(mUniffiHandle.IntoRust(), 3, uniffiArgs, aError);
    
    return nullptr;
  }
};


// Sync callback methods are always wrapped to be fire-and-forget style async callbacks.  This means
// we schedule the callback asynchronously and ignore the return value and any exceptions thrown.
extern "C" void callback_interface_uniffi_bindings_tests_test_trait_interface_throw_if_equal(
  uint64_t aUniffiHandle,
  RustBuffer aNumbers,
  RustBuffer* aUniffiOutReturn,
  RustCallStatus* uniffiOutStatus
) {
  UniquePtr<AsyncCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodUniffiBindingsTestsTestTraitInterfaceThrowIfEqual>(aUniffiHandle, aNumbers);
  AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(std::move(handler), &gUniffiCallbackHandlerUniffiBindingsTestsTestTraitInterface);
}


extern "C" void callback_free_uniffi_bindings_tests_test_trait_interface(uint64_t uniffiHandle) {
   // Callback object handles are keys in a map stored in the JS handler. To
   // handle the free call, schedule a fire-and-forget JS call to remove the key.
   AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(
      MakeUnique<CallbackFreeHandler>("TestTraitInterface.uniffi_free", uniffiHandle),
      &gUniffiCallbackHandlerUniffiBindingsTestsTestTraitInterface);
}

static VTableCallbackInterfaceUniffiBindingsTestsTestTraitInterface kUniffiVtableUniffiBindingsTestsTestTraitInterface {
  callback_interface_uniffi_bindings_tests_test_trait_interface_noop,
  callback_interface_uniffi_bindings_tests_test_trait_interface_get_value,
  callback_interface_uniffi_bindings_tests_test_trait_interface_set_value,
  callback_interface_uniffi_bindings_tests_test_trait_interface_throw_if_equal,
  callback_free_uniffi_bindings_tests_test_trait_interface
};
static StaticRefPtr<dom::UniFFICallbackHandler> gUniffiCallbackHandlerUniffiBindingsTestsCollisionTestCallbackInterface;

class CallbackInterfaceMethodUniffiBindingsTestsCollisionTestCallbackInterfaceGetValue final : public AsyncCallbackMethodHandlerBase {
private:
  // Rust arguments

public:
  CallbackInterfaceMethodUniffiBindingsTestsCollisionTestCallbackInterfaceGetValue(
      uint64_t aUniffiHandle)
    : AsyncCallbackMethodHandlerBase(
        "TestCallbackInterface.callback_interface_uniffi_bindings_tests_collision_test_callback_interface_get_value",
        aUniffiHandle
    )
  {
  }

  MOZ_CAN_RUN_SCRIPT
  already_AddRefed<dom::Promise>
  MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;

    // Setup
    if (!uniffiArgs.AppendElements(0, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return nullptr;
    }

    // Convert each argument

    RefPtr<dom::Promise> result = aJsHandler->CallAsync(mUniffiHandle.IntoRust(), 0, uniffiArgs, aError);
    
    return nullptr;
  }
};


// Sync callback methods are always wrapped to be fire-and-forget style async callbacks.  This means
// we schedule the callback asynchronously and ignore the return value and any exceptions thrown.
extern "C" void callback_interface_uniffi_bindings_tests_collision_test_callback_interface_get_value(
  uint64_t aUniffiHandle,
  RustBuffer* aUniffiOutReturn,
  RustCallStatus* uniffiOutStatus
) {
  UniquePtr<AsyncCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodUniffiBindingsTestsCollisionTestCallbackInterfaceGetValue>(aUniffiHandle);
  AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(std::move(handler), &gUniffiCallbackHandlerUniffiBindingsTestsCollisionTestCallbackInterface);
}


extern "C" void callback_free_uniffi_bindings_tests_collision_test_callback_interface(uint64_t uniffiHandle) {
   // Callback object handles are keys in a map stored in the JS handler. To
   // handle the free call, schedule a fire-and-forget JS call to remove the key.
   AsyncCallbackMethodHandlerBase::ScheduleAsyncCall(
      MakeUnique<CallbackFreeHandler>("TestCallbackInterface.uniffi_free", uniffiHandle),
      &gUniffiCallbackHandlerUniffiBindingsTestsCollisionTestCallbackInterface);
}

static VTableCallbackInterfaceUniffiBindingsTestsCollisionTestCallbackInterface kUniffiVtableUniffiBindingsTestsCollisionTestCallbackInterface {
  callback_interface_uniffi_bindings_tests_collision_test_callback_interface_get_value,
  callback_free_uniffi_bindings_tests_collision_test_callback_interface
};
#endif /* MOZ_UNIFFI_FIXTURES */

void RegisterCallbackHandler(uint64_t aInterfaceId, UniFFICallbackHandler& aCallbackHandler, ErrorResult& aError) {
  switch (aInterfaceId) {
    
    case 1: {
      if (gUniffiCallbackHandlerContextIdContextIdCallback) {
        aError.ThrowUnknownError("[UniFFI] Callback handler already registered for ContextIdCallback"_ns);
        return;
      }

      gUniffiCallbackHandlerContextIdContextIdCallback = &aCallbackHandler;
      uniffi_context_id_fn_init_callback_vtable_contextidcallback(&kUniffiVtableContextIdContextIdCallback);
      break;
    }
    case 2: {
      if (gUniffiCallbackHandlerErrorsupportApplicationErrorReporter) {
        aError.ThrowUnknownError("[UniFFI] Callback handler already registered for ApplicationErrorReporter"_ns);
        return;
      }

      gUniffiCallbackHandlerErrorsupportApplicationErrorReporter = &aCallbackHandler;
      uniffi_error_support_fn_init_callback_vtable_applicationerrorreporter(&kUniffiVtableErrorsupportApplicationErrorReporter);
      break;
    }
    
    #ifdef MOZ_UNIFFI_FIXTURES
    case 3: {
      if (gUniffiCallbackHandlerUniffiBindingsTestsTestAsyncCallbackInterface) {
        aError.ThrowUnknownError("[UniFFI] Callback handler already registered for TestAsyncCallbackInterface"_ns);
        return;
      }

      gUniffiCallbackHandlerUniffiBindingsTestsTestAsyncCallbackInterface = &aCallbackHandler;
      uniffi_uniffi_bindings_tests_fn_init_callback_vtable_testasynccallbackinterface(&kUniffiVtableUniffiBindingsTestsTestAsyncCallbackInterface);
      break;
    }
    case 4: {
      if (gUniffiCallbackHandlerUniffiBindingsTestsTestCallbackInterface) {
        aError.ThrowUnknownError("[UniFFI] Callback handler already registered for TestCallbackInterface"_ns);
        return;
      }

      gUniffiCallbackHandlerUniffiBindingsTestsTestCallbackInterface = &aCallbackHandler;
      uniffi_uniffi_bindings_tests_fn_init_callback_vtable_testcallbackinterface(&kUniffiVtableUniffiBindingsTestsTestCallbackInterface);
      break;
    }
    case 5: {
      if (gUniffiCallbackHandlerUniffiBindingsTestsAsyncTestTraitInterface) {
        aError.ThrowUnknownError("[UniFFI] Callback handler already registered for AsyncTestTraitInterface"_ns);
        return;
      }

      gUniffiCallbackHandlerUniffiBindingsTestsAsyncTestTraitInterface = &aCallbackHandler;
      uniffi_uniffi_bindings_tests_fn_init_callback_vtable_asynctesttraitinterface(&kUniffiVtableUniffiBindingsTestsAsyncTestTraitInterface);
      break;
    }
    case 6: {
      if (gUniffiCallbackHandlerUniffiBindingsTestsTestTraitInterface) {
        aError.ThrowUnknownError("[UniFFI] Callback handler already registered for TestTraitInterface"_ns);
        return;
      }

      gUniffiCallbackHandlerUniffiBindingsTestsTestTraitInterface = &aCallbackHandler;
      uniffi_uniffi_bindings_tests_fn_init_callback_vtable_testtraitinterface(&kUniffiVtableUniffiBindingsTestsTestTraitInterface);
      break;
    }
    case 7: {
      if (gUniffiCallbackHandlerUniffiBindingsTestsCollisionTestCallbackInterface) {
        aError.ThrowUnknownError("[UniFFI] Callback handler already registered for TestCallbackInterface"_ns);
        return;
      }

      gUniffiCallbackHandlerUniffiBindingsTestsCollisionTestCallbackInterface = &aCallbackHandler;
      uniffi_uniffi_bindings_tests_collision_fn_init_callback_vtable_testcallbackinterface(&kUniffiVtableUniffiBindingsTestsCollisionTestCallbackInterface);
      break;
    }
    #endif /* MOZ_UNIFFI_FIXTURES */

    default:
      aError.ThrowUnknownError(nsPrintfCString("RegisterCallbackHandler: Unknown callback interface id (%" PRIu64 ")", aInterfaceId));
      return;
  }
}

void DeregisterCallbackHandler(uint64_t aInterfaceId, ErrorResult& aError) {
  switch (aInterfaceId) {
    
    case 1: {
      if (!gUniffiCallbackHandlerContextIdContextIdCallback) {
        aError.ThrowUnknownError("[UniFFI] Callback handler not registered for ContextIdCallback"_ns);
        return;
      }

      gUniffiCallbackHandlerContextIdContextIdCallback = nullptr;
      break;
    }
    case 2: {
      if (!gUniffiCallbackHandlerErrorsupportApplicationErrorReporter) {
        aError.ThrowUnknownError("[UniFFI] Callback handler not registered for ApplicationErrorReporter"_ns);
        return;
      }

      gUniffiCallbackHandlerErrorsupportApplicationErrorReporter = nullptr;
      break;
    }
    
    #ifdef MOZ_UNIFFI_FIXTURES
    case 3: {
      if (!gUniffiCallbackHandlerUniffiBindingsTestsTestAsyncCallbackInterface) {
        aError.ThrowUnknownError("[UniFFI] Callback handler not registered for TestAsyncCallbackInterface"_ns);
        return;
      }

      gUniffiCallbackHandlerUniffiBindingsTestsTestAsyncCallbackInterface = nullptr;
      break;
    }
    case 4: {
      if (!gUniffiCallbackHandlerUniffiBindingsTestsTestCallbackInterface) {
        aError.ThrowUnknownError("[UniFFI] Callback handler not registered for TestCallbackInterface"_ns);
        return;
      }

      gUniffiCallbackHandlerUniffiBindingsTestsTestCallbackInterface = nullptr;
      break;
    }
    case 5: {
      if (!gUniffiCallbackHandlerUniffiBindingsTestsAsyncTestTraitInterface) {
        aError.ThrowUnknownError("[UniFFI] Callback handler not registered for AsyncTestTraitInterface"_ns);
        return;
      }

      gUniffiCallbackHandlerUniffiBindingsTestsAsyncTestTraitInterface = nullptr;
      break;
    }
    case 6: {
      if (!gUniffiCallbackHandlerUniffiBindingsTestsTestTraitInterface) {
        aError.ThrowUnknownError("[UniFFI] Callback handler not registered for TestTraitInterface"_ns);
        return;
      }

      gUniffiCallbackHandlerUniffiBindingsTestsTestTraitInterface = nullptr;
      break;
    }
    case 7: {
      if (!gUniffiCallbackHandlerUniffiBindingsTestsCollisionTestCallbackInterface) {
        aError.ThrowUnknownError("[UniFFI] Callback handler not registered for TestCallbackInterface"_ns);
        return;
      }

      gUniffiCallbackHandlerUniffiBindingsTestsCollisionTestCallbackInterface = nullptr;
      break;
    }
    #endif /* MOZ_UNIFFI_FIXTURES */

    default:
      aError.ThrowUnknownError(nsPrintfCString("DeregisterCallbackHandler: Unknown callback interface id (%" PRIu64 ")", aInterfaceId));
      return;
  }
}

}  // namespace mozilla::uniffi
