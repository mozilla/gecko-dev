/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set ts=8 sts=2 et sw=2 tw=80: */

// Generated by uniffi-bindgen-gecko-js.  DO NOT EDIT.

#include "nsString.h"
#include "nsPrintfCString.h"
#include "mozilla/Logging.h"
#include "mozilla/Maybe.h"
#include "mozilla/StaticPtr.h"
#include "mozilla/UniquePtr.h"
#include "mozilla/dom/Promise.h"
#include "mozilla/dom/UniFFIScaffolding.h"
#include "mozilla/uniffi/Call.h"
#include "mozilla/uniffi/Callbacks.h"
#include "mozilla/uniffi/FfiValue.h"
#include "mozilla/uniffi/PointerType.h"
#include "mozilla/uniffi/Rust.h"

namespace mozilla::uniffi {

using dom::ArrayBuffer;
using dom::AutoEntryScript;
using dom::GlobalObject;
using dom::RootedDictionary;
using dom::NullableRootedUnion;
using dom::Promise;
using dom::OwningUniFFIScaffoldingValue;
using dom::Sequence;
using dom::UniFFICallbackHandler;
using dom::UniFFIPointer;
using dom::UniFFIScaffoldingCallResult;

// Define scaffolding functions from UniFFI
extern "C" {

  typedef void (*RustFutureContinuationCallback)(uint64_t, int8_t);
  typedef void (*ForeignFutureFree)(uint64_t);
  typedef void (*CallbackInterfaceFree)(uint64_t);
  struct ForeignFuture {
    uint64_t handle;
    ForeignFutureFree free;
  };
  struct ForeignFutureStructU8 {
    uint8_t return_value;
    RustCallStatus call_status;
  };
  typedef void (*ForeignFutureCompleteU8)(uint64_t, ForeignFutureStructU8);
  struct ForeignFutureStructI8 {
    int8_t return_value;
    RustCallStatus call_status;
  };
  typedef void (*ForeignFutureCompleteI8)(uint64_t, ForeignFutureStructI8);
  struct ForeignFutureStructU16 {
    uint16_t return_value;
    RustCallStatus call_status;
  };
  typedef void (*ForeignFutureCompleteU16)(uint64_t, ForeignFutureStructU16);
  struct ForeignFutureStructI16 {
    int16_t return_value;
    RustCallStatus call_status;
  };
  typedef void (*ForeignFutureCompleteI16)(uint64_t, ForeignFutureStructI16);
  struct ForeignFutureStructU32 {
    uint32_t return_value;
    RustCallStatus call_status;
  };
  typedef void (*ForeignFutureCompleteU32)(uint64_t, ForeignFutureStructU32);
  struct ForeignFutureStructI32 {
    int32_t return_value;
    RustCallStatus call_status;
  };
  typedef void (*ForeignFutureCompleteI32)(uint64_t, ForeignFutureStructI32);
  struct ForeignFutureStructU64 {
    uint64_t return_value;
    RustCallStatus call_status;
  };
  typedef void (*ForeignFutureCompleteU64)(uint64_t, ForeignFutureStructU64);
  struct ForeignFutureStructI64 {
    int64_t return_value;
    RustCallStatus call_status;
  };
  typedef void (*ForeignFutureCompleteI64)(uint64_t, ForeignFutureStructI64);
  struct ForeignFutureStructF32 {
    float return_value;
    RustCallStatus call_status;
  };
  typedef void (*ForeignFutureCompleteF32)(uint64_t, ForeignFutureStructF32);
  struct ForeignFutureStructF64 {
    double return_value;
    RustCallStatus call_status;
  };
  typedef void (*ForeignFutureCompleteF64)(uint64_t, ForeignFutureStructF64);
  struct ForeignFutureStructPointer {
    void* return_value;
    RustCallStatus call_status;
  };
  typedef void (*ForeignFutureCompletePointer)(uint64_t, ForeignFutureStructPointer);
  struct ForeignFutureStructRustBuffer {
    RustBuffer return_value;
    RustCallStatus call_status;
  };
  typedef void (*ForeignFutureCompleteRustBuffer)(uint64_t, ForeignFutureStructRustBuffer);
  struct ForeignFutureStructVoid {
    RustCallStatus call_status;
  };
  typedef void (*ForeignFutureCompleteVoid)(uint64_t, ForeignFutureStructVoid);
  typedef void (*CallbackInterfaceApplicationErrorReporterMethod0)(uint64_t, RustBuffer, RustBuffer, void*, RustCallStatus*);
  typedef void (*CallbackInterfaceApplicationErrorReporterMethod1)(uint64_t, RustBuffer, RustBuffer, uint32_t, uint32_t, void*, RustCallStatus*);
  struct VTableCallbackInterfaceApplicationErrorReporter {
    CallbackInterfaceApplicationErrorReporterMethod0 report_error;
    CallbackInterfaceApplicationErrorReporterMethod1 report_breadcrumb;
    CallbackInterfaceFree uniffi_free;
  };
  void uniffi_error_support_fn_init_callback_vtable_applicationerrorreporter(VTableCallbackInterfaceApplicationErrorReporter*);
  void uniffi_error_support_fn_func_set_application_error_reporter(uint64_t, RustCallStatus*);
  void uniffi_error_support_fn_func_unset_application_error_reporter(RustCallStatus*);
  RustBuffer ffi_error_support_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_error_support_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_error_support_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_error_support_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_u8(uint64_t);
  void ffi_error_support_rust_future_free_u8(uint64_t);
  uint8_t ffi_error_support_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_i8(uint64_t);
  void ffi_error_support_rust_future_free_i8(uint64_t);
  int8_t ffi_error_support_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_u16(uint64_t);
  void ffi_error_support_rust_future_free_u16(uint64_t);
  uint16_t ffi_error_support_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_i16(uint64_t);
  void ffi_error_support_rust_future_free_i16(uint64_t);
  int16_t ffi_error_support_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_u32(uint64_t);
  void ffi_error_support_rust_future_free_u32(uint64_t);
  uint32_t ffi_error_support_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_i32(uint64_t);
  void ffi_error_support_rust_future_free_i32(uint64_t);
  int32_t ffi_error_support_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_u64(uint64_t);
  void ffi_error_support_rust_future_free_u64(uint64_t);
  uint64_t ffi_error_support_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_i64(uint64_t);
  void ffi_error_support_rust_future_free_i64(uint64_t);
  int64_t ffi_error_support_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_f32(uint64_t);
  void ffi_error_support_rust_future_free_f32(uint64_t);
  float ffi_error_support_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_f64(uint64_t);
  void ffi_error_support_rust_future_free_f64(uint64_t);
  double ffi_error_support_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_poll_pointer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_pointer(uint64_t);
  void ffi_error_support_rust_future_free_pointer(uint64_t);
  void* ffi_error_support_rust_future_complete_pointer(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_rust_buffer(uint64_t);
  void ffi_error_support_rust_future_free_rust_buffer(uint64_t);
  RustBuffer ffi_error_support_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_void(uint64_t);
  void ffi_error_support_rust_future_free_void(uint64_t);
  void ffi_error_support_rust_future_complete_void(uint64_t, RustCallStatus*);
  uint16_t uniffi_error_support_checksum_func_set_application_error_reporter();
  uint16_t uniffi_error_support_checksum_func_unset_application_error_reporter();
  uint16_t uniffi_error_support_checksum_method_applicationerrorreporter_report_error();
  uint16_t uniffi_error_support_checksum_method_applicationerrorreporter_report_breadcrumb();
  uint32_t ffi_error_support_uniffi_contract_version();
  void* uniffi_relevancy_fn_clone_relevancystore(void*, RustCallStatus*);
  void uniffi_relevancy_fn_free_relevancystore(void*, RustCallStatus*);
  void* uniffi_relevancy_fn_constructor_relevancystore_new(RustBuffer, void*, RustCallStatus*);
  void uniffi_relevancy_fn_method_relevancystore_bandit_init(void*, RustBuffer, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_relevancy_fn_method_relevancystore_bandit_select(void*, RustBuffer, RustBuffer, RustCallStatus*);
  void uniffi_relevancy_fn_method_relevancystore_bandit_update(void*, RustBuffer, RustBuffer, int8_t, RustCallStatus*);
  void uniffi_relevancy_fn_method_relevancystore_close(void*, RustCallStatus*);
  void uniffi_relevancy_fn_method_relevancystore_ensure_interest_data_populated(void*, RustCallStatus*);
  RustBuffer uniffi_relevancy_fn_method_relevancystore_get_bandit_data(void*, RustBuffer, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_relevancy_fn_method_relevancystore_ingest(void*, RustBuffer, RustCallStatus*);
  void uniffi_relevancy_fn_method_relevancystore_interrupt(void*, RustCallStatus*);
  RustBuffer uniffi_relevancy_fn_method_relevancystore_user_interest_vector(void*, RustCallStatus*);
  double uniffi_relevancy_fn_func_score(RustBuffer, RustBuffer, RustCallStatus*);
  RustBuffer ffi_relevancy_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_relevancy_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_relevancy_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_relevancy_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_u8(uint64_t);
  void ffi_relevancy_rust_future_free_u8(uint64_t);
  uint8_t ffi_relevancy_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_i8(uint64_t);
  void ffi_relevancy_rust_future_free_i8(uint64_t);
  int8_t ffi_relevancy_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_u16(uint64_t);
  void ffi_relevancy_rust_future_free_u16(uint64_t);
  uint16_t ffi_relevancy_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_i16(uint64_t);
  void ffi_relevancy_rust_future_free_i16(uint64_t);
  int16_t ffi_relevancy_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_u32(uint64_t);
  void ffi_relevancy_rust_future_free_u32(uint64_t);
  uint32_t ffi_relevancy_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_i32(uint64_t);
  void ffi_relevancy_rust_future_free_i32(uint64_t);
  int32_t ffi_relevancy_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_u64(uint64_t);
  void ffi_relevancy_rust_future_free_u64(uint64_t);
  uint64_t ffi_relevancy_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_i64(uint64_t);
  void ffi_relevancy_rust_future_free_i64(uint64_t);
  int64_t ffi_relevancy_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_f32(uint64_t);
  void ffi_relevancy_rust_future_free_f32(uint64_t);
  float ffi_relevancy_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_f64(uint64_t);
  void ffi_relevancy_rust_future_free_f64(uint64_t);
  double ffi_relevancy_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_poll_pointer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_pointer(uint64_t);
  void ffi_relevancy_rust_future_free_pointer(uint64_t);
  void* ffi_relevancy_rust_future_complete_pointer(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_rust_buffer(uint64_t);
  void ffi_relevancy_rust_future_free_rust_buffer(uint64_t);
  RustBuffer ffi_relevancy_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_void(uint64_t);
  void ffi_relevancy_rust_future_free_void(uint64_t);
  void ffi_relevancy_rust_future_complete_void(uint64_t, RustCallStatus*);
  uint16_t uniffi_relevancy_checksum_func_score();
  uint16_t uniffi_relevancy_checksum_method_relevancystore_bandit_init();
  uint16_t uniffi_relevancy_checksum_method_relevancystore_bandit_select();
  uint16_t uniffi_relevancy_checksum_method_relevancystore_bandit_update();
  uint16_t uniffi_relevancy_checksum_method_relevancystore_close();
  uint16_t uniffi_relevancy_checksum_method_relevancystore_ensure_interest_data_populated();
  uint16_t uniffi_relevancy_checksum_method_relevancystore_get_bandit_data();
  uint16_t uniffi_relevancy_checksum_method_relevancystore_ingest();
  uint16_t uniffi_relevancy_checksum_method_relevancystore_interrupt();
  uint16_t uniffi_relevancy_checksum_method_relevancystore_user_interest_vector();
  uint16_t uniffi_relevancy_checksum_constructor_relevancystore_new();
  uint32_t ffi_relevancy_uniffi_contract_version();
  void* uniffi_remote_settings_fn_clone_remotesettings(void*, RustCallStatus*);
  void uniffi_remote_settings_fn_free_remotesettings(void*, RustCallStatus*);
  void* uniffi_remote_settings_fn_constructor_remotesettings_new(RustBuffer, RustCallStatus*);
  void uniffi_remote_settings_fn_method_remotesettings_download_attachment_to_path(void*, RustBuffer, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_remote_settings_fn_method_remotesettings_get_records(void*, RustCallStatus*);
  RustBuffer uniffi_remote_settings_fn_method_remotesettings_get_records_since(void*, uint64_t, RustCallStatus*);
  void* uniffi_remote_settings_fn_clone_remotesettingsclient(void*, RustCallStatus*);
  void uniffi_remote_settings_fn_free_remotesettingsclient(void*, RustCallStatus*);
  RustBuffer uniffi_remote_settings_fn_method_remotesettingsclient_collection_name(void*, RustCallStatus*);
  RustBuffer uniffi_remote_settings_fn_method_remotesettingsclient_get_attachment(void*, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_remote_settings_fn_method_remotesettingsclient_get_records(void*, int8_t, RustCallStatus*);
  RustBuffer uniffi_remote_settings_fn_method_remotesettingsclient_get_records_map(void*, int8_t, RustCallStatus*);
  void uniffi_remote_settings_fn_method_remotesettingsclient_shutdown(void*, RustCallStatus*);
  void uniffi_remote_settings_fn_method_remotesettingsclient_sync(void*, RustCallStatus*);
  void* uniffi_remote_settings_fn_clone_remotesettingsservice(void*, RustCallStatus*);
  void uniffi_remote_settings_fn_free_remotesettingsservice(void*, RustCallStatus*);
  void* uniffi_remote_settings_fn_constructor_remotesettingsservice_new(RustBuffer, RustBuffer, RustCallStatus*);
  void* uniffi_remote_settings_fn_method_remotesettingsservice_make_client(void*, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_remote_settings_fn_method_remotesettingsservice_sync(void*, RustCallStatus*);
  void uniffi_remote_settings_fn_method_remotesettingsservice_update_config(void*, RustBuffer, RustCallStatus*);
  RustBuffer ffi_remote_settings_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_remote_settings_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_remote_settings_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_remote_settings_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_u8(uint64_t);
  void ffi_remote_settings_rust_future_free_u8(uint64_t);
  uint8_t ffi_remote_settings_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_i8(uint64_t);
  void ffi_remote_settings_rust_future_free_i8(uint64_t);
  int8_t ffi_remote_settings_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_u16(uint64_t);
  void ffi_remote_settings_rust_future_free_u16(uint64_t);
  uint16_t ffi_remote_settings_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_i16(uint64_t);
  void ffi_remote_settings_rust_future_free_i16(uint64_t);
  int16_t ffi_remote_settings_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_u32(uint64_t);
  void ffi_remote_settings_rust_future_free_u32(uint64_t);
  uint32_t ffi_remote_settings_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_i32(uint64_t);
  void ffi_remote_settings_rust_future_free_i32(uint64_t);
  int32_t ffi_remote_settings_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_u64(uint64_t);
  void ffi_remote_settings_rust_future_free_u64(uint64_t);
  uint64_t ffi_remote_settings_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_i64(uint64_t);
  void ffi_remote_settings_rust_future_free_i64(uint64_t);
  int64_t ffi_remote_settings_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_f32(uint64_t);
  void ffi_remote_settings_rust_future_free_f32(uint64_t);
  float ffi_remote_settings_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_f64(uint64_t);
  void ffi_remote_settings_rust_future_free_f64(uint64_t);
  double ffi_remote_settings_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_poll_pointer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_pointer(uint64_t);
  void ffi_remote_settings_rust_future_free_pointer(uint64_t);
  void* ffi_remote_settings_rust_future_complete_pointer(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_rust_buffer(uint64_t);
  void ffi_remote_settings_rust_future_free_rust_buffer(uint64_t);
  RustBuffer ffi_remote_settings_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_void(uint64_t);
  void ffi_remote_settings_rust_future_free_void(uint64_t);
  void ffi_remote_settings_rust_future_complete_void(uint64_t, RustCallStatus*);
  uint16_t uniffi_remote_settings_checksum_method_remotesettings_download_attachment_to_path();
  uint16_t uniffi_remote_settings_checksum_method_remotesettings_get_records();
  uint16_t uniffi_remote_settings_checksum_method_remotesettings_get_records_since();
  uint16_t uniffi_remote_settings_checksum_method_remotesettingsclient_collection_name();
  uint16_t uniffi_remote_settings_checksum_method_remotesettingsclient_get_attachment();
  uint16_t uniffi_remote_settings_checksum_method_remotesettingsclient_get_records();
  uint16_t uniffi_remote_settings_checksum_method_remotesettingsclient_get_records_map();
  uint16_t uniffi_remote_settings_checksum_method_remotesettingsclient_shutdown();
  uint16_t uniffi_remote_settings_checksum_method_remotesettingsclient_sync();
  uint16_t uniffi_remote_settings_checksum_method_remotesettingsservice_make_client();
  uint16_t uniffi_remote_settings_checksum_method_remotesettingsservice_sync();
  uint16_t uniffi_remote_settings_checksum_method_remotesettingsservice_update_config();
  uint16_t uniffi_remote_settings_checksum_constructor_remotesettings_new();
  uint16_t uniffi_remote_settings_checksum_constructor_remotesettingsservice_new();
  uint32_t ffi_remote_settings_uniffi_contract_version();
  void* uniffi_search_fn_clone_searchengineselector(void*, RustCallStatus*);
  void uniffi_search_fn_free_searchengineselector(void*, RustCallStatus*);
  void* uniffi_search_fn_constructor_searchengineselector_new(RustCallStatus*);
  void uniffi_search_fn_method_searchengineselector_clear_search_config(void*, RustCallStatus*);
  RustBuffer uniffi_search_fn_method_searchengineselector_filter_engine_configuration(void*, RustBuffer, RustCallStatus*);
  void uniffi_search_fn_method_searchengineselector_set_config_overrides(void*, RustBuffer, RustCallStatus*);
  void uniffi_search_fn_method_searchengineselector_set_search_config(void*, RustBuffer, RustCallStatus*);
  void uniffi_search_fn_method_searchengineselector_use_remote_settings_server(void*, void*, int8_t, RustCallStatus*);
  RustBuffer ffi_search_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_search_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_search_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_search_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_search_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_u8(uint64_t);
  void ffi_search_rust_future_free_u8(uint64_t);
  uint8_t ffi_search_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_i8(uint64_t);
  void ffi_search_rust_future_free_i8(uint64_t);
  int8_t ffi_search_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_u16(uint64_t);
  void ffi_search_rust_future_free_u16(uint64_t);
  uint16_t ffi_search_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_i16(uint64_t);
  void ffi_search_rust_future_free_i16(uint64_t);
  int16_t ffi_search_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_u32(uint64_t);
  void ffi_search_rust_future_free_u32(uint64_t);
  uint32_t ffi_search_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_i32(uint64_t);
  void ffi_search_rust_future_free_i32(uint64_t);
  int32_t ffi_search_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_u64(uint64_t);
  void ffi_search_rust_future_free_u64(uint64_t);
  uint64_t ffi_search_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_i64(uint64_t);
  void ffi_search_rust_future_free_i64(uint64_t);
  int64_t ffi_search_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_f32(uint64_t);
  void ffi_search_rust_future_free_f32(uint64_t);
  float ffi_search_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_f64(uint64_t);
  void ffi_search_rust_future_free_f64(uint64_t);
  double ffi_search_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_poll_pointer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_pointer(uint64_t);
  void ffi_search_rust_future_free_pointer(uint64_t);
  void* ffi_search_rust_future_complete_pointer(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_rust_buffer(uint64_t);
  void ffi_search_rust_future_free_rust_buffer(uint64_t);
  RustBuffer ffi_search_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_void(uint64_t);
  void ffi_search_rust_future_free_void(uint64_t);
  void ffi_search_rust_future_complete_void(uint64_t, RustCallStatus*);
  uint16_t uniffi_search_checksum_method_searchengineselector_clear_search_config();
  uint16_t uniffi_search_checksum_method_searchengineselector_filter_engine_configuration();
  uint16_t uniffi_search_checksum_method_searchengineselector_set_config_overrides();
  uint16_t uniffi_search_checksum_method_searchengineselector_set_search_config();
  uint16_t uniffi_search_checksum_method_searchengineselector_use_remote_settings_server();
  uint16_t uniffi_search_checksum_constructor_searchengineselector_new();
  uint32_t ffi_search_uniffi_contract_version();
  void* uniffi_suggest_fn_clone_suggeststore(void*, RustCallStatus*);
  void uniffi_suggest_fn_free_suggeststore(void*, RustCallStatus*);
  void* uniffi_suggest_fn_constructor_suggeststore_new(RustBuffer, void*, RustCallStatus*);
  int8_t uniffi_suggest_fn_method_suggeststore_any_dismissed_suggestions(void*, RustCallStatus*);
  void uniffi_suggest_fn_method_suggeststore_clear(void*, RustCallStatus*);
  void uniffi_suggest_fn_method_suggeststore_clear_dismissed_suggestions(void*, RustCallStatus*);
  void uniffi_suggest_fn_method_suggeststore_dismiss_by_key(void*, RustBuffer, RustCallStatus*);
  void uniffi_suggest_fn_method_suggeststore_dismiss_by_suggestion(void*, RustBuffer, RustCallStatus*);
  void uniffi_suggest_fn_method_suggeststore_dismiss_suggestion(void*, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_suggest_fn_method_suggeststore_fetch_geonames(void*, RustBuffer, int8_t, RustBuffer, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_suggest_fn_method_suggeststore_fetch_global_config(void*, RustCallStatus*);
  RustBuffer uniffi_suggest_fn_method_suggeststore_fetch_provider_config(void*, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_suggest_fn_method_suggeststore_ingest(void*, RustBuffer, RustCallStatus*);
  void uniffi_suggest_fn_method_suggeststore_interrupt(void*, RustBuffer, RustCallStatus*);
  int8_t uniffi_suggest_fn_method_suggeststore_is_dismissed_by_key(void*, RustBuffer, RustCallStatus*);
  int8_t uniffi_suggest_fn_method_suggeststore_is_dismissed_by_suggestion(void*, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_suggest_fn_method_suggeststore_query(void*, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_suggest_fn_method_suggeststore_query_with_metrics(void*, RustBuffer, RustCallStatus*);
  void* uniffi_suggest_fn_clone_suggeststorebuilder(void*, RustCallStatus*);
  void uniffi_suggest_fn_free_suggeststorebuilder(void*, RustCallStatus*);
  void* uniffi_suggest_fn_constructor_suggeststorebuilder_new(RustCallStatus*);
  void* uniffi_suggest_fn_method_suggeststorebuilder_build(void*, RustCallStatus*);
  void* uniffi_suggest_fn_method_suggeststorebuilder_cache_path(void*, RustBuffer, RustCallStatus*);
  void* uniffi_suggest_fn_method_suggeststorebuilder_data_path(void*, RustBuffer, RustCallStatus*);
  void* uniffi_suggest_fn_method_suggeststorebuilder_load_extension(void*, RustBuffer, RustBuffer, RustCallStatus*);
  void* uniffi_suggest_fn_method_suggeststorebuilder_remote_settings_bucket_name(void*, RustBuffer, RustCallStatus*);
  void* uniffi_suggest_fn_method_suggeststorebuilder_remote_settings_server(void*, RustBuffer, RustCallStatus*);
  void* uniffi_suggest_fn_method_suggeststorebuilder_remote_settings_service(void*, void*, RustCallStatus*);
  int8_t uniffi_suggest_fn_func_raw_suggestion_url_matches(RustBuffer, RustBuffer, RustCallStatus*);
  RustBuffer ffi_suggest_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_suggest_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_suggest_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_suggest_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_u8(uint64_t);
  void ffi_suggest_rust_future_free_u8(uint64_t);
  uint8_t ffi_suggest_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_i8(uint64_t);
  void ffi_suggest_rust_future_free_i8(uint64_t);
  int8_t ffi_suggest_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_u16(uint64_t);
  void ffi_suggest_rust_future_free_u16(uint64_t);
  uint16_t ffi_suggest_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_i16(uint64_t);
  void ffi_suggest_rust_future_free_i16(uint64_t);
  int16_t ffi_suggest_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_u32(uint64_t);
  void ffi_suggest_rust_future_free_u32(uint64_t);
  uint32_t ffi_suggest_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_i32(uint64_t);
  void ffi_suggest_rust_future_free_i32(uint64_t);
  int32_t ffi_suggest_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_u64(uint64_t);
  void ffi_suggest_rust_future_free_u64(uint64_t);
  uint64_t ffi_suggest_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_i64(uint64_t);
  void ffi_suggest_rust_future_free_i64(uint64_t);
  int64_t ffi_suggest_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_f32(uint64_t);
  void ffi_suggest_rust_future_free_f32(uint64_t);
  float ffi_suggest_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_f64(uint64_t);
  void ffi_suggest_rust_future_free_f64(uint64_t);
  double ffi_suggest_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_poll_pointer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_pointer(uint64_t);
  void ffi_suggest_rust_future_free_pointer(uint64_t);
  void* ffi_suggest_rust_future_complete_pointer(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_rust_buffer(uint64_t);
  void ffi_suggest_rust_future_free_rust_buffer(uint64_t);
  RustBuffer ffi_suggest_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_void(uint64_t);
  void ffi_suggest_rust_future_free_void(uint64_t);
  void ffi_suggest_rust_future_complete_void(uint64_t, RustCallStatus*);
  uint16_t uniffi_suggest_checksum_func_raw_suggestion_url_matches();
  uint16_t uniffi_suggest_checksum_method_suggeststore_any_dismissed_suggestions();
  uint16_t uniffi_suggest_checksum_method_suggeststore_clear();
  uint16_t uniffi_suggest_checksum_method_suggeststore_clear_dismissed_suggestions();
  uint16_t uniffi_suggest_checksum_method_suggeststore_dismiss_by_key();
  uint16_t uniffi_suggest_checksum_method_suggeststore_dismiss_by_suggestion();
  uint16_t uniffi_suggest_checksum_method_suggeststore_dismiss_suggestion();
  uint16_t uniffi_suggest_checksum_method_suggeststore_fetch_geonames();
  uint16_t uniffi_suggest_checksum_method_suggeststore_fetch_global_config();
  uint16_t uniffi_suggest_checksum_method_suggeststore_fetch_provider_config();
  uint16_t uniffi_suggest_checksum_method_suggeststore_ingest();
  uint16_t uniffi_suggest_checksum_method_suggeststore_interrupt();
  uint16_t uniffi_suggest_checksum_method_suggeststore_is_dismissed_by_key();
  uint16_t uniffi_suggest_checksum_method_suggeststore_is_dismissed_by_suggestion();
  uint16_t uniffi_suggest_checksum_method_suggeststore_query();
  uint16_t uniffi_suggest_checksum_method_suggeststore_query_with_metrics();
  uint16_t uniffi_suggest_checksum_method_suggeststorebuilder_build();
  uint16_t uniffi_suggest_checksum_method_suggeststorebuilder_cache_path();
  uint16_t uniffi_suggest_checksum_method_suggeststorebuilder_data_path();
  uint16_t uniffi_suggest_checksum_method_suggeststorebuilder_load_extension();
  uint16_t uniffi_suggest_checksum_method_suggeststorebuilder_remote_settings_bucket_name();
  uint16_t uniffi_suggest_checksum_method_suggeststorebuilder_remote_settings_server();
  uint16_t uniffi_suggest_checksum_method_suggeststorebuilder_remote_settings_service();
  uint16_t uniffi_suggest_checksum_constructor_suggeststore_new();
  uint16_t uniffi_suggest_checksum_constructor_suggeststorebuilder_new();
  uint32_t ffi_suggest_uniffi_contract_version();
  RustBuffer ffi_sync15_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_sync15_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_sync15_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_sync15_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_u8(uint64_t);
  void ffi_sync15_rust_future_free_u8(uint64_t);
  uint8_t ffi_sync15_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_i8(uint64_t);
  void ffi_sync15_rust_future_free_i8(uint64_t);
  int8_t ffi_sync15_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_u16(uint64_t);
  void ffi_sync15_rust_future_free_u16(uint64_t);
  uint16_t ffi_sync15_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_i16(uint64_t);
  void ffi_sync15_rust_future_free_i16(uint64_t);
  int16_t ffi_sync15_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_u32(uint64_t);
  void ffi_sync15_rust_future_free_u32(uint64_t);
  uint32_t ffi_sync15_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_i32(uint64_t);
  void ffi_sync15_rust_future_free_i32(uint64_t);
  int32_t ffi_sync15_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_u64(uint64_t);
  void ffi_sync15_rust_future_free_u64(uint64_t);
  uint64_t ffi_sync15_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_i64(uint64_t);
  void ffi_sync15_rust_future_free_i64(uint64_t);
  int64_t ffi_sync15_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_f32(uint64_t);
  void ffi_sync15_rust_future_free_f32(uint64_t);
  float ffi_sync15_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_f64(uint64_t);
  void ffi_sync15_rust_future_free_f64(uint64_t);
  double ffi_sync15_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_poll_pointer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_pointer(uint64_t);
  void ffi_sync15_rust_future_free_pointer(uint64_t);
  void* ffi_sync15_rust_future_complete_pointer(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_rust_buffer(uint64_t);
  void ffi_sync15_rust_future_free_rust_buffer(uint64_t);
  RustBuffer ffi_sync15_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_void(uint64_t);
  void ffi_sync15_rust_future_free_void(uint64_t);
  void ffi_sync15_rust_future_complete_void(uint64_t, RustCallStatus*);
  uint32_t ffi_sync15_uniffi_contract_version();
  void* uniffi_tabs_fn_clone_remotecommandstore(void*, RustCallStatus*);
  void uniffi_tabs_fn_free_remotecommandstore(void*, RustCallStatus*);
  int8_t uniffi_tabs_fn_method_remotecommandstore_add_remote_command(void*, RustBuffer, RustBuffer, RustCallStatus*);
  int8_t uniffi_tabs_fn_method_remotecommandstore_add_remote_command_at(void*, RustBuffer, RustBuffer, int64_t, RustCallStatus*);
  RustBuffer uniffi_tabs_fn_method_remotecommandstore_get_unsent_commands(void*, RustCallStatus*);
  int8_t uniffi_tabs_fn_method_remotecommandstore_remove_remote_command(void*, RustBuffer, RustBuffer, RustCallStatus*);
  int8_t uniffi_tabs_fn_method_remotecommandstore_set_pending_command_sent(void*, RustBuffer, RustCallStatus*);
  void* uniffi_tabs_fn_clone_tabsbridgedengine(void*, RustCallStatus*);
  void uniffi_tabs_fn_free_tabsbridgedengine(void*, RustCallStatus*);
  RustBuffer uniffi_tabs_fn_method_tabsbridgedengine_apply(void*, RustCallStatus*);
  RustBuffer uniffi_tabs_fn_method_tabsbridgedengine_ensure_current_sync_id(void*, RustBuffer, RustCallStatus*);
  int64_t uniffi_tabs_fn_method_tabsbridgedengine_last_sync(void*, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsbridgedengine_prepare_for_sync(void*, RustBuffer, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsbridgedengine_reset(void*, RustCallStatus*);
  RustBuffer uniffi_tabs_fn_method_tabsbridgedengine_reset_sync_id(void*, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsbridgedengine_set_last_sync(void*, int64_t, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsbridgedengine_set_uploaded(void*, int64_t, RustBuffer, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsbridgedengine_store_incoming(void*, RustBuffer, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsbridgedengine_sync_finished(void*, RustCallStatus*);
  RustBuffer uniffi_tabs_fn_method_tabsbridgedengine_sync_id(void*, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsbridgedengine_sync_started(void*, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsbridgedengine_wipe(void*, RustCallStatus*);
  void* uniffi_tabs_fn_clone_tabsstore(void*, RustCallStatus*);
  void uniffi_tabs_fn_free_tabsstore(void*, RustCallStatus*);
  void* uniffi_tabs_fn_constructor_tabsstore_new(RustBuffer, RustCallStatus*);
  void* uniffi_tabs_fn_method_tabsstore_bridged_engine(void*, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsstore_close_connection(void*, RustCallStatus*);
  RustBuffer uniffi_tabs_fn_method_tabsstore_get_all(void*, RustCallStatus*);
  void* uniffi_tabs_fn_method_tabsstore_new_remote_command_store(void*, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsstore_register_with_sync_manager(void*, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsstore_set_local_tabs(void*, RustBuffer, RustCallStatus*);
  RustBuffer ffi_tabs_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_tabs_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_tabs_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_tabs_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_u8(uint64_t);
  void ffi_tabs_rust_future_free_u8(uint64_t);
  uint8_t ffi_tabs_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_i8(uint64_t);
  void ffi_tabs_rust_future_free_i8(uint64_t);
  int8_t ffi_tabs_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_u16(uint64_t);
  void ffi_tabs_rust_future_free_u16(uint64_t);
  uint16_t ffi_tabs_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_i16(uint64_t);
  void ffi_tabs_rust_future_free_i16(uint64_t);
  int16_t ffi_tabs_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_u32(uint64_t);
  void ffi_tabs_rust_future_free_u32(uint64_t);
  uint32_t ffi_tabs_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_i32(uint64_t);
  void ffi_tabs_rust_future_free_i32(uint64_t);
  int32_t ffi_tabs_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_u64(uint64_t);
  void ffi_tabs_rust_future_free_u64(uint64_t);
  uint64_t ffi_tabs_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_i64(uint64_t);
  void ffi_tabs_rust_future_free_i64(uint64_t);
  int64_t ffi_tabs_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_f32(uint64_t);
  void ffi_tabs_rust_future_free_f32(uint64_t);
  float ffi_tabs_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_f64(uint64_t);
  void ffi_tabs_rust_future_free_f64(uint64_t);
  double ffi_tabs_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_poll_pointer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_pointer(uint64_t);
  void ffi_tabs_rust_future_free_pointer(uint64_t);
  void* ffi_tabs_rust_future_complete_pointer(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_rust_buffer(uint64_t);
  void ffi_tabs_rust_future_free_rust_buffer(uint64_t);
  RustBuffer ffi_tabs_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_void(uint64_t);
  void ffi_tabs_rust_future_free_void(uint64_t);
  void ffi_tabs_rust_future_complete_void(uint64_t, RustCallStatus*);
  uint16_t uniffi_tabs_checksum_method_remotecommandstore_add_remote_command();
  uint16_t uniffi_tabs_checksum_method_remotecommandstore_add_remote_command_at();
  uint16_t uniffi_tabs_checksum_method_remotecommandstore_get_unsent_commands();
  uint16_t uniffi_tabs_checksum_method_remotecommandstore_remove_remote_command();
  uint16_t uniffi_tabs_checksum_method_remotecommandstore_set_pending_command_sent();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_apply();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_ensure_current_sync_id();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_last_sync();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_prepare_for_sync();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_reset();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_reset_sync_id();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_set_last_sync();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_set_uploaded();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_store_incoming();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_sync_finished();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_sync_id();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_sync_started();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_wipe();
  uint16_t uniffi_tabs_checksum_method_tabsstore_bridged_engine();
  uint16_t uniffi_tabs_checksum_method_tabsstore_close_connection();
  uint16_t uniffi_tabs_checksum_method_tabsstore_get_all();
  uint16_t uniffi_tabs_checksum_method_tabsstore_new_remote_command_store();
  uint16_t uniffi_tabs_checksum_method_tabsstore_register_with_sync_manager();
  uint16_t uniffi_tabs_checksum_method_tabsstore_set_local_tabs();
  uint16_t uniffi_tabs_checksum_constructor_tabsstore_new();
  uint32_t ffi_tabs_uniffi_contract_version();
  void* uniffi_webext_storage_fn_clone_webextstoragebridgedengine(void*, RustCallStatus*);
  void uniffi_webext_storage_fn_free_webextstoragebridgedengine(void*, RustCallStatus*);
  RustBuffer uniffi_webext_storage_fn_method_webextstoragebridgedengine_apply(void*, RustCallStatus*);
  RustBuffer uniffi_webext_storage_fn_method_webextstoragebridgedengine_ensure_current_sync_id(void*, RustBuffer, RustCallStatus*);
  int64_t uniffi_webext_storage_fn_method_webextstoragebridgedengine_last_sync(void*, RustCallStatus*);
  void uniffi_webext_storage_fn_method_webextstoragebridgedengine_prepare_for_sync(void*, RustBuffer, RustCallStatus*);
  void uniffi_webext_storage_fn_method_webextstoragebridgedengine_reset(void*, RustCallStatus*);
  RustBuffer uniffi_webext_storage_fn_method_webextstoragebridgedengine_reset_sync_id(void*, RustCallStatus*);
  void uniffi_webext_storage_fn_method_webextstoragebridgedengine_set_last_sync(void*, int64_t, RustCallStatus*);
  void uniffi_webext_storage_fn_method_webextstoragebridgedengine_set_uploaded(void*, int64_t, RustBuffer, RustCallStatus*);
  void uniffi_webext_storage_fn_method_webextstoragebridgedengine_store_incoming(void*, RustBuffer, RustCallStatus*);
  void uniffi_webext_storage_fn_method_webextstoragebridgedengine_sync_finished(void*, RustCallStatus*);
  RustBuffer uniffi_webext_storage_fn_method_webextstoragebridgedengine_sync_id(void*, RustCallStatus*);
  void uniffi_webext_storage_fn_method_webextstoragebridgedengine_sync_started(void*, RustCallStatus*);
  void uniffi_webext_storage_fn_method_webextstoragebridgedengine_wipe(void*, RustCallStatus*);
  void* uniffi_webext_storage_fn_clone_webextstoragestore(void*, RustCallStatus*);
  void uniffi_webext_storage_fn_free_webextstoragestore(void*, RustCallStatus*);
  void* uniffi_webext_storage_fn_constructor_webextstoragestore_new(RustBuffer, RustCallStatus*);
  void* uniffi_webext_storage_fn_method_webextstoragestore_bridged_engine(void*, RustCallStatus*);
  RustBuffer uniffi_webext_storage_fn_method_webextstoragestore_clear(void*, RustBuffer, RustCallStatus*);
  void uniffi_webext_storage_fn_method_webextstoragestore_close(void*, RustCallStatus*);
  RustBuffer uniffi_webext_storage_fn_method_webextstoragestore_get(void*, RustBuffer, RustBuffer, RustCallStatus*);
  uint64_t uniffi_webext_storage_fn_method_webextstoragestore_get_bytes_in_use(void*, RustBuffer, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_webext_storage_fn_method_webextstoragestore_get_synced_changes(void*, RustCallStatus*);
  RustBuffer uniffi_webext_storage_fn_method_webextstoragestore_remove(void*, RustBuffer, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_webext_storage_fn_method_webextstoragestore_set(void*, RustBuffer, RustBuffer, RustCallStatus*);
  RustBuffer ffi_webext_storage_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_webext_storage_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_webext_storage_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_webext_storage_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_u8(uint64_t);
  void ffi_webext_storage_rust_future_free_u8(uint64_t);
  uint8_t ffi_webext_storage_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_i8(uint64_t);
  void ffi_webext_storage_rust_future_free_i8(uint64_t);
  int8_t ffi_webext_storage_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_u16(uint64_t);
  void ffi_webext_storage_rust_future_free_u16(uint64_t);
  uint16_t ffi_webext_storage_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_i16(uint64_t);
  void ffi_webext_storage_rust_future_free_i16(uint64_t);
  int16_t ffi_webext_storage_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_u32(uint64_t);
  void ffi_webext_storage_rust_future_free_u32(uint64_t);
  uint32_t ffi_webext_storage_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_i32(uint64_t);
  void ffi_webext_storage_rust_future_free_i32(uint64_t);
  int32_t ffi_webext_storage_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_u64(uint64_t);
  void ffi_webext_storage_rust_future_free_u64(uint64_t);
  uint64_t ffi_webext_storage_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_i64(uint64_t);
  void ffi_webext_storage_rust_future_free_i64(uint64_t);
  int64_t ffi_webext_storage_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_f32(uint64_t);
  void ffi_webext_storage_rust_future_free_f32(uint64_t);
  float ffi_webext_storage_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_f64(uint64_t);
  void ffi_webext_storage_rust_future_free_f64(uint64_t);
  double ffi_webext_storage_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_poll_pointer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_pointer(uint64_t);
  void ffi_webext_storage_rust_future_free_pointer(uint64_t);
  void* ffi_webext_storage_rust_future_complete_pointer(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_rust_buffer(uint64_t);
  void ffi_webext_storage_rust_future_free_rust_buffer(uint64_t);
  RustBuffer ffi_webext_storage_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_void(uint64_t);
  void ffi_webext_storage_rust_future_free_void(uint64_t);
  void ffi_webext_storage_rust_future_complete_void(uint64_t, RustCallStatus*);
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_apply();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_ensure_current_sync_id();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_last_sync();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_prepare_for_sync();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_reset();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_reset_sync_id();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_set_last_sync();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_set_uploaded();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_store_incoming();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_sync_finished();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_sync_id();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_sync_started();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_wipe();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragestore_bridged_engine();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragestore_clear();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragestore_close();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragestore_get();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragestore_get_bytes_in_use();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragestore_get_synced_changes();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragestore_remove();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragestore_set();
  uint16_t uniffi_webext_storage_checksum_constructor_webextstoragestore_new();
  uint32_t ffi_webext_storage_uniffi_contract_version();

#ifdef MOZ_UNIFFI_FIXTURES
  uint64_t uniffi_arithmetical_fn_func_add(uint64_t, uint64_t, RustCallStatus*);
  uint64_t uniffi_arithmetical_fn_func_div(uint64_t, uint64_t, RustCallStatus*);
  int8_t uniffi_arithmetical_fn_func_equal(uint64_t, uint64_t, RustCallStatus*);
  uint64_t uniffi_arithmetical_fn_func_sub(uint64_t, uint64_t, RustCallStatus*);
  RustBuffer ffi_arithmetical_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_arithmetical_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_arithmetical_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_arithmetical_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_arithmetical_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_arithmetical_rust_future_cancel_u8(uint64_t);
  void ffi_arithmetical_rust_future_free_u8(uint64_t);
  uint8_t ffi_arithmetical_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_arithmetical_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_arithmetical_rust_future_cancel_i8(uint64_t);
  void ffi_arithmetical_rust_future_free_i8(uint64_t);
  int8_t ffi_arithmetical_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_arithmetical_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_arithmetical_rust_future_cancel_u16(uint64_t);
  void ffi_arithmetical_rust_future_free_u16(uint64_t);
  uint16_t ffi_arithmetical_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_arithmetical_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_arithmetical_rust_future_cancel_i16(uint64_t);
  void ffi_arithmetical_rust_future_free_i16(uint64_t);
  int16_t ffi_arithmetical_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_arithmetical_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_arithmetical_rust_future_cancel_u32(uint64_t);
  void ffi_arithmetical_rust_future_free_u32(uint64_t);
  uint32_t ffi_arithmetical_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_arithmetical_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_arithmetical_rust_future_cancel_i32(uint64_t);
  void ffi_arithmetical_rust_future_free_i32(uint64_t);
  int32_t ffi_arithmetical_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_arithmetical_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_arithmetical_rust_future_cancel_u64(uint64_t);
  void ffi_arithmetical_rust_future_free_u64(uint64_t);
  uint64_t ffi_arithmetical_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_arithmetical_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_arithmetical_rust_future_cancel_i64(uint64_t);
  void ffi_arithmetical_rust_future_free_i64(uint64_t);
  int64_t ffi_arithmetical_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_arithmetical_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_arithmetical_rust_future_cancel_f32(uint64_t);
  void ffi_arithmetical_rust_future_free_f32(uint64_t);
  float ffi_arithmetical_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_arithmetical_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_arithmetical_rust_future_cancel_f64(uint64_t);
  void ffi_arithmetical_rust_future_free_f64(uint64_t);
  double ffi_arithmetical_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_arithmetical_rust_future_poll_pointer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_arithmetical_rust_future_cancel_pointer(uint64_t);
  void ffi_arithmetical_rust_future_free_pointer(uint64_t);
  void* ffi_arithmetical_rust_future_complete_pointer(uint64_t, RustCallStatus*);
  void ffi_arithmetical_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_arithmetical_rust_future_cancel_rust_buffer(uint64_t);
  void ffi_arithmetical_rust_future_free_rust_buffer(uint64_t);
  RustBuffer ffi_arithmetical_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_arithmetical_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_arithmetical_rust_future_cancel_void(uint64_t);
  void ffi_arithmetical_rust_future_free_void(uint64_t);
  void ffi_arithmetical_rust_future_complete_void(uint64_t, RustCallStatus*);
  uint16_t uniffi_arithmetical_checksum_func_add();
  uint16_t uniffi_arithmetical_checksum_func_div();
  uint16_t uniffi_arithmetical_checksum_func_equal();
  uint16_t uniffi_arithmetical_checksum_func_sub();
  uint32_t ffi_arithmetical_uniffi_contract_version();
  RustBuffer uniffi_uniffi_custom_types_fn_func_get_custom_types_demo(RustBuffer, RustCallStatus*);
  RustBuffer ffi_uniffi_custom_types_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_uniffi_custom_types_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_uniffi_custom_types_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_uniffi_custom_types_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_uniffi_custom_types_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_custom_types_rust_future_cancel_u8(uint64_t);
  void ffi_uniffi_custom_types_rust_future_free_u8(uint64_t);
  uint8_t ffi_uniffi_custom_types_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_uniffi_custom_types_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_custom_types_rust_future_cancel_i8(uint64_t);
  void ffi_uniffi_custom_types_rust_future_free_i8(uint64_t);
  int8_t ffi_uniffi_custom_types_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_uniffi_custom_types_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_custom_types_rust_future_cancel_u16(uint64_t);
  void ffi_uniffi_custom_types_rust_future_free_u16(uint64_t);
  uint16_t ffi_uniffi_custom_types_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_uniffi_custom_types_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_custom_types_rust_future_cancel_i16(uint64_t);
  void ffi_uniffi_custom_types_rust_future_free_i16(uint64_t);
  int16_t ffi_uniffi_custom_types_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_uniffi_custom_types_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_custom_types_rust_future_cancel_u32(uint64_t);
  void ffi_uniffi_custom_types_rust_future_free_u32(uint64_t);
  uint32_t ffi_uniffi_custom_types_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_uniffi_custom_types_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_custom_types_rust_future_cancel_i32(uint64_t);
  void ffi_uniffi_custom_types_rust_future_free_i32(uint64_t);
  int32_t ffi_uniffi_custom_types_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_uniffi_custom_types_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_custom_types_rust_future_cancel_u64(uint64_t);
  void ffi_uniffi_custom_types_rust_future_free_u64(uint64_t);
  uint64_t ffi_uniffi_custom_types_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_uniffi_custom_types_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_custom_types_rust_future_cancel_i64(uint64_t);
  void ffi_uniffi_custom_types_rust_future_free_i64(uint64_t);
  int64_t ffi_uniffi_custom_types_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_uniffi_custom_types_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_custom_types_rust_future_cancel_f32(uint64_t);
  void ffi_uniffi_custom_types_rust_future_free_f32(uint64_t);
  float ffi_uniffi_custom_types_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_uniffi_custom_types_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_custom_types_rust_future_cancel_f64(uint64_t);
  void ffi_uniffi_custom_types_rust_future_free_f64(uint64_t);
  double ffi_uniffi_custom_types_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_uniffi_custom_types_rust_future_poll_pointer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_custom_types_rust_future_cancel_pointer(uint64_t);
  void ffi_uniffi_custom_types_rust_future_free_pointer(uint64_t);
  void* ffi_uniffi_custom_types_rust_future_complete_pointer(uint64_t, RustCallStatus*);
  void ffi_uniffi_custom_types_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_custom_types_rust_future_cancel_rust_buffer(uint64_t);
  void ffi_uniffi_custom_types_rust_future_free_rust_buffer(uint64_t);
  RustBuffer ffi_uniffi_custom_types_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_uniffi_custom_types_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_custom_types_rust_future_cancel_void(uint64_t);
  void ffi_uniffi_custom_types_rust_future_free_void(uint64_t);
  void ffi_uniffi_custom_types_rust_future_complete_void(uint64_t, RustCallStatus*);
  uint16_t uniffi_uniffi_custom_types_checksum_func_get_custom_types_demo();
  uint32_t ffi_uniffi_custom_types_uniffi_contract_version();
  double uniffi_uniffi_fixture_external_types_fn_func_gradient(RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_fixture_external_types_fn_func_intersection(RustBuffer, RustBuffer, RustCallStatus*);
  void uniffi_uniffi_fixture_external_types_fn_func_move_sprite_to_origin(void*, RustCallStatus*);
  RustBuffer ffi_uniffi_fixture_external_types_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_uniffi_fixture_external_types_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_uniffi_fixture_external_types_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_uniffi_fixture_external_types_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_external_types_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_external_types_rust_future_cancel_u8(uint64_t);
  void ffi_uniffi_fixture_external_types_rust_future_free_u8(uint64_t);
  uint8_t ffi_uniffi_fixture_external_types_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_external_types_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_external_types_rust_future_cancel_i8(uint64_t);
  void ffi_uniffi_fixture_external_types_rust_future_free_i8(uint64_t);
  int8_t ffi_uniffi_fixture_external_types_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_external_types_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_external_types_rust_future_cancel_u16(uint64_t);
  void ffi_uniffi_fixture_external_types_rust_future_free_u16(uint64_t);
  uint16_t ffi_uniffi_fixture_external_types_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_external_types_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_external_types_rust_future_cancel_i16(uint64_t);
  void ffi_uniffi_fixture_external_types_rust_future_free_i16(uint64_t);
  int16_t ffi_uniffi_fixture_external_types_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_external_types_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_external_types_rust_future_cancel_u32(uint64_t);
  void ffi_uniffi_fixture_external_types_rust_future_free_u32(uint64_t);
  uint32_t ffi_uniffi_fixture_external_types_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_external_types_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_external_types_rust_future_cancel_i32(uint64_t);
  void ffi_uniffi_fixture_external_types_rust_future_free_i32(uint64_t);
  int32_t ffi_uniffi_fixture_external_types_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_external_types_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_external_types_rust_future_cancel_u64(uint64_t);
  void ffi_uniffi_fixture_external_types_rust_future_free_u64(uint64_t);
  uint64_t ffi_uniffi_fixture_external_types_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_external_types_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_external_types_rust_future_cancel_i64(uint64_t);
  void ffi_uniffi_fixture_external_types_rust_future_free_i64(uint64_t);
  int64_t ffi_uniffi_fixture_external_types_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_external_types_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_external_types_rust_future_cancel_f32(uint64_t);
  void ffi_uniffi_fixture_external_types_rust_future_free_f32(uint64_t);
  float ffi_uniffi_fixture_external_types_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_external_types_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_external_types_rust_future_cancel_f64(uint64_t);
  void ffi_uniffi_fixture_external_types_rust_future_free_f64(uint64_t);
  double ffi_uniffi_fixture_external_types_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_external_types_rust_future_poll_pointer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_external_types_rust_future_cancel_pointer(uint64_t);
  void ffi_uniffi_fixture_external_types_rust_future_free_pointer(uint64_t);
  void* ffi_uniffi_fixture_external_types_rust_future_complete_pointer(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_external_types_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_external_types_rust_future_cancel_rust_buffer(uint64_t);
  void ffi_uniffi_fixture_external_types_rust_future_free_rust_buffer(uint64_t);
  RustBuffer ffi_uniffi_fixture_external_types_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_external_types_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_external_types_rust_future_cancel_void(uint64_t);
  void ffi_uniffi_fixture_external_types_rust_future_free_void(uint64_t);
  void ffi_uniffi_fixture_external_types_rust_future_complete_void(uint64_t, RustCallStatus*);
  uint16_t uniffi_uniffi_fixture_external_types_checksum_func_gradient();
  uint16_t uniffi_uniffi_fixture_external_types_checksum_func_intersection();
  uint16_t uniffi_uniffi_fixture_external_types_checksum_func_move_sprite_to_origin();
  uint32_t ffi_uniffi_fixture_external_types_uniffi_contract_version();
  typedef void (*CallbackInterfaceLoggerMethod0)(uint64_t, RustBuffer, void*, RustCallStatus*);
  typedef void (*CallbackInterfaceLoggerMethod1)(uint64_t, RustBuffer, uint32_t, RustBuffer, void*, RustCallStatus*);
  typedef void (*CallbackInterfaceLoggerMethod2)(uint64_t, void*, RustCallStatus*);
  struct VTableCallbackInterfaceLogger {
    CallbackInterfaceLoggerMethod0 log;
    CallbackInterfaceLoggerMethod1 log_repeat;
    CallbackInterfaceLoggerMethod2 finished;
    CallbackInterfaceFree uniffi_free;
  };
  void uniffi_uniffi_fixture_callbacks_fn_init_callback_vtable_logger(VTableCallbackInterfaceLogger*);
  void uniffi_uniffi_fixture_callbacks_fn_func_call_log_repeat(uint64_t, RustBuffer, uint32_t, RustBuffer, RustCallStatus*);
  void uniffi_uniffi_fixture_callbacks_fn_func_log_even_numbers(uint64_t, RustBuffer, RustCallStatus*);
  void uniffi_uniffi_fixture_callbacks_fn_func_log_even_numbers_main_thread(uint64_t, RustBuffer, RustCallStatus*);
  RustBuffer ffi_uniffi_fixture_callbacks_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_uniffi_fixture_callbacks_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_uniffi_fixture_callbacks_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_uniffi_fixture_callbacks_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_callbacks_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_callbacks_rust_future_cancel_u8(uint64_t);
  void ffi_uniffi_fixture_callbacks_rust_future_free_u8(uint64_t);
  uint8_t ffi_uniffi_fixture_callbacks_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_callbacks_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_callbacks_rust_future_cancel_i8(uint64_t);
  void ffi_uniffi_fixture_callbacks_rust_future_free_i8(uint64_t);
  int8_t ffi_uniffi_fixture_callbacks_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_callbacks_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_callbacks_rust_future_cancel_u16(uint64_t);
  void ffi_uniffi_fixture_callbacks_rust_future_free_u16(uint64_t);
  uint16_t ffi_uniffi_fixture_callbacks_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_callbacks_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_callbacks_rust_future_cancel_i16(uint64_t);
  void ffi_uniffi_fixture_callbacks_rust_future_free_i16(uint64_t);
  int16_t ffi_uniffi_fixture_callbacks_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_callbacks_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_callbacks_rust_future_cancel_u32(uint64_t);
  void ffi_uniffi_fixture_callbacks_rust_future_free_u32(uint64_t);
  uint32_t ffi_uniffi_fixture_callbacks_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_callbacks_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_callbacks_rust_future_cancel_i32(uint64_t);
  void ffi_uniffi_fixture_callbacks_rust_future_free_i32(uint64_t);
  int32_t ffi_uniffi_fixture_callbacks_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_callbacks_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_callbacks_rust_future_cancel_u64(uint64_t);
  void ffi_uniffi_fixture_callbacks_rust_future_free_u64(uint64_t);
  uint64_t ffi_uniffi_fixture_callbacks_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_callbacks_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_callbacks_rust_future_cancel_i64(uint64_t);
  void ffi_uniffi_fixture_callbacks_rust_future_free_i64(uint64_t);
  int64_t ffi_uniffi_fixture_callbacks_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_callbacks_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_callbacks_rust_future_cancel_f32(uint64_t);
  void ffi_uniffi_fixture_callbacks_rust_future_free_f32(uint64_t);
  float ffi_uniffi_fixture_callbacks_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_callbacks_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_callbacks_rust_future_cancel_f64(uint64_t);
  void ffi_uniffi_fixture_callbacks_rust_future_free_f64(uint64_t);
  double ffi_uniffi_fixture_callbacks_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_callbacks_rust_future_poll_pointer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_callbacks_rust_future_cancel_pointer(uint64_t);
  void ffi_uniffi_fixture_callbacks_rust_future_free_pointer(uint64_t);
  void* ffi_uniffi_fixture_callbacks_rust_future_complete_pointer(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_callbacks_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_callbacks_rust_future_cancel_rust_buffer(uint64_t);
  void ffi_uniffi_fixture_callbacks_rust_future_free_rust_buffer(uint64_t);
  RustBuffer ffi_uniffi_fixture_callbacks_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_callbacks_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_callbacks_rust_future_cancel_void(uint64_t);
  void ffi_uniffi_fixture_callbacks_rust_future_free_void(uint64_t);
  void ffi_uniffi_fixture_callbacks_rust_future_complete_void(uint64_t, RustCallStatus*);
  uint16_t uniffi_uniffi_fixture_callbacks_checksum_func_call_log_repeat();
  uint16_t uniffi_uniffi_fixture_callbacks_checksum_func_log_even_numbers();
  uint16_t uniffi_uniffi_fixture_callbacks_checksum_func_log_even_numbers_main_thread();
  uint16_t uniffi_uniffi_fixture_callbacks_checksum_method_logger_log();
  uint16_t uniffi_uniffi_fixture_callbacks_checksum_method_logger_log_repeat();
  uint16_t uniffi_uniffi_fixture_callbacks_checksum_method_logger_finished();
  uint32_t ffi_uniffi_fixture_callbacks_uniffi_contract_version();
  typedef void (*CallbackInterfaceRustTaskMethod0)(uint64_t, void*, RustCallStatus*);
  typedef void (*CallbackInterfaceWorkerQueueMethod0)(uint64_t, void*, void*, RustCallStatus*);
  struct VTableCallbackInterfaceRustTask {
    CallbackInterfaceRustTaskMethod0 run;
    CallbackInterfaceFree uniffi_free;
  };
  struct VTableCallbackInterfaceWorkerQueue {
    CallbackInterfaceWorkerQueueMethod0 add_task;
    CallbackInterfaceFree uniffi_free;
  };
  void* uniffi_uniffi_fixture_futures_fn_clone_futuretester(void*, RustCallStatus*);
  void uniffi_uniffi_fixture_futures_fn_free_futuretester(void*, RustCallStatus*);
  void* uniffi_uniffi_fixture_futures_fn_constructor_futuretester_init(RustCallStatus*);
  uint32_t uniffi_uniffi_fixture_futures_fn_method_futuretester_complete_futures(void*, uint8_t, RustCallStatus*);
  uint64_t uniffi_uniffi_fixture_futures_fn_method_futuretester_make_future(void*);
  void uniffi_uniffi_fixture_futures_fn_method_futuretester_wake_futures(void*, RustCallStatus*);
  void* uniffi_uniffi_fixture_futures_fn_clone_rusttask(void*, RustCallStatus*);
  void uniffi_uniffi_fixture_futures_fn_free_rusttask(void*, RustCallStatus*);
  void uniffi_uniffi_fixture_futures_fn_method_rusttask_run(void*, RustCallStatus*);
  void* uniffi_uniffi_fixture_futures_fn_clone_traveller(void*, RustCallStatus*);
  void uniffi_uniffi_fixture_futures_fn_free_traveller(void*, RustCallStatus*);
  void* uniffi_uniffi_fixture_futures_fn_constructor_traveller_new(RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_fixture_futures_fn_method_traveller_name(void*, RustCallStatus*);
  void* uniffi_uniffi_fixture_futures_fn_clone_workerqueue(void*, RustCallStatus*);
  void uniffi_uniffi_fixture_futures_fn_free_workerqueue(void*, RustCallStatus*);
  void uniffi_uniffi_fixture_futures_fn_method_workerqueue_add_task(void*, void*, RustCallStatus*);
  uint64_t uniffi_uniffi_fixture_futures_fn_func_expensive_computation();
  void uniffi_uniffi_fixture_futures_fn_func_initialize_gecko_global_worker_queue(RustCallStatus*);
  void uniffi_uniffi_fixture_futures_fn_func_initialize_global_worker_queue(void*, RustCallStatus*);
  uint64_t uniffi_uniffi_fixture_futures_fn_func_roundtrip_f32(float);
  uint64_t uniffi_uniffi_fixture_futures_fn_func_roundtrip_f64(double);
  uint64_t uniffi_uniffi_fixture_futures_fn_func_roundtrip_i16(int16_t);
  uint64_t uniffi_uniffi_fixture_futures_fn_func_roundtrip_i32(int32_t);
  uint64_t uniffi_uniffi_fixture_futures_fn_func_roundtrip_i64(int64_t);
  uint64_t uniffi_uniffi_fixture_futures_fn_func_roundtrip_i8(int8_t);
  uint64_t uniffi_uniffi_fixture_futures_fn_func_roundtrip_map(RustBuffer);
  uint64_t uniffi_uniffi_fixture_futures_fn_func_roundtrip_obj(void*);
  uint64_t uniffi_uniffi_fixture_futures_fn_func_roundtrip_string(RustBuffer);
  uint64_t uniffi_uniffi_fixture_futures_fn_func_roundtrip_u16(uint16_t);
  uint64_t uniffi_uniffi_fixture_futures_fn_func_roundtrip_u32(uint32_t);
  uint64_t uniffi_uniffi_fixture_futures_fn_func_roundtrip_u64(uint64_t);
  uint64_t uniffi_uniffi_fixture_futures_fn_func_roundtrip_u8(uint8_t);
  uint64_t uniffi_uniffi_fixture_futures_fn_func_roundtrip_vec(RustBuffer);
  RustBuffer ffi_uniffi_fixture_futures_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_uniffi_fixture_futures_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_uniffi_fixture_futures_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_uniffi_fixture_futures_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_futures_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_futures_rust_future_cancel_u8(uint64_t);
  void ffi_uniffi_fixture_futures_rust_future_free_u8(uint64_t);
  uint8_t ffi_uniffi_fixture_futures_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_futures_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_futures_rust_future_cancel_i8(uint64_t);
  void ffi_uniffi_fixture_futures_rust_future_free_i8(uint64_t);
  int8_t ffi_uniffi_fixture_futures_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_futures_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_futures_rust_future_cancel_u16(uint64_t);
  void ffi_uniffi_fixture_futures_rust_future_free_u16(uint64_t);
  uint16_t ffi_uniffi_fixture_futures_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_futures_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_futures_rust_future_cancel_i16(uint64_t);
  void ffi_uniffi_fixture_futures_rust_future_free_i16(uint64_t);
  int16_t ffi_uniffi_fixture_futures_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_futures_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_futures_rust_future_cancel_u32(uint64_t);
  void ffi_uniffi_fixture_futures_rust_future_free_u32(uint64_t);
  uint32_t ffi_uniffi_fixture_futures_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_futures_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_futures_rust_future_cancel_i32(uint64_t);
  void ffi_uniffi_fixture_futures_rust_future_free_i32(uint64_t);
  int32_t ffi_uniffi_fixture_futures_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_futures_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_futures_rust_future_cancel_u64(uint64_t);
  void ffi_uniffi_fixture_futures_rust_future_free_u64(uint64_t);
  uint64_t ffi_uniffi_fixture_futures_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_futures_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_futures_rust_future_cancel_i64(uint64_t);
  void ffi_uniffi_fixture_futures_rust_future_free_i64(uint64_t);
  int64_t ffi_uniffi_fixture_futures_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_futures_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_futures_rust_future_cancel_f32(uint64_t);
  void ffi_uniffi_fixture_futures_rust_future_free_f32(uint64_t);
  float ffi_uniffi_fixture_futures_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_futures_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_futures_rust_future_cancel_f64(uint64_t);
  void ffi_uniffi_fixture_futures_rust_future_free_f64(uint64_t);
  double ffi_uniffi_fixture_futures_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_futures_rust_future_poll_pointer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_futures_rust_future_cancel_pointer(uint64_t);
  void ffi_uniffi_fixture_futures_rust_future_free_pointer(uint64_t);
  void* ffi_uniffi_fixture_futures_rust_future_complete_pointer(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_futures_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_futures_rust_future_cancel_rust_buffer(uint64_t);
  void ffi_uniffi_fixture_futures_rust_future_free_rust_buffer(uint64_t);
  RustBuffer ffi_uniffi_fixture_futures_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_futures_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_futures_rust_future_cancel_void(uint64_t);
  void ffi_uniffi_fixture_futures_rust_future_free_void(uint64_t);
  void ffi_uniffi_fixture_futures_rust_future_complete_void(uint64_t, RustCallStatus*);
  uint16_t uniffi_uniffi_fixture_futures_checksum_func_expensive_computation();
  uint16_t uniffi_uniffi_fixture_futures_checksum_func_initialize_gecko_global_worker_queue();
  uint16_t uniffi_uniffi_fixture_futures_checksum_func_initialize_global_worker_queue();
  uint16_t uniffi_uniffi_fixture_futures_checksum_func_roundtrip_f32();
  uint16_t uniffi_uniffi_fixture_futures_checksum_func_roundtrip_f64();
  uint16_t uniffi_uniffi_fixture_futures_checksum_func_roundtrip_i16();
  uint16_t uniffi_uniffi_fixture_futures_checksum_func_roundtrip_i32();
  uint16_t uniffi_uniffi_fixture_futures_checksum_func_roundtrip_i64();
  uint16_t uniffi_uniffi_fixture_futures_checksum_func_roundtrip_i8();
  uint16_t uniffi_uniffi_fixture_futures_checksum_func_roundtrip_map();
  uint16_t uniffi_uniffi_fixture_futures_checksum_func_roundtrip_obj();
  uint16_t uniffi_uniffi_fixture_futures_checksum_func_roundtrip_string();
  uint16_t uniffi_uniffi_fixture_futures_checksum_func_roundtrip_u16();
  uint16_t uniffi_uniffi_fixture_futures_checksum_func_roundtrip_u32();
  uint16_t uniffi_uniffi_fixture_futures_checksum_func_roundtrip_u64();
  uint16_t uniffi_uniffi_fixture_futures_checksum_func_roundtrip_u8();
  uint16_t uniffi_uniffi_fixture_futures_checksum_func_roundtrip_vec();
  uint16_t uniffi_uniffi_fixture_futures_checksum_method_futuretester_complete_futures();
  uint16_t uniffi_uniffi_fixture_futures_checksum_method_futuretester_make_future();
  uint16_t uniffi_uniffi_fixture_futures_checksum_method_futuretester_wake_futures();
  uint16_t uniffi_uniffi_fixture_futures_checksum_method_rusttask_run();
  uint16_t uniffi_uniffi_fixture_futures_checksum_method_traveller_name();
  uint16_t uniffi_uniffi_fixture_futures_checksum_method_workerqueue_add_task();
  uint16_t uniffi_uniffi_fixture_futures_checksum_constructor_futuretester_init();
  uint16_t uniffi_uniffi_fixture_futures_checksum_constructor_traveller_new();
  uint32_t ffi_uniffi_fixture_futures_uniffi_contract_version();
  double uniffi_uniffi_geometry_fn_func_gradient(RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_geometry_fn_func_intersection(RustBuffer, RustBuffer, RustCallStatus*);
  RustBuffer ffi_uniffi_geometry_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_uniffi_geometry_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_uniffi_geometry_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_uniffi_geometry_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_uniffi_geometry_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_geometry_rust_future_cancel_u8(uint64_t);
  void ffi_uniffi_geometry_rust_future_free_u8(uint64_t);
  uint8_t ffi_uniffi_geometry_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_uniffi_geometry_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_geometry_rust_future_cancel_i8(uint64_t);
  void ffi_uniffi_geometry_rust_future_free_i8(uint64_t);
  int8_t ffi_uniffi_geometry_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_uniffi_geometry_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_geometry_rust_future_cancel_u16(uint64_t);
  void ffi_uniffi_geometry_rust_future_free_u16(uint64_t);
  uint16_t ffi_uniffi_geometry_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_uniffi_geometry_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_geometry_rust_future_cancel_i16(uint64_t);
  void ffi_uniffi_geometry_rust_future_free_i16(uint64_t);
  int16_t ffi_uniffi_geometry_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_uniffi_geometry_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_geometry_rust_future_cancel_u32(uint64_t);
  void ffi_uniffi_geometry_rust_future_free_u32(uint64_t);
  uint32_t ffi_uniffi_geometry_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_uniffi_geometry_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_geometry_rust_future_cancel_i32(uint64_t);
  void ffi_uniffi_geometry_rust_future_free_i32(uint64_t);
  int32_t ffi_uniffi_geometry_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_uniffi_geometry_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_geometry_rust_future_cancel_u64(uint64_t);
  void ffi_uniffi_geometry_rust_future_free_u64(uint64_t);
  uint64_t ffi_uniffi_geometry_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_uniffi_geometry_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_geometry_rust_future_cancel_i64(uint64_t);
  void ffi_uniffi_geometry_rust_future_free_i64(uint64_t);
  int64_t ffi_uniffi_geometry_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_uniffi_geometry_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_geometry_rust_future_cancel_f32(uint64_t);
  void ffi_uniffi_geometry_rust_future_free_f32(uint64_t);
  float ffi_uniffi_geometry_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_uniffi_geometry_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_geometry_rust_future_cancel_f64(uint64_t);
  void ffi_uniffi_geometry_rust_future_free_f64(uint64_t);
  double ffi_uniffi_geometry_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_uniffi_geometry_rust_future_poll_pointer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_geometry_rust_future_cancel_pointer(uint64_t);
  void ffi_uniffi_geometry_rust_future_free_pointer(uint64_t);
  void* ffi_uniffi_geometry_rust_future_complete_pointer(uint64_t, RustCallStatus*);
  void ffi_uniffi_geometry_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_geometry_rust_future_cancel_rust_buffer(uint64_t);
  void ffi_uniffi_geometry_rust_future_free_rust_buffer(uint64_t);
  RustBuffer ffi_uniffi_geometry_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_uniffi_geometry_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_geometry_rust_future_cancel_void(uint64_t);
  void ffi_uniffi_geometry_rust_future_free_void(uint64_t);
  void ffi_uniffi_geometry_rust_future_complete_void(uint64_t, RustCallStatus*);
  uint16_t uniffi_uniffi_geometry_checksum_func_gradient();
  uint16_t uniffi_uniffi_geometry_checksum_func_intersection();
  uint32_t ffi_uniffi_geometry_uniffi_contract_version();
  void* uniffi_uniffi_fixture_refcounts_fn_clone_singletonobject(void*, RustCallStatus*);
  void uniffi_uniffi_fixture_refcounts_fn_free_singletonobject(void*, RustCallStatus*);
  void uniffi_uniffi_fixture_refcounts_fn_method_singletonobject_method(void*, RustCallStatus*);
  int32_t uniffi_uniffi_fixture_refcounts_fn_func_get_js_refcount(RustCallStatus*);
  void* uniffi_uniffi_fixture_refcounts_fn_func_get_singleton(RustCallStatus*);
  RustBuffer ffi_uniffi_fixture_refcounts_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_uniffi_fixture_refcounts_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_uniffi_fixture_refcounts_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_uniffi_fixture_refcounts_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_refcounts_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_refcounts_rust_future_cancel_u8(uint64_t);
  void ffi_uniffi_fixture_refcounts_rust_future_free_u8(uint64_t);
  uint8_t ffi_uniffi_fixture_refcounts_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_refcounts_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_refcounts_rust_future_cancel_i8(uint64_t);
  void ffi_uniffi_fixture_refcounts_rust_future_free_i8(uint64_t);
  int8_t ffi_uniffi_fixture_refcounts_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_refcounts_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_refcounts_rust_future_cancel_u16(uint64_t);
  void ffi_uniffi_fixture_refcounts_rust_future_free_u16(uint64_t);
  uint16_t ffi_uniffi_fixture_refcounts_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_refcounts_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_refcounts_rust_future_cancel_i16(uint64_t);
  void ffi_uniffi_fixture_refcounts_rust_future_free_i16(uint64_t);
  int16_t ffi_uniffi_fixture_refcounts_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_refcounts_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_refcounts_rust_future_cancel_u32(uint64_t);
  void ffi_uniffi_fixture_refcounts_rust_future_free_u32(uint64_t);
  uint32_t ffi_uniffi_fixture_refcounts_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_refcounts_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_refcounts_rust_future_cancel_i32(uint64_t);
  void ffi_uniffi_fixture_refcounts_rust_future_free_i32(uint64_t);
  int32_t ffi_uniffi_fixture_refcounts_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_refcounts_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_refcounts_rust_future_cancel_u64(uint64_t);
  void ffi_uniffi_fixture_refcounts_rust_future_free_u64(uint64_t);
  uint64_t ffi_uniffi_fixture_refcounts_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_refcounts_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_refcounts_rust_future_cancel_i64(uint64_t);
  void ffi_uniffi_fixture_refcounts_rust_future_free_i64(uint64_t);
  int64_t ffi_uniffi_fixture_refcounts_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_refcounts_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_refcounts_rust_future_cancel_f32(uint64_t);
  void ffi_uniffi_fixture_refcounts_rust_future_free_f32(uint64_t);
  float ffi_uniffi_fixture_refcounts_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_refcounts_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_refcounts_rust_future_cancel_f64(uint64_t);
  void ffi_uniffi_fixture_refcounts_rust_future_free_f64(uint64_t);
  double ffi_uniffi_fixture_refcounts_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_refcounts_rust_future_poll_pointer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_refcounts_rust_future_cancel_pointer(uint64_t);
  void ffi_uniffi_fixture_refcounts_rust_future_free_pointer(uint64_t);
  void* ffi_uniffi_fixture_refcounts_rust_future_complete_pointer(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_refcounts_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_refcounts_rust_future_cancel_rust_buffer(uint64_t);
  void ffi_uniffi_fixture_refcounts_rust_future_free_rust_buffer(uint64_t);
  RustBuffer ffi_uniffi_fixture_refcounts_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_uniffi_fixture_refcounts_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_fixture_refcounts_rust_future_cancel_void(uint64_t);
  void ffi_uniffi_fixture_refcounts_rust_future_free_void(uint64_t);
  void ffi_uniffi_fixture_refcounts_rust_future_complete_void(uint64_t, RustCallStatus*);
  uint16_t uniffi_uniffi_fixture_refcounts_checksum_func_get_js_refcount();
  uint16_t uniffi_uniffi_fixture_refcounts_checksum_func_get_singleton();
  uint16_t uniffi_uniffi_fixture_refcounts_checksum_method_singletonobject_method();
  uint32_t ffi_uniffi_fixture_refcounts_uniffi_contract_version();
  void* uniffi_uniffi_rondpoint_fn_clone_optionneur(void*, RustCallStatus*);
  void uniffi_uniffi_rondpoint_fn_free_optionneur(void*, RustCallStatus*);
  void* uniffi_uniffi_rondpoint_fn_constructor_optionneur_new(RustCallStatus*);
  int8_t uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_boolean(void*, int8_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_enum(void*, RustBuffer, RustCallStatus*);
  float uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_f32(void*, float, RustCallStatus*);
  double uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_f64(void*, double, RustCallStatus*);
  int16_t uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_i16_dec(void*, int16_t, RustCallStatus*);
  int16_t uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_i16_hex(void*, int16_t, RustCallStatus*);
  int32_t uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_i32_dec(void*, int32_t, RustCallStatus*);
  int32_t uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_i32_hex(void*, int32_t, RustCallStatus*);
  int64_t uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_i64_dec(void*, int64_t, RustCallStatus*);
  int64_t uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_i64_hex(void*, int64_t, RustCallStatus*);
  int8_t uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_i8_dec(void*, int8_t, RustCallStatus*);
  int8_t uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_i8_hex(void*, int8_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_null(void*, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_sequence(void*, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_string(void*, RustBuffer, RustCallStatus*);
  uint16_t uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_u16_dec(void*, uint16_t, RustCallStatus*);
  uint16_t uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_u16_hex(void*, uint16_t, RustCallStatus*);
  uint32_t uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_u32_dec(void*, uint32_t, RustCallStatus*);
  uint32_t uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_u32_hex(void*, uint32_t, RustCallStatus*);
  uint32_t uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_u32_oct(void*, uint32_t, RustCallStatus*);
  uint64_t uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_u64_dec(void*, uint64_t, RustCallStatus*);
  uint64_t uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_u64_hex(void*, uint64_t, RustCallStatus*);
  uint8_t uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_u8_dec(void*, uint8_t, RustCallStatus*);
  uint8_t uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_u8_hex(void*, uint8_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_zero(void*, RustBuffer, RustCallStatus*);
  void* uniffi_uniffi_rondpoint_fn_clone_retourneur(void*, RustCallStatus*);
  void uniffi_uniffi_rondpoint_fn_free_retourneur(void*, RustCallStatus*);
  void* uniffi_uniffi_rondpoint_fn_constructor_retourneur_new(RustCallStatus*);
  int8_t uniffi_uniffi_rondpoint_fn_method_retourneur_identique_boolean(void*, int8_t, RustCallStatus*);
  double uniffi_uniffi_rondpoint_fn_method_retourneur_identique_double(void*, double, RustCallStatus*);
  float uniffi_uniffi_rondpoint_fn_method_retourneur_identique_float(void*, float, RustCallStatus*);
  int16_t uniffi_uniffi_rondpoint_fn_method_retourneur_identique_i16(void*, int16_t, RustCallStatus*);
  int32_t uniffi_uniffi_rondpoint_fn_method_retourneur_identique_i32(void*, int32_t, RustCallStatus*);
  int64_t uniffi_uniffi_rondpoint_fn_method_retourneur_identique_i64(void*, int64_t, RustCallStatus*);
  int8_t uniffi_uniffi_rondpoint_fn_method_retourneur_identique_i8(void*, int8_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_method_retourneur_identique_nombres(void*, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_method_retourneur_identique_nombres_signes(void*, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_method_retourneur_identique_optionneur_dictionnaire(void*, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_method_retourneur_identique_string(void*, RustBuffer, RustCallStatus*);
  uint16_t uniffi_uniffi_rondpoint_fn_method_retourneur_identique_u16(void*, uint16_t, RustCallStatus*);
  uint32_t uniffi_uniffi_rondpoint_fn_method_retourneur_identique_u32(void*, uint32_t, RustCallStatus*);
  uint64_t uniffi_uniffi_rondpoint_fn_method_retourneur_identique_u64(void*, uint64_t, RustCallStatus*);
  uint8_t uniffi_uniffi_rondpoint_fn_method_retourneur_identique_u8(void*, uint8_t, RustCallStatus*);
  void* uniffi_uniffi_rondpoint_fn_clone_stringifier(void*, RustCallStatus*);
  void uniffi_uniffi_rondpoint_fn_free_stringifier(void*, RustCallStatus*);
  void* uniffi_uniffi_rondpoint_fn_constructor_stringifier_new(RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_boolean(void*, int8_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_double(void*, double, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_float(void*, float, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_i16(void*, int16_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_i32(void*, int32_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_i64(void*, int64_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_i8(void*, int8_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_u16(void*, uint16_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_u32(void*, uint32_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_u64(void*, uint64_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_u8(void*, uint8_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_method_stringifier_well_known_string(void*, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_func_copie_carte(RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_func_copie_dictionnaire(RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_func_copie_enumeration(RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_rondpoint_fn_func_copie_enumerations(RustBuffer, RustCallStatus*);
  int8_t uniffi_uniffi_rondpoint_fn_func_switcheroo(int8_t, RustCallStatus*);
  RustBuffer ffi_uniffi_rondpoint_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_uniffi_rondpoint_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_uniffi_rondpoint_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_uniffi_rondpoint_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_uniffi_rondpoint_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_rondpoint_rust_future_cancel_u8(uint64_t);
  void ffi_uniffi_rondpoint_rust_future_free_u8(uint64_t);
  uint8_t ffi_uniffi_rondpoint_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_uniffi_rondpoint_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_rondpoint_rust_future_cancel_i8(uint64_t);
  void ffi_uniffi_rondpoint_rust_future_free_i8(uint64_t);
  int8_t ffi_uniffi_rondpoint_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_uniffi_rondpoint_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_rondpoint_rust_future_cancel_u16(uint64_t);
  void ffi_uniffi_rondpoint_rust_future_free_u16(uint64_t);
  uint16_t ffi_uniffi_rondpoint_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_uniffi_rondpoint_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_rondpoint_rust_future_cancel_i16(uint64_t);
  void ffi_uniffi_rondpoint_rust_future_free_i16(uint64_t);
  int16_t ffi_uniffi_rondpoint_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_uniffi_rondpoint_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_rondpoint_rust_future_cancel_u32(uint64_t);
  void ffi_uniffi_rondpoint_rust_future_free_u32(uint64_t);
  uint32_t ffi_uniffi_rondpoint_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_uniffi_rondpoint_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_rondpoint_rust_future_cancel_i32(uint64_t);
  void ffi_uniffi_rondpoint_rust_future_free_i32(uint64_t);
  int32_t ffi_uniffi_rondpoint_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_uniffi_rondpoint_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_rondpoint_rust_future_cancel_u64(uint64_t);
  void ffi_uniffi_rondpoint_rust_future_free_u64(uint64_t);
  uint64_t ffi_uniffi_rondpoint_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_uniffi_rondpoint_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_rondpoint_rust_future_cancel_i64(uint64_t);
  void ffi_uniffi_rondpoint_rust_future_free_i64(uint64_t);
  int64_t ffi_uniffi_rondpoint_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_uniffi_rondpoint_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_rondpoint_rust_future_cancel_f32(uint64_t);
  void ffi_uniffi_rondpoint_rust_future_free_f32(uint64_t);
  float ffi_uniffi_rondpoint_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_uniffi_rondpoint_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_rondpoint_rust_future_cancel_f64(uint64_t);
  void ffi_uniffi_rondpoint_rust_future_free_f64(uint64_t);
  double ffi_uniffi_rondpoint_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_uniffi_rondpoint_rust_future_poll_pointer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_rondpoint_rust_future_cancel_pointer(uint64_t);
  void ffi_uniffi_rondpoint_rust_future_free_pointer(uint64_t);
  void* ffi_uniffi_rondpoint_rust_future_complete_pointer(uint64_t, RustCallStatus*);
  void ffi_uniffi_rondpoint_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_rondpoint_rust_future_cancel_rust_buffer(uint64_t);
  void ffi_uniffi_rondpoint_rust_future_free_rust_buffer(uint64_t);
  RustBuffer ffi_uniffi_rondpoint_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_uniffi_rondpoint_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_rondpoint_rust_future_cancel_void(uint64_t);
  void ffi_uniffi_rondpoint_rust_future_free_void(uint64_t);
  void ffi_uniffi_rondpoint_rust_future_complete_void(uint64_t, RustCallStatus*);
  uint16_t uniffi_uniffi_rondpoint_checksum_func_copie_carte();
  uint16_t uniffi_uniffi_rondpoint_checksum_func_copie_dictionnaire();
  uint16_t uniffi_uniffi_rondpoint_checksum_func_copie_enumeration();
  uint16_t uniffi_uniffi_rondpoint_checksum_func_copie_enumerations();
  uint16_t uniffi_uniffi_rondpoint_checksum_func_switcheroo();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_optionneur_sinon_boolean();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_optionneur_sinon_enum();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_optionneur_sinon_f32();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_optionneur_sinon_f64();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_optionneur_sinon_i16_dec();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_optionneur_sinon_i16_hex();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_optionneur_sinon_i32_dec();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_optionneur_sinon_i32_hex();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_optionneur_sinon_i64_dec();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_optionneur_sinon_i64_hex();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_optionneur_sinon_i8_dec();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_optionneur_sinon_i8_hex();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_optionneur_sinon_null();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_optionneur_sinon_sequence();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_optionneur_sinon_string();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_optionneur_sinon_u16_dec();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_optionneur_sinon_u16_hex();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_optionneur_sinon_u32_dec();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_optionneur_sinon_u32_hex();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_optionneur_sinon_u32_oct();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_optionneur_sinon_u64_dec();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_optionneur_sinon_u64_hex();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_optionneur_sinon_u8_dec();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_optionneur_sinon_u8_hex();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_optionneur_sinon_zero();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_retourneur_identique_boolean();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_retourneur_identique_double();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_retourneur_identique_float();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_retourneur_identique_i16();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_retourneur_identique_i32();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_retourneur_identique_i64();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_retourneur_identique_i8();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_retourneur_identique_nombres();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_retourneur_identique_nombres_signes();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_retourneur_identique_optionneur_dictionnaire();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_retourneur_identique_string();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_retourneur_identique_u16();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_retourneur_identique_u32();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_retourneur_identique_u64();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_retourneur_identique_u8();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_stringifier_to_string_boolean();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_stringifier_to_string_double();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_stringifier_to_string_float();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_stringifier_to_string_i16();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_stringifier_to_string_i32();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_stringifier_to_string_i64();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_stringifier_to_string_i8();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_stringifier_to_string_u16();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_stringifier_to_string_u32();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_stringifier_to_string_u64();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_stringifier_to_string_u8();
  uint16_t uniffi_uniffi_rondpoint_checksum_method_stringifier_well_known_string();
  uint16_t uniffi_uniffi_rondpoint_checksum_constructor_optionneur_new();
  uint16_t uniffi_uniffi_rondpoint_checksum_constructor_retourneur_new();
  uint16_t uniffi_uniffi_rondpoint_checksum_constructor_stringifier_new();
  uint32_t ffi_uniffi_rondpoint_uniffi_contract_version();
  void* uniffi_uniffi_sprites_fn_clone_sprite(void*, RustCallStatus*);
  void uniffi_uniffi_sprites_fn_free_sprite(void*, RustCallStatus*);
  void* uniffi_uniffi_sprites_fn_constructor_sprite_new(RustBuffer, RustCallStatus*);
  void* uniffi_uniffi_sprites_fn_constructor_sprite_new_relative_to(RustBuffer, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_sprites_fn_method_sprite_get_position(void*, RustCallStatus*);
  void uniffi_uniffi_sprites_fn_method_sprite_move_by(void*, RustBuffer, RustCallStatus*);
  void uniffi_uniffi_sprites_fn_method_sprite_move_to(void*, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_sprites_fn_func_translate(RustBuffer, RustBuffer, RustCallStatus*);
  RustBuffer ffi_uniffi_sprites_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_uniffi_sprites_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_uniffi_sprites_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_uniffi_sprites_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_uniffi_sprites_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_sprites_rust_future_cancel_u8(uint64_t);
  void ffi_uniffi_sprites_rust_future_free_u8(uint64_t);
  uint8_t ffi_uniffi_sprites_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_uniffi_sprites_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_sprites_rust_future_cancel_i8(uint64_t);
  void ffi_uniffi_sprites_rust_future_free_i8(uint64_t);
  int8_t ffi_uniffi_sprites_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_uniffi_sprites_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_sprites_rust_future_cancel_u16(uint64_t);
  void ffi_uniffi_sprites_rust_future_free_u16(uint64_t);
  uint16_t ffi_uniffi_sprites_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_uniffi_sprites_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_sprites_rust_future_cancel_i16(uint64_t);
  void ffi_uniffi_sprites_rust_future_free_i16(uint64_t);
  int16_t ffi_uniffi_sprites_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_uniffi_sprites_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_sprites_rust_future_cancel_u32(uint64_t);
  void ffi_uniffi_sprites_rust_future_free_u32(uint64_t);
  uint32_t ffi_uniffi_sprites_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_uniffi_sprites_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_sprites_rust_future_cancel_i32(uint64_t);
  void ffi_uniffi_sprites_rust_future_free_i32(uint64_t);
  int32_t ffi_uniffi_sprites_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_uniffi_sprites_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_sprites_rust_future_cancel_u64(uint64_t);
  void ffi_uniffi_sprites_rust_future_free_u64(uint64_t);
  uint64_t ffi_uniffi_sprites_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_uniffi_sprites_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_sprites_rust_future_cancel_i64(uint64_t);
  void ffi_uniffi_sprites_rust_future_free_i64(uint64_t);
  int64_t ffi_uniffi_sprites_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_uniffi_sprites_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_sprites_rust_future_cancel_f32(uint64_t);
  void ffi_uniffi_sprites_rust_future_free_f32(uint64_t);
  float ffi_uniffi_sprites_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_uniffi_sprites_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_sprites_rust_future_cancel_f64(uint64_t);
  void ffi_uniffi_sprites_rust_future_free_f64(uint64_t);
  double ffi_uniffi_sprites_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_uniffi_sprites_rust_future_poll_pointer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_sprites_rust_future_cancel_pointer(uint64_t);
  void ffi_uniffi_sprites_rust_future_free_pointer(uint64_t);
  void* ffi_uniffi_sprites_rust_future_complete_pointer(uint64_t, RustCallStatus*);
  void ffi_uniffi_sprites_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_sprites_rust_future_cancel_rust_buffer(uint64_t);
  void ffi_uniffi_sprites_rust_future_free_rust_buffer(uint64_t);
  RustBuffer ffi_uniffi_sprites_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_uniffi_sprites_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_sprites_rust_future_cancel_void(uint64_t);
  void ffi_uniffi_sprites_rust_future_free_void(uint64_t);
  void ffi_uniffi_sprites_rust_future_complete_void(uint64_t, RustCallStatus*);
  uint16_t uniffi_uniffi_sprites_checksum_func_translate();
  uint16_t uniffi_uniffi_sprites_checksum_method_sprite_get_position();
  uint16_t uniffi_uniffi_sprites_checksum_method_sprite_move_by();
  uint16_t uniffi_uniffi_sprites_checksum_method_sprite_move_to();
  uint16_t uniffi_uniffi_sprites_checksum_constructor_sprite_new();
  uint16_t uniffi_uniffi_sprites_checksum_constructor_sprite_new_relative_to();
  uint32_t ffi_uniffi_sprites_uniffi_contract_version();
  void* uniffi_uniffi_todolist_fn_clone_todolist(void*, RustCallStatus*);
  void uniffi_uniffi_todolist_fn_free_todolist(void*, RustCallStatus*);
  void* uniffi_uniffi_todolist_fn_constructor_todolist_new(RustCallStatus*);
  void uniffi_uniffi_todolist_fn_method_todolist_add_entries(void*, RustBuffer, RustCallStatus*);
  void uniffi_uniffi_todolist_fn_method_todolist_add_entry(void*, RustBuffer, RustCallStatus*);
  void uniffi_uniffi_todolist_fn_method_todolist_add_item(void*, RustBuffer, RustCallStatus*);
  void uniffi_uniffi_todolist_fn_method_todolist_add_items(void*, RustBuffer, RustCallStatus*);
  void uniffi_uniffi_todolist_fn_method_todolist_clear_item(void*, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_todolist_fn_method_todolist_get_entries(void*, RustCallStatus*);
  RustBuffer uniffi_uniffi_todolist_fn_method_todolist_get_first(void*, RustCallStatus*);
  RustBuffer uniffi_uniffi_todolist_fn_method_todolist_get_items(void*, RustCallStatus*);
  RustBuffer uniffi_uniffi_todolist_fn_method_todolist_get_last(void*, RustCallStatus*);
  RustBuffer uniffi_uniffi_todolist_fn_method_todolist_get_last_entry(void*, RustCallStatus*);
  void uniffi_uniffi_todolist_fn_method_todolist_make_default(void*, RustCallStatus*);
  RustBuffer uniffi_uniffi_todolist_fn_func_create_entry_with(RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_todolist_fn_func_get_default_list(RustCallStatus*);
  void uniffi_uniffi_todolist_fn_func_set_default_list(void*, RustCallStatus*);
  RustBuffer ffi_uniffi_todolist_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_uniffi_todolist_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_uniffi_todolist_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_uniffi_todolist_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_uniffi_todolist_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_todolist_rust_future_cancel_u8(uint64_t);
  void ffi_uniffi_todolist_rust_future_free_u8(uint64_t);
  uint8_t ffi_uniffi_todolist_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_uniffi_todolist_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_todolist_rust_future_cancel_i8(uint64_t);
  void ffi_uniffi_todolist_rust_future_free_i8(uint64_t);
  int8_t ffi_uniffi_todolist_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_uniffi_todolist_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_todolist_rust_future_cancel_u16(uint64_t);
  void ffi_uniffi_todolist_rust_future_free_u16(uint64_t);
  uint16_t ffi_uniffi_todolist_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_uniffi_todolist_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_todolist_rust_future_cancel_i16(uint64_t);
  void ffi_uniffi_todolist_rust_future_free_i16(uint64_t);
  int16_t ffi_uniffi_todolist_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_uniffi_todolist_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_todolist_rust_future_cancel_u32(uint64_t);
  void ffi_uniffi_todolist_rust_future_free_u32(uint64_t);
  uint32_t ffi_uniffi_todolist_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_uniffi_todolist_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_todolist_rust_future_cancel_i32(uint64_t);
  void ffi_uniffi_todolist_rust_future_free_i32(uint64_t);
  int32_t ffi_uniffi_todolist_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_uniffi_todolist_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_todolist_rust_future_cancel_u64(uint64_t);
  void ffi_uniffi_todolist_rust_future_free_u64(uint64_t);
  uint64_t ffi_uniffi_todolist_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_uniffi_todolist_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_todolist_rust_future_cancel_i64(uint64_t);
  void ffi_uniffi_todolist_rust_future_free_i64(uint64_t);
  int64_t ffi_uniffi_todolist_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_uniffi_todolist_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_todolist_rust_future_cancel_f32(uint64_t);
  void ffi_uniffi_todolist_rust_future_free_f32(uint64_t);
  float ffi_uniffi_todolist_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_uniffi_todolist_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_todolist_rust_future_cancel_f64(uint64_t);
  void ffi_uniffi_todolist_rust_future_free_f64(uint64_t);
  double ffi_uniffi_todolist_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_uniffi_todolist_rust_future_poll_pointer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_todolist_rust_future_cancel_pointer(uint64_t);
  void ffi_uniffi_todolist_rust_future_free_pointer(uint64_t);
  void* ffi_uniffi_todolist_rust_future_complete_pointer(uint64_t, RustCallStatus*);
  void ffi_uniffi_todolist_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_todolist_rust_future_cancel_rust_buffer(uint64_t);
  void ffi_uniffi_todolist_rust_future_free_rust_buffer(uint64_t);
  RustBuffer ffi_uniffi_todolist_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_uniffi_todolist_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_todolist_rust_future_cancel_void(uint64_t);
  void ffi_uniffi_todolist_rust_future_free_void(uint64_t);
  void ffi_uniffi_todolist_rust_future_complete_void(uint64_t, RustCallStatus*);
  uint16_t uniffi_uniffi_todolist_checksum_func_create_entry_with();
  uint16_t uniffi_uniffi_todolist_checksum_func_get_default_list();
  uint16_t uniffi_uniffi_todolist_checksum_func_set_default_list();
  uint16_t uniffi_uniffi_todolist_checksum_method_todolist_add_entries();
  uint16_t uniffi_uniffi_todolist_checksum_method_todolist_add_entry();
  uint16_t uniffi_uniffi_todolist_checksum_method_todolist_add_item();
  uint16_t uniffi_uniffi_todolist_checksum_method_todolist_add_items();
  uint16_t uniffi_uniffi_todolist_checksum_method_todolist_clear_item();
  uint16_t uniffi_uniffi_todolist_checksum_method_todolist_get_entries();
  uint16_t uniffi_uniffi_todolist_checksum_method_todolist_get_first();
  uint16_t uniffi_uniffi_todolist_checksum_method_todolist_get_items();
  uint16_t uniffi_uniffi_todolist_checksum_method_todolist_get_last();
  uint16_t uniffi_uniffi_todolist_checksum_method_todolist_get_last_entry();
  uint16_t uniffi_uniffi_todolist_checksum_method_todolist_make_default();
  uint16_t uniffi_uniffi_todolist_checksum_constructor_todolist_new();
  uint32_t ffi_uniffi_todolist_uniffi_contract_version();
  typedef void (*CallbackInterfaceCalcMethod0)(uint64_t, uint32_t, uint32_t, uint32_t*, RustCallStatus*);
  struct VTableCallbackInterfaceCalc {
    CallbackInterfaceCalcMethod0 add;
    CallbackInterfaceFree uniffi_free;
  };
  void* uniffi_uniffi_trait_interfaces_fn_clone_calc(void*, RustCallStatus*);
  void uniffi_uniffi_trait_interfaces_fn_free_calc(void*, RustCallStatus*);
  uint32_t uniffi_uniffi_trait_interfaces_fn_method_calc_add(void*, uint32_t, uint32_t, RustCallStatus*);
  void* uniffi_uniffi_trait_interfaces_fn_func_make_buggy_calculator(RustCallStatus*);
  void* uniffi_uniffi_trait_interfaces_fn_func_make_calculator(RustCallStatus*);
  RustBuffer ffi_uniffi_trait_interfaces_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_uniffi_trait_interfaces_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_uniffi_trait_interfaces_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_uniffi_trait_interfaces_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_uniffi_trait_interfaces_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_trait_interfaces_rust_future_cancel_u8(uint64_t);
  void ffi_uniffi_trait_interfaces_rust_future_free_u8(uint64_t);
  uint8_t ffi_uniffi_trait_interfaces_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_uniffi_trait_interfaces_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_trait_interfaces_rust_future_cancel_i8(uint64_t);
  void ffi_uniffi_trait_interfaces_rust_future_free_i8(uint64_t);
  int8_t ffi_uniffi_trait_interfaces_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_uniffi_trait_interfaces_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_trait_interfaces_rust_future_cancel_u16(uint64_t);
  void ffi_uniffi_trait_interfaces_rust_future_free_u16(uint64_t);
  uint16_t ffi_uniffi_trait_interfaces_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_uniffi_trait_interfaces_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_trait_interfaces_rust_future_cancel_i16(uint64_t);
  void ffi_uniffi_trait_interfaces_rust_future_free_i16(uint64_t);
  int16_t ffi_uniffi_trait_interfaces_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_uniffi_trait_interfaces_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_trait_interfaces_rust_future_cancel_u32(uint64_t);
  void ffi_uniffi_trait_interfaces_rust_future_free_u32(uint64_t);
  uint32_t ffi_uniffi_trait_interfaces_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_uniffi_trait_interfaces_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_trait_interfaces_rust_future_cancel_i32(uint64_t);
  void ffi_uniffi_trait_interfaces_rust_future_free_i32(uint64_t);
  int32_t ffi_uniffi_trait_interfaces_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_uniffi_trait_interfaces_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_trait_interfaces_rust_future_cancel_u64(uint64_t);
  void ffi_uniffi_trait_interfaces_rust_future_free_u64(uint64_t);
  uint64_t ffi_uniffi_trait_interfaces_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_uniffi_trait_interfaces_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_trait_interfaces_rust_future_cancel_i64(uint64_t);
  void ffi_uniffi_trait_interfaces_rust_future_free_i64(uint64_t);
  int64_t ffi_uniffi_trait_interfaces_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_uniffi_trait_interfaces_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_trait_interfaces_rust_future_cancel_f32(uint64_t);
  void ffi_uniffi_trait_interfaces_rust_future_free_f32(uint64_t);
  float ffi_uniffi_trait_interfaces_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_uniffi_trait_interfaces_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_trait_interfaces_rust_future_cancel_f64(uint64_t);
  void ffi_uniffi_trait_interfaces_rust_future_free_f64(uint64_t);
  double ffi_uniffi_trait_interfaces_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_uniffi_trait_interfaces_rust_future_poll_pointer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_trait_interfaces_rust_future_cancel_pointer(uint64_t);
  void ffi_uniffi_trait_interfaces_rust_future_free_pointer(uint64_t);
  void* ffi_uniffi_trait_interfaces_rust_future_complete_pointer(uint64_t, RustCallStatus*);
  void ffi_uniffi_trait_interfaces_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_trait_interfaces_rust_future_cancel_rust_buffer(uint64_t);
  void ffi_uniffi_trait_interfaces_rust_future_free_rust_buffer(uint64_t);
  RustBuffer ffi_uniffi_trait_interfaces_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_uniffi_trait_interfaces_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_trait_interfaces_rust_future_cancel_void(uint64_t);
  void ffi_uniffi_trait_interfaces_rust_future_free_void(uint64_t);
  void ffi_uniffi_trait_interfaces_rust_future_complete_void(uint64_t, RustCallStatus*);
  uint16_t uniffi_uniffi_trait_interfaces_checksum_func_make_buggy_calculator();
  uint16_t uniffi_uniffi_trait_interfaces_checksum_func_make_calculator();
  uint16_t uniffi_uniffi_trait_interfaces_checksum_method_calc_add();
  uint32_t ffi_uniffi_trait_interfaces_uniffi_contract_version();
#endif /* MOZ_UNIFFI_FIXTURES */
}

// Define pointer types and FfiValueObjectHandle* classes

const static mozilla::uniffi::UniFFIPointerType kRelevancyRelevancyStorePointerType {
  "relevancy::RelevancyStore"_ns,
  uniffi_relevancy_fn_clone_relevancystore,
  uniffi_relevancy_fn_free_relevancystore,
};

class FfiValueObjectHandleRelevancyRelevancyStore {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleRelevancyRelevancyStore() = default;
  explicit FfiValueObjectHandleRelevancyRelevancyStore(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleRelevancyRelevancyStore(const FfiValueObjectHandleRelevancyRelevancyStore&) = delete;
  FfiValueObjectHandleRelevancyRelevancyStore& operator=(const FfiValueObjectHandleRelevancyRelevancyStore&) = delete;

    FfiValueObjectHandleRelevancyRelevancyStore& operator=(FfiValueObjectHandleRelevancyRelevancyStore&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kRelevancyRelevancyStorePointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kRelevancyRelevancyStorePointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleRelevancyRelevancyStore FromRust(void* aValue) {
    return FfiValueObjectHandleRelevancyRelevancyStore(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_relevancy_fn_free_relevancystore)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleRelevancyRelevancyStore() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kRemoteSettingsRemoteSettingsPointerType {
  "remote_settings::RemoteSettings"_ns,
  uniffi_remote_settings_fn_clone_remotesettings,
  uniffi_remote_settings_fn_free_remotesettings,
};

class FfiValueObjectHandleRemoteSettingsRemoteSettings {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleRemoteSettingsRemoteSettings() = default;
  explicit FfiValueObjectHandleRemoteSettingsRemoteSettings(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleRemoteSettingsRemoteSettings(const FfiValueObjectHandleRemoteSettingsRemoteSettings&) = delete;
  FfiValueObjectHandleRemoteSettingsRemoteSettings& operator=(const FfiValueObjectHandleRemoteSettingsRemoteSettings&) = delete;

    FfiValueObjectHandleRemoteSettingsRemoteSettings& operator=(FfiValueObjectHandleRemoteSettingsRemoteSettings&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kRemoteSettingsRemoteSettingsPointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kRemoteSettingsRemoteSettingsPointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleRemoteSettingsRemoteSettings FromRust(void* aValue) {
    return FfiValueObjectHandleRemoteSettingsRemoteSettings(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_remote_settings_fn_free_remotesettings)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleRemoteSettingsRemoteSettings() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kRemoteSettingsRemoteSettingsClientPointerType {
  "remote_settings::RemoteSettingsClient"_ns,
  uniffi_remote_settings_fn_clone_remotesettingsclient,
  uniffi_remote_settings_fn_free_remotesettingsclient,
};

class FfiValueObjectHandleRemoteSettingsRemoteSettingsClient {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleRemoteSettingsRemoteSettingsClient() = default;
  explicit FfiValueObjectHandleRemoteSettingsRemoteSettingsClient(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleRemoteSettingsRemoteSettingsClient(const FfiValueObjectHandleRemoteSettingsRemoteSettingsClient&) = delete;
  FfiValueObjectHandleRemoteSettingsRemoteSettingsClient& operator=(const FfiValueObjectHandleRemoteSettingsRemoteSettingsClient&) = delete;

    FfiValueObjectHandleRemoteSettingsRemoteSettingsClient& operator=(FfiValueObjectHandleRemoteSettingsRemoteSettingsClient&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kRemoteSettingsRemoteSettingsClientPointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kRemoteSettingsRemoteSettingsClientPointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleRemoteSettingsRemoteSettingsClient FromRust(void* aValue) {
    return FfiValueObjectHandleRemoteSettingsRemoteSettingsClient(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_remote_settings_fn_free_remotesettingsclient)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleRemoteSettingsRemoteSettingsClient() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kRemoteSettingsRemoteSettingsServicePointerType {
  "remote_settings::RemoteSettingsService"_ns,
  uniffi_remote_settings_fn_clone_remotesettingsservice,
  uniffi_remote_settings_fn_free_remotesettingsservice,
};

class FfiValueObjectHandleRemoteSettingsRemoteSettingsService {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService() = default;
  explicit FfiValueObjectHandleRemoteSettingsRemoteSettingsService(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService(const FfiValueObjectHandleRemoteSettingsRemoteSettingsService&) = delete;
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService& operator=(const FfiValueObjectHandleRemoteSettingsRemoteSettingsService&) = delete;

    FfiValueObjectHandleRemoteSettingsRemoteSettingsService& operator=(FfiValueObjectHandleRemoteSettingsRemoteSettingsService&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kRemoteSettingsRemoteSettingsServicePointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kRemoteSettingsRemoteSettingsServicePointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleRemoteSettingsRemoteSettingsService FromRust(void* aValue) {
    return FfiValueObjectHandleRemoteSettingsRemoteSettingsService(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_remote_settings_fn_free_remotesettingsservice)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleRemoteSettingsRemoteSettingsService() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kSearchSearchEngineSelectorPointerType {
  "search::SearchEngineSelector"_ns,
  uniffi_search_fn_clone_searchengineselector,
  uniffi_search_fn_free_searchengineselector,
};

class FfiValueObjectHandleSearchSearchEngineSelector {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleSearchSearchEngineSelector() = default;
  explicit FfiValueObjectHandleSearchSearchEngineSelector(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleSearchSearchEngineSelector(const FfiValueObjectHandleSearchSearchEngineSelector&) = delete;
  FfiValueObjectHandleSearchSearchEngineSelector& operator=(const FfiValueObjectHandleSearchSearchEngineSelector&) = delete;

    FfiValueObjectHandleSearchSearchEngineSelector& operator=(FfiValueObjectHandleSearchSearchEngineSelector&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kSearchSearchEngineSelectorPointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kSearchSearchEngineSelectorPointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleSearchSearchEngineSelector FromRust(void* aValue) {
    return FfiValueObjectHandleSearchSearchEngineSelector(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_search_fn_free_searchengineselector)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleSearchSearchEngineSelector() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kSuggestSuggestStorePointerType {
  "suggest::SuggestStore"_ns,
  uniffi_suggest_fn_clone_suggeststore,
  uniffi_suggest_fn_free_suggeststore,
};

class FfiValueObjectHandleSuggestSuggestStore {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleSuggestSuggestStore() = default;
  explicit FfiValueObjectHandleSuggestSuggestStore(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleSuggestSuggestStore(const FfiValueObjectHandleSuggestSuggestStore&) = delete;
  FfiValueObjectHandleSuggestSuggestStore& operator=(const FfiValueObjectHandleSuggestSuggestStore&) = delete;

    FfiValueObjectHandleSuggestSuggestStore& operator=(FfiValueObjectHandleSuggestSuggestStore&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kSuggestSuggestStorePointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kSuggestSuggestStorePointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleSuggestSuggestStore FromRust(void* aValue) {
    return FfiValueObjectHandleSuggestSuggestStore(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_suggest_fn_free_suggeststore)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleSuggestSuggestStore() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kSuggestSuggestStoreBuilderPointerType {
  "suggest::SuggestStoreBuilder"_ns,
  uniffi_suggest_fn_clone_suggeststorebuilder,
  uniffi_suggest_fn_free_suggeststorebuilder,
};

class FfiValueObjectHandleSuggestSuggestStoreBuilder {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleSuggestSuggestStoreBuilder() = default;
  explicit FfiValueObjectHandleSuggestSuggestStoreBuilder(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleSuggestSuggestStoreBuilder(const FfiValueObjectHandleSuggestSuggestStoreBuilder&) = delete;
  FfiValueObjectHandleSuggestSuggestStoreBuilder& operator=(const FfiValueObjectHandleSuggestSuggestStoreBuilder&) = delete;

    FfiValueObjectHandleSuggestSuggestStoreBuilder& operator=(FfiValueObjectHandleSuggestSuggestStoreBuilder&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kSuggestSuggestStoreBuilderPointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kSuggestSuggestStoreBuilderPointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleSuggestSuggestStoreBuilder FromRust(void* aValue) {
    return FfiValueObjectHandleSuggestSuggestStoreBuilder(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_suggest_fn_free_suggeststorebuilder)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleSuggestSuggestStoreBuilder() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kTabsRemoteCommandStorePointerType {
  "tabs::RemoteCommandStore"_ns,
  uniffi_tabs_fn_clone_remotecommandstore,
  uniffi_tabs_fn_free_remotecommandstore,
};

class FfiValueObjectHandleTabsRemoteCommandStore {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleTabsRemoteCommandStore() = default;
  explicit FfiValueObjectHandleTabsRemoteCommandStore(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleTabsRemoteCommandStore(const FfiValueObjectHandleTabsRemoteCommandStore&) = delete;
  FfiValueObjectHandleTabsRemoteCommandStore& operator=(const FfiValueObjectHandleTabsRemoteCommandStore&) = delete;

    FfiValueObjectHandleTabsRemoteCommandStore& operator=(FfiValueObjectHandleTabsRemoteCommandStore&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kTabsRemoteCommandStorePointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kTabsRemoteCommandStorePointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleTabsRemoteCommandStore FromRust(void* aValue) {
    return FfiValueObjectHandleTabsRemoteCommandStore(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_tabs_fn_free_remotecommandstore)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleTabsRemoteCommandStore() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kTabsTabsBridgedEnginePointerType {
  "tabs::TabsBridgedEngine"_ns,
  uniffi_tabs_fn_clone_tabsbridgedengine,
  uniffi_tabs_fn_free_tabsbridgedengine,
};

class FfiValueObjectHandleTabsTabsBridgedEngine {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleTabsTabsBridgedEngine() = default;
  explicit FfiValueObjectHandleTabsTabsBridgedEngine(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleTabsTabsBridgedEngine(const FfiValueObjectHandleTabsTabsBridgedEngine&) = delete;
  FfiValueObjectHandleTabsTabsBridgedEngine& operator=(const FfiValueObjectHandleTabsTabsBridgedEngine&) = delete;

    FfiValueObjectHandleTabsTabsBridgedEngine& operator=(FfiValueObjectHandleTabsTabsBridgedEngine&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kTabsTabsBridgedEnginePointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kTabsTabsBridgedEnginePointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleTabsTabsBridgedEngine FromRust(void* aValue) {
    return FfiValueObjectHandleTabsTabsBridgedEngine(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_tabs_fn_free_tabsbridgedengine)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleTabsTabsBridgedEngine() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kTabsTabsStorePointerType {
  "tabs::TabsStore"_ns,
  uniffi_tabs_fn_clone_tabsstore,
  uniffi_tabs_fn_free_tabsstore,
};

class FfiValueObjectHandleTabsTabsStore {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleTabsTabsStore() = default;
  explicit FfiValueObjectHandleTabsTabsStore(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleTabsTabsStore(const FfiValueObjectHandleTabsTabsStore&) = delete;
  FfiValueObjectHandleTabsTabsStore& operator=(const FfiValueObjectHandleTabsTabsStore&) = delete;

    FfiValueObjectHandleTabsTabsStore& operator=(FfiValueObjectHandleTabsTabsStore&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kTabsTabsStorePointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kTabsTabsStorePointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleTabsTabsStore FromRust(void* aValue) {
    return FfiValueObjectHandleTabsTabsStore(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_tabs_fn_free_tabsstore)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleTabsTabsStore() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kWebextstorageWebExtStorageBridgedEnginePointerType {
  "webextstorage::WebExtStorageBridgedEngine"_ns,
  uniffi_webext_storage_fn_clone_webextstoragebridgedengine,
  uniffi_webext_storage_fn_free_webextstoragebridgedengine,
};

class FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine() = default;
  explicit FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine(const FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine&) = delete;
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine& operator=(const FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine&) = delete;

    FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine& operator=(FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kWebextstorageWebExtStorageBridgedEnginePointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kWebextstorageWebExtStorageBridgedEnginePointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine FromRust(void* aValue) {
    return FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_webext_storage_fn_free_webextstoragebridgedengine)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kWebextstorageWebExtStorageStorePointerType {
  "webextstorage::WebExtStorageStore"_ns,
  uniffi_webext_storage_fn_clone_webextstoragestore,
  uniffi_webext_storage_fn_free_webextstoragestore,
};

class FfiValueObjectHandleWebextstorageWebExtStorageStore {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleWebextstorageWebExtStorageStore() = default;
  explicit FfiValueObjectHandleWebextstorageWebExtStorageStore(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleWebextstorageWebExtStorageStore(const FfiValueObjectHandleWebextstorageWebExtStorageStore&) = delete;
  FfiValueObjectHandleWebextstorageWebExtStorageStore& operator=(const FfiValueObjectHandleWebextstorageWebExtStorageStore&) = delete;

    FfiValueObjectHandleWebextstorageWebExtStorageStore& operator=(FfiValueObjectHandleWebextstorageWebExtStorageStore&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kWebextstorageWebExtStorageStorePointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kWebextstorageWebExtStorageStorePointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleWebextstorageWebExtStorageStore FromRust(void* aValue) {
    return FfiValueObjectHandleWebextstorageWebExtStorageStore(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_webext_storage_fn_free_webextstoragestore)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleWebextstorageWebExtStorageStore() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};

#ifdef MOZ_UNIFFI_FIXTURES
const static mozilla::uniffi::UniFFIPointerType kFuturesFutureTesterPointerType {
  "futures::FutureTester"_ns,
  uniffi_uniffi_fixture_futures_fn_clone_futuretester,
  uniffi_uniffi_fixture_futures_fn_free_futuretester,
};

class FfiValueObjectHandleFuturesFutureTester {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleFuturesFutureTester() = default;
  explicit FfiValueObjectHandleFuturesFutureTester(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleFuturesFutureTester(const FfiValueObjectHandleFuturesFutureTester&) = delete;
  FfiValueObjectHandleFuturesFutureTester& operator=(const FfiValueObjectHandleFuturesFutureTester&) = delete;

    FfiValueObjectHandleFuturesFutureTester& operator=(FfiValueObjectHandleFuturesFutureTester&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kFuturesFutureTesterPointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kFuturesFutureTesterPointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleFuturesFutureTester FromRust(void* aValue) {
    return FfiValueObjectHandleFuturesFutureTester(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_uniffi_fixture_futures_fn_free_futuretester)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleFuturesFutureTester() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kFuturesRustTaskPointerType {
  "futures::RustTask"_ns,
  uniffi_uniffi_fixture_futures_fn_clone_rusttask,
  uniffi_uniffi_fixture_futures_fn_free_rusttask,
};

class FfiValueObjectHandleFuturesRustTask {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleFuturesRustTask() = default;
  explicit FfiValueObjectHandleFuturesRustTask(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleFuturesRustTask(const FfiValueObjectHandleFuturesRustTask&) = delete;
  FfiValueObjectHandleFuturesRustTask& operator=(const FfiValueObjectHandleFuturesRustTask&) = delete;

    FfiValueObjectHandleFuturesRustTask& operator=(FfiValueObjectHandleFuturesRustTask&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kFuturesRustTaskPointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kFuturesRustTaskPointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleFuturesRustTask FromRust(void* aValue) {
    return FfiValueObjectHandleFuturesRustTask(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_uniffi_fixture_futures_fn_free_rusttask)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleFuturesRustTask() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kFuturesTravellerPointerType {
  "futures::Traveller"_ns,
  uniffi_uniffi_fixture_futures_fn_clone_traveller,
  uniffi_uniffi_fixture_futures_fn_free_traveller,
};

class FfiValueObjectHandleFuturesTraveller {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleFuturesTraveller() = default;
  explicit FfiValueObjectHandleFuturesTraveller(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleFuturesTraveller(const FfiValueObjectHandleFuturesTraveller&) = delete;
  FfiValueObjectHandleFuturesTraveller& operator=(const FfiValueObjectHandleFuturesTraveller&) = delete;

    FfiValueObjectHandleFuturesTraveller& operator=(FfiValueObjectHandleFuturesTraveller&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kFuturesTravellerPointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kFuturesTravellerPointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleFuturesTraveller FromRust(void* aValue) {
    return FfiValueObjectHandleFuturesTraveller(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_uniffi_fixture_futures_fn_free_traveller)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleFuturesTraveller() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kFuturesWorkerQueuePointerType {
  "futures::WorkerQueue"_ns,
  uniffi_uniffi_fixture_futures_fn_clone_workerqueue,
  uniffi_uniffi_fixture_futures_fn_free_workerqueue,
};

class FfiValueObjectHandleFuturesWorkerQueue {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleFuturesWorkerQueue() = default;
  explicit FfiValueObjectHandleFuturesWorkerQueue(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleFuturesWorkerQueue(const FfiValueObjectHandleFuturesWorkerQueue&) = delete;
  FfiValueObjectHandleFuturesWorkerQueue& operator=(const FfiValueObjectHandleFuturesWorkerQueue&) = delete;

    FfiValueObjectHandleFuturesWorkerQueue& operator=(FfiValueObjectHandleFuturesWorkerQueue&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kFuturesWorkerQueuePointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kFuturesWorkerQueuePointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleFuturesWorkerQueue FromRust(void* aValue) {
    return FfiValueObjectHandleFuturesWorkerQueue(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_uniffi_fixture_futures_fn_free_workerqueue)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleFuturesWorkerQueue() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kRefcountsSingletonObjectPointerType {
  "refcounts::SingletonObject"_ns,
  uniffi_uniffi_fixture_refcounts_fn_clone_singletonobject,
  uniffi_uniffi_fixture_refcounts_fn_free_singletonobject,
};

class FfiValueObjectHandleRefcountsSingletonObject {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleRefcountsSingletonObject() = default;
  explicit FfiValueObjectHandleRefcountsSingletonObject(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleRefcountsSingletonObject(const FfiValueObjectHandleRefcountsSingletonObject&) = delete;
  FfiValueObjectHandleRefcountsSingletonObject& operator=(const FfiValueObjectHandleRefcountsSingletonObject&) = delete;

    FfiValueObjectHandleRefcountsSingletonObject& operator=(FfiValueObjectHandleRefcountsSingletonObject&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kRefcountsSingletonObjectPointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kRefcountsSingletonObjectPointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleRefcountsSingletonObject FromRust(void* aValue) {
    return FfiValueObjectHandleRefcountsSingletonObject(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_uniffi_fixture_refcounts_fn_free_singletonobject)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleRefcountsSingletonObject() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kRondpointOptionneurPointerType {
  "rondpoint::Optionneur"_ns,
  uniffi_uniffi_rondpoint_fn_clone_optionneur,
  uniffi_uniffi_rondpoint_fn_free_optionneur,
};

class FfiValueObjectHandleRondpointOptionneur {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleRondpointOptionneur() = default;
  explicit FfiValueObjectHandleRondpointOptionneur(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleRondpointOptionneur(const FfiValueObjectHandleRondpointOptionneur&) = delete;
  FfiValueObjectHandleRondpointOptionneur& operator=(const FfiValueObjectHandleRondpointOptionneur&) = delete;

    FfiValueObjectHandleRondpointOptionneur& operator=(FfiValueObjectHandleRondpointOptionneur&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kRondpointOptionneurPointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kRondpointOptionneurPointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleRondpointOptionneur FromRust(void* aValue) {
    return FfiValueObjectHandleRondpointOptionneur(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_uniffi_rondpoint_fn_free_optionneur)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleRondpointOptionneur() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kRondpointRetourneurPointerType {
  "rondpoint::Retourneur"_ns,
  uniffi_uniffi_rondpoint_fn_clone_retourneur,
  uniffi_uniffi_rondpoint_fn_free_retourneur,
};

class FfiValueObjectHandleRondpointRetourneur {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleRondpointRetourneur() = default;
  explicit FfiValueObjectHandleRondpointRetourneur(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleRondpointRetourneur(const FfiValueObjectHandleRondpointRetourneur&) = delete;
  FfiValueObjectHandleRondpointRetourneur& operator=(const FfiValueObjectHandleRondpointRetourneur&) = delete;

    FfiValueObjectHandleRondpointRetourneur& operator=(FfiValueObjectHandleRondpointRetourneur&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kRondpointRetourneurPointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kRondpointRetourneurPointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleRondpointRetourneur FromRust(void* aValue) {
    return FfiValueObjectHandleRondpointRetourneur(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_uniffi_rondpoint_fn_free_retourneur)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleRondpointRetourneur() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kRondpointStringifierPointerType {
  "rondpoint::Stringifier"_ns,
  uniffi_uniffi_rondpoint_fn_clone_stringifier,
  uniffi_uniffi_rondpoint_fn_free_stringifier,
};

class FfiValueObjectHandleRondpointStringifier {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleRondpointStringifier() = default;
  explicit FfiValueObjectHandleRondpointStringifier(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleRondpointStringifier(const FfiValueObjectHandleRondpointStringifier&) = delete;
  FfiValueObjectHandleRondpointStringifier& operator=(const FfiValueObjectHandleRondpointStringifier&) = delete;

    FfiValueObjectHandleRondpointStringifier& operator=(FfiValueObjectHandleRondpointStringifier&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kRondpointStringifierPointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kRondpointStringifierPointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleRondpointStringifier FromRust(void* aValue) {
    return FfiValueObjectHandleRondpointStringifier(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_uniffi_rondpoint_fn_free_stringifier)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleRondpointStringifier() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kSpritesSpritePointerType {
  "sprites::Sprite"_ns,
  uniffi_uniffi_sprites_fn_clone_sprite,
  uniffi_uniffi_sprites_fn_free_sprite,
};

class FfiValueObjectHandleSpritesSprite {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleSpritesSprite() = default;
  explicit FfiValueObjectHandleSpritesSprite(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleSpritesSprite(const FfiValueObjectHandleSpritesSprite&) = delete;
  FfiValueObjectHandleSpritesSprite& operator=(const FfiValueObjectHandleSpritesSprite&) = delete;

    FfiValueObjectHandleSpritesSprite& operator=(FfiValueObjectHandleSpritesSprite&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kSpritesSpritePointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kSpritesSpritePointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleSpritesSprite FromRust(void* aValue) {
    return FfiValueObjectHandleSpritesSprite(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_uniffi_sprites_fn_free_sprite)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleSpritesSprite() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kTodolistTodoListPointerType {
  "todolist::TodoList"_ns,
  uniffi_uniffi_todolist_fn_clone_todolist,
  uniffi_uniffi_todolist_fn_free_todolist,
};

class FfiValueObjectHandleTodolistTodoList {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleTodolistTodoList() = default;
  explicit FfiValueObjectHandleTodolistTodoList(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleTodolistTodoList(const FfiValueObjectHandleTodolistTodoList&) = delete;
  FfiValueObjectHandleTodolistTodoList& operator=(const FfiValueObjectHandleTodolistTodoList&) = delete;

    FfiValueObjectHandleTodolistTodoList& operator=(FfiValueObjectHandleTodolistTodoList&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kTodolistTodoListPointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kTodolistTodoListPointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleTodolistTodoList FromRust(void* aValue) {
    return FfiValueObjectHandleTodolistTodoList(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_uniffi_todolist_fn_free_todolist)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleTodolistTodoList() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kUniffiTraitInterfacesCalcPointerType {
  "uniffi_trait_interfaces::Calc"_ns,
  uniffi_uniffi_trait_interfaces_fn_clone_calc,
  uniffi_uniffi_trait_interfaces_fn_free_calc,
};

class FfiValueObjectHandleUniffiTraitInterfacesCalc {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleUniffiTraitInterfacesCalc() = default;
  explicit FfiValueObjectHandleUniffiTraitInterfacesCalc(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleUniffiTraitInterfacesCalc(const FfiValueObjectHandleUniffiTraitInterfacesCalc&) = delete;
  FfiValueObjectHandleUniffiTraitInterfacesCalc& operator=(const FfiValueObjectHandleUniffiTraitInterfacesCalc&) = delete;

    FfiValueObjectHandleUniffiTraitInterfacesCalc& operator=(FfiValueObjectHandleUniffiTraitInterfacesCalc&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kUniffiTraitInterfacesCalcPointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kUniffiTraitInterfacesCalcPointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleUniffiTraitInterfacesCalc FromRust(void* aValue) {
    return FfiValueObjectHandleUniffiTraitInterfacesCalc(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_uniffi_trait_interfaces_fn_free_calc)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleUniffiTraitInterfacesCalc() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
#endif /* MOZ_UNIFFI_FIXTURES */

// Callback interface method handlers, vtables, etc.

static StaticRefPtr<dom::UniFFICallbackHandler> gCallbackInterfaceJsHandlerApplicationErrorReporter;

class CallbackInterfaceMethodApplicationErrorReporterReportError : public UniffiCallbackMethodHandlerBase {
private:
  // Rust arguments
  FfiValueRustBuffer type_name{};
  FfiValueRustBuffer message{};

public:
  CallbackInterfaceMethodApplicationErrorReporterReportError(size_t aObjectHandle, RustBuffer type_name, RustBuffer message)
    : UniffiCallbackMethodHandlerBase("errorsupport:ApplicationErrorReporter", aObjectHandle), type_name(FfiValueRustBuffer::FromRust(type_name)), message(FfiValueRustBuffer::FromRust(message)) {
  }

  MOZ_CAN_RUN_SCRIPT
  void MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;
    // Setup
    if (!uniffiArgs.AppendElements(2, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return;
    }

    // Convert each argument
    type_name.Lift(
      aCx,
      &uniffiArgs[0],
      aError);
    if (aError.Failed()) {
        return;
    }
    message.Lift(
      aCx,
      &uniffiArgs[1],
      aError);
    if (aError.Failed()) {
        return;
    }

    // Stores the return value.  For now, we currently don't do anything with it, since we only support
    // fire-and-forget callbacks.
    NullableRootedUnion<dom::OwningUniFFIScaffoldingValue> returnValue(aCx);
    // Make the call
    aJsHandler->Call(mObjectHandle, 0, uniffiArgs, returnValue, aError);
  }
};

extern "C" void callback_interface_application_error_reporter_report_error(
    uint64_t uniffiHandle,
    RustBuffer type_name, RustBuffer message, 
    void* uniffiOutReturn,
    RustCallStatus* uniffiCallStatus
) {
  UniquePtr<UniffiCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodApplicationErrorReporterReportError>(uniffiHandle, type_name, message);
  // Note: currently we only support queueing fire-and-forget async callbacks

  // For fire-and-forget callbacks, we don't know if the method succeeds or not
  // since it's called later. uniffiCallStatus is initialized to a successful
  // state by the Rust code, so there's no need to modify it.
  UniffiCallbackMethodHandlerBase::FireAndForget(std::move(handler), &gCallbackInterfaceJsHandlerApplicationErrorReporter);
}

class CallbackInterfaceMethodApplicationErrorReporterReportBreadcrumb : public UniffiCallbackMethodHandlerBase {
private:
  // Rust arguments
  FfiValueRustBuffer message{};
  FfiValueRustBuffer module{};
  FfiValueInt<uint32_t> line{};
  FfiValueInt<uint32_t> column{};

public:
  CallbackInterfaceMethodApplicationErrorReporterReportBreadcrumb(size_t aObjectHandle, RustBuffer message, RustBuffer module, uint32_t line, uint32_t column)
    : UniffiCallbackMethodHandlerBase("errorsupport:ApplicationErrorReporter", aObjectHandle), message(FfiValueRustBuffer::FromRust(message)), module(FfiValueRustBuffer::FromRust(module)), line(FfiValueInt<uint32_t>::FromRust(line)), column(FfiValueInt<uint32_t>::FromRust(column)) {
  }

  MOZ_CAN_RUN_SCRIPT
  void MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;
    // Setup
    if (!uniffiArgs.AppendElements(4, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return;
    }

    // Convert each argument
    message.Lift(
      aCx,
      &uniffiArgs[0],
      aError);
    if (aError.Failed()) {
        return;
    }
    module.Lift(
      aCx,
      &uniffiArgs[1],
      aError);
    if (aError.Failed()) {
        return;
    }
    line.Lift(
      aCx,
      &uniffiArgs[2],
      aError);
    if (aError.Failed()) {
        return;
    }
    column.Lift(
      aCx,
      &uniffiArgs[3],
      aError);
    if (aError.Failed()) {
        return;
    }

    // Stores the return value.  For now, we currently don't do anything with it, since we only support
    // fire-and-forget callbacks.
    NullableRootedUnion<dom::OwningUniFFIScaffoldingValue> returnValue(aCx);
    // Make the call
    aJsHandler->Call(mObjectHandle, 1, uniffiArgs, returnValue, aError);
  }
};

extern "C" void callback_interface_application_error_reporter_report_breadcrumb(
    uint64_t uniffiHandle,
    RustBuffer message, RustBuffer module, uint32_t line, uint32_t column, 
    void* uniffiOutReturn,
    RustCallStatus* uniffiCallStatus
) {
  UniquePtr<UniffiCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodApplicationErrorReporterReportBreadcrumb>(uniffiHandle, message, module, line, column);
  // Note: currently we only support queueing fire-and-forget async callbacks

  // For fire-and-forget callbacks, we don't know if the method succeeds or not
  // since it's called later. uniffiCallStatus is initialized to a successful
  // state by the Rust code, so there's no need to modify it.
  UniffiCallbackMethodHandlerBase::FireAndForget(std::move(handler), &gCallbackInterfaceJsHandlerApplicationErrorReporter);
}

extern "C" void callbackInterfaceFreeApplicationErrorReporter(uint64_t uniffiHandle) {
  // Callback object handles are keys in a map stored in the JS handler. To
  // handle the free call, make a call into JS which will remove the key.
  // Fire-and-forget is perfect for this.
  UniffiCallbackMethodHandlerBase::FireAndForget(MakeUnique<UniffiCallbackFreeHandler>("errorsupport:ApplicationErrorReporter", uniffiHandle), &gCallbackInterfaceJsHandlerApplicationErrorReporter);
}


static VTableCallbackInterfaceApplicationErrorReporter kCallbackInterfaceVtableApplicationErrorReporter {
  callback_interface_application_error_reporter_report_error,
  callback_interface_application_error_reporter_report_breadcrumb,
  callbackInterfaceFreeApplicationErrorReporter
};

#ifdef MOZ_UNIFFI_FIXTURES
static StaticRefPtr<dom::UniFFICallbackHandler> gCallbackInterfaceJsHandlerLogger;

class CallbackInterfaceMethodLoggerLog : public UniffiCallbackMethodHandlerBase {
private:
  // Rust arguments
  FfiValueRustBuffer message{};

public:
  CallbackInterfaceMethodLoggerLog(size_t aObjectHandle, RustBuffer message)
    : UniffiCallbackMethodHandlerBase("fixture_callbacks:Logger", aObjectHandle), message(FfiValueRustBuffer::FromRust(message)) {
  }

  MOZ_CAN_RUN_SCRIPT
  void MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;
    // Setup
    if (!uniffiArgs.AppendElements(1, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return;
    }

    // Convert each argument
    message.Lift(
      aCx,
      &uniffiArgs[0],
      aError);
    if (aError.Failed()) {
        return;
    }

    // Stores the return value.  For now, we currently don't do anything with it, since we only support
    // fire-and-forget callbacks.
    NullableRootedUnion<dom::OwningUniFFIScaffoldingValue> returnValue(aCx);
    // Make the call
    aJsHandler->Call(mObjectHandle, 0, uniffiArgs, returnValue, aError);
  }
};

extern "C" void callback_interface_logger_log(
    uint64_t uniffiHandle,
    RustBuffer message, 
    void* uniffiOutReturn,
    RustCallStatus* uniffiCallStatus
) {
  UniquePtr<UniffiCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodLoggerLog>(uniffiHandle, message);
  // Note: currently we only support queueing fire-and-forget async callbacks

  // For fire-and-forget callbacks, we don't know if the method succeeds or not
  // since it's called later. uniffiCallStatus is initialized to a successful
  // state by the Rust code, so there's no need to modify it.
  UniffiCallbackMethodHandlerBase::FireAndForget(std::move(handler), &gCallbackInterfaceJsHandlerLogger);
}

class CallbackInterfaceMethodLoggerLogRepeat : public UniffiCallbackMethodHandlerBase {
private:
  // Rust arguments
  FfiValueRustBuffer message{};
  FfiValueInt<uint32_t> count{};
  FfiValueRustBuffer exclude{};

public:
  CallbackInterfaceMethodLoggerLogRepeat(size_t aObjectHandle, RustBuffer message, uint32_t count, RustBuffer exclude)
    : UniffiCallbackMethodHandlerBase("fixture_callbacks:Logger", aObjectHandle), message(FfiValueRustBuffer::FromRust(message)), count(FfiValueInt<uint32_t>::FromRust(count)), exclude(FfiValueRustBuffer::FromRust(exclude)) {
  }

  MOZ_CAN_RUN_SCRIPT
  void MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;
    // Setup
    if (!uniffiArgs.AppendElements(3, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return;
    }

    // Convert each argument
    message.Lift(
      aCx,
      &uniffiArgs[0],
      aError);
    if (aError.Failed()) {
        return;
    }
    count.Lift(
      aCx,
      &uniffiArgs[1],
      aError);
    if (aError.Failed()) {
        return;
    }
    exclude.Lift(
      aCx,
      &uniffiArgs[2],
      aError);
    if (aError.Failed()) {
        return;
    }

    // Stores the return value.  For now, we currently don't do anything with it, since we only support
    // fire-and-forget callbacks.
    NullableRootedUnion<dom::OwningUniFFIScaffoldingValue> returnValue(aCx);
    // Make the call
    aJsHandler->Call(mObjectHandle, 1, uniffiArgs, returnValue, aError);
  }
};

extern "C" void callback_interface_logger_log_repeat(
    uint64_t uniffiHandle,
    RustBuffer message, uint32_t count, RustBuffer exclude, 
    void* uniffiOutReturn,
    RustCallStatus* uniffiCallStatus
) {
  UniquePtr<UniffiCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodLoggerLogRepeat>(uniffiHandle, message, count, exclude);
  // Note: currently we only support queueing fire-and-forget async callbacks

  // For fire-and-forget callbacks, we don't know if the method succeeds or not
  // since it's called later. uniffiCallStatus is initialized to a successful
  // state by the Rust code, so there's no need to modify it.
  UniffiCallbackMethodHandlerBase::FireAndForget(std::move(handler), &gCallbackInterfaceJsHandlerLogger);
}

class CallbackInterfaceMethodLoggerFinished : public UniffiCallbackMethodHandlerBase {
private:
  // Rust arguments

public:
  CallbackInterfaceMethodLoggerFinished(size_t aObjectHandle)
    : UniffiCallbackMethodHandlerBase("fixture_callbacks:Logger", aObjectHandle) {
  }

  MOZ_CAN_RUN_SCRIPT
  void MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;

    // Stores the return value.  For now, we currently don't do anything with it, since we only support
    // fire-and-forget callbacks.
    NullableRootedUnion<dom::OwningUniFFIScaffoldingValue> returnValue(aCx);
    // Make the call
    aJsHandler->Call(mObjectHandle, 2, uniffiArgs, returnValue, aError);
  }
};

extern "C" void callback_interface_logger_finished(
    uint64_t uniffiHandle,
    
    void* uniffiOutReturn,
    RustCallStatus* uniffiCallStatus
) {
  UniquePtr<UniffiCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodLoggerFinished>(uniffiHandle);
  // Note: currently we only support queueing fire-and-forget async callbacks

  // For fire-and-forget callbacks, we don't know if the method succeeds or not
  // since it's called later. uniffiCallStatus is initialized to a successful
  // state by the Rust code, so there's no need to modify it.
  UniffiCallbackMethodHandlerBase::FireAndForget(std::move(handler), &gCallbackInterfaceJsHandlerLogger);
}

extern "C" void callbackInterfaceFreeLogger(uint64_t uniffiHandle) {
  // Callback object handles are keys in a map stored in the JS handler. To
  // handle the free call, make a call into JS which will remove the key.
  // Fire-and-forget is perfect for this.
  UniffiCallbackMethodHandlerBase::FireAndForget(MakeUnique<UniffiCallbackFreeHandler>("fixture_callbacks:Logger", uniffiHandle), &gCallbackInterfaceJsHandlerLogger);
}


static VTableCallbackInterfaceLogger kCallbackInterfaceVtableLogger {
  callback_interface_logger_log,
  callback_interface_logger_log_repeat,
  callback_interface_logger_finished,
  callbackInterfaceFreeLogger
};
#endif /* MOZ_UNIFFI_FIXTURES */

void RegisterCallbackHandler(uint64_t aInterfaceId, UniFFICallbackHandler& aCallbackHandler, ErrorResult& aError) {
  switch (aInterfaceId) {
    
    case 0: {
      if (gCallbackInterfaceJsHandlerApplicationErrorReporter) {
        aError.ThrowUnknownError("[UniFFI] Callback handler already registered for errorsupport:ApplicationErrorReporter"_ns);
        return;
      }

      gCallbackInterfaceJsHandlerApplicationErrorReporter = &aCallbackHandler;
      uniffi_error_support_fn_init_callback_vtable_applicationerrorreporter(&kCallbackInterfaceVtableApplicationErrorReporter);
      break;
    }
    
    #ifdef MOZ_UNIFFI_FIXTURES
    case 1: {
      if (gCallbackInterfaceJsHandlerLogger) {
        aError.ThrowUnknownError("[UniFFI] Callback handler already registered for fixture_callbacks:Logger"_ns);
        return;
      }

      gCallbackInterfaceJsHandlerLogger = &aCallbackHandler;
      uniffi_uniffi_fixture_callbacks_fn_init_callback_vtable_logger(&kCallbackInterfaceVtableLogger);
      break;
    }
    #endif /* MOZ_UNIFFI_FIXTURES */

    default:
      aError.ThrowUnknownError(nsPrintfCString("Unknown interface id: %" PRIu64, aInterfaceId));
      return;
  }
}

void DeregisterCallbackHandler(uint64_t aInterfaceId, ErrorResult& aError) {
  switch (aInterfaceId) {
    
    case 0: {
      if (!gCallbackInterfaceJsHandlerApplicationErrorReporter) {
        aError.ThrowUnknownError("[UniFFI] Callback handler not registered for errorsupport:ApplicationErrorReporter"_ns);
        return;
      }

      gCallbackInterfaceJsHandlerApplicationErrorReporter = nullptr;
      break;
    }
    
    #ifdef MOZ_UNIFFI_FIXTURES
    case 1: {
      if (!gCallbackInterfaceJsHandlerLogger) {
        aError.ThrowUnknownError("[UniFFI] Callback handler not registered for fixture_callbacks:Logger"_ns);
        return;
      }

      gCallbackInterfaceJsHandlerLogger = nullptr;
      break;
    }
    #endif /* MOZ_UNIFFI_FIXTURES */

    default:
      aError.ThrowUnknownError(nsPrintfCString("Unknown interface id: %" PRIu64, aInterfaceId));
      return;
  }
}


// Define scaffolding call classes for each combination of return/argument types

class ScaffoldingCallHandlerUniffiErrorSupportFnFuncSetApplicationErrorReporter : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint64_t> mErrorReporter{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mErrorReporter.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_error_support_fn_func_set_application_error_reporter(
      mErrorReporter.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiErrorSupportFnFuncUnsetApplicationErrorReporter : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_error_support_fn_func_unset_application_error_reporter(
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnFuncScore : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mInterestVector{};
  FfiValueRustBuffer mContentCategories{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueFloat<double> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mInterestVector.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mContentCategories.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueFloat<double>::FromRust(
      uniffi_relevancy_fn_func_score(
        mInterestVector.IntoRust(),
        mContentCategories.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreBanditInit : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRelevancyRelevancyStore mPtr{};
  FfiValueRustBuffer mBandit{};
  FfiValueRustBuffer mArms{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mBandit.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mArms.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_relevancy_fn_method_relevancystore_bandit_init(
      mPtr.IntoRust(),
      mBandit.IntoRust(),
      mArms.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreBanditSelect : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRelevancyRelevancyStore mPtr{};
  FfiValueRustBuffer mBandit{};
  FfiValueRustBuffer mArms{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mBandit.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mArms.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_relevancy_fn_method_relevancystore_bandit_select(
        mPtr.IntoRust(),
        mBandit.IntoRust(),
        mArms.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreBanditUpdate : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRelevancyRelevancyStore mPtr{};
  FfiValueRustBuffer mBandit{};
  FfiValueRustBuffer mArm{};
  FfiValueInt<int8_t> mSelected{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mBandit.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mArm.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
    mSelected.Lower(aArgs[3], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_relevancy_fn_method_relevancystore_bandit_update(
      mPtr.IntoRust(),
      mBandit.IntoRust(),
      mArm.IntoRust(),
      mSelected.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreClose : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRelevancyRelevancyStore mPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_relevancy_fn_method_relevancystore_close(
      mPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreEnsureInterestDataPopulated : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRelevancyRelevancyStore mPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_relevancy_fn_method_relevancystore_ensure_interest_data_populated(
      mPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreGetBanditData : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRelevancyRelevancyStore mPtr{};
  FfiValueRustBuffer mBandit{};
  FfiValueRustBuffer mArm{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mBandit.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mArm.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_relevancy_fn_method_relevancystore_get_bandit_data(
        mPtr.IntoRust(),
        mBandit.IntoRust(),
        mArm.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreIngest : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRelevancyRelevancyStore mPtr{};
  FfiValueRustBuffer mTopUrlsByFrecency{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mTopUrlsByFrecency.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_relevancy_fn_method_relevancystore_ingest(
        mPtr.IntoRust(),
        mTopUrlsByFrecency.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreInterrupt : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRelevancyRelevancyStore mPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_relevancy_fn_method_relevancystore_interrupt(
      mPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreUserInterestVector : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRelevancyRelevancyStore mPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_relevancy_fn_method_relevancystore_user_interest_vector(
        mPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnConstructorRelevancystoreNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mDbPath{};
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService mRemoteSettings{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleRelevancyRelevancyStore mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mDbPath.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mRemoteSettings.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleRelevancyRelevancyStore::FromRust(
      uniffi_relevancy_fn_constructor_relevancystore_new(
        mDbPath.IntoRust(),
        mRemoteSettings.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsDownloadAttachmentToPath : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettings mPtr{};
  FfiValueRustBuffer mAttachmentId{};
  FfiValueRustBuffer mPath{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mAttachmentId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mPath.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_remote_settings_fn_method_remotesettings_download_attachment_to_path(
      mPtr.IntoRust(),
      mAttachmentId.IntoRust(),
      mPath.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsGetRecords : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettings mPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_remote_settings_fn_method_remotesettings_get_records(
        mPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsGetRecordsSince : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettings mPtr{};
  FfiValueInt<uint64_t> mTimestamp{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mTimestamp.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_remote_settings_fn_method_remotesettings_get_records_since(
        mPtr.IntoRust(),
        mTimestamp.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnConstructorRemotesettingsNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mRemoteSettingsConfig{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettings mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mRemoteSettingsConfig.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleRemoteSettingsRemoteSettings::FromRust(
      uniffi_remote_settings_fn_constructor_remotesettings_new(
        mRemoteSettingsConfig.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientCollectionName : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsClient mPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_remote_settings_fn_method_remotesettingsclient_collection_name(
        mPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientGetAttachment : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsClient mPtr{};
  FfiValueRustBuffer mRecord{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mRecord.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_remote_settings_fn_method_remotesettingsclient_get_attachment(
        mPtr.IntoRust(),
        mRecord.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientGetRecords : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsClient mPtr{};
  FfiValueInt<int8_t> mSyncIfEmpty{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mSyncIfEmpty.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_remote_settings_fn_method_remotesettingsclient_get_records(
        mPtr.IntoRust(),
        mSyncIfEmpty.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientGetRecordsMap : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsClient mPtr{};
  FfiValueInt<int8_t> mSyncIfEmpty{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mSyncIfEmpty.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_remote_settings_fn_method_remotesettingsclient_get_records_map(
        mPtr.IntoRust(),
        mSyncIfEmpty.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientShutdown : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsClient mPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_remote_settings_fn_method_remotesettingsclient_shutdown(
      mPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientSync : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsClient mPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_remote_settings_fn_method_remotesettingsclient_sync(
      mPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsserviceMakeClient : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService mPtr{};
  FfiValueRustBuffer mCollectionName{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsClient mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mCollectionName.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleRemoteSettingsRemoteSettingsClient::FromRust(
      uniffi_remote_settings_fn_method_remotesettingsservice_make_client(
        mPtr.IntoRust(),
        mCollectionName.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsserviceSync : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService mPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_remote_settings_fn_method_remotesettingsservice_sync(
        mPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsserviceUpdateConfig : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService mPtr{};
  FfiValueRustBuffer mConfig{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mConfig.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_remote_settings_fn_method_remotesettingsservice_update_config(
      mPtr.IntoRust(),
      mConfig.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnConstructorRemotesettingsserviceNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mStorageDir{};
  FfiValueRustBuffer mConfig{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mStorageDir.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mConfig.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleRemoteSettingsRemoteSettingsService::FromRust(
      uniffi_remote_settings_fn_constructor_remotesettingsservice_new(
        mStorageDir.IntoRust(),
        mConfig.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSearchFnMethodSearchengineselectorClearSearchConfig : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSearchSearchEngineSelector mPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_search_fn_method_searchengineselector_clear_search_config(
      mPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiSearchFnMethodSearchengineselectorFilterEngineConfiguration : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSearchSearchEngineSelector mPtr{};
  FfiValueRustBuffer mUserEnvironment{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mUserEnvironment.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_search_fn_method_searchengineselector_filter_engine_configuration(
        mPtr.IntoRust(),
        mUserEnvironment.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSearchFnMethodSearchengineselectorSetConfigOverrides : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSearchSearchEngineSelector mPtr{};
  FfiValueRustBuffer mOverrides{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mOverrides.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_search_fn_method_searchengineselector_set_config_overrides(
      mPtr.IntoRust(),
      mOverrides.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiSearchFnMethodSearchengineselectorSetSearchConfig : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSearchSearchEngineSelector mPtr{};
  FfiValueRustBuffer mConfiguration{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mConfiguration.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_search_fn_method_searchengineselector_set_search_config(
      mPtr.IntoRust(),
      mConfiguration.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiSearchFnMethodSearchengineselectorUseRemoteSettingsServer : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSearchSearchEngineSelector mPtr{};
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService mService{};
  FfiValueInt<int8_t> mApplyEngineOverrides{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mService.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mApplyEngineOverrides.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_search_fn_method_searchengineselector_use_remote_settings_server(
      mPtr.IntoRust(),
      mService.IntoRust(),
      mApplyEngineOverrides.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiSearchFnConstructorSearchengineselectorNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleSearchSearchEngineSelector mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleSearchSearchEngineSelector::FromRust(
      uniffi_search_fn_constructor_searchengineselector_new(
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnFuncRawSuggestionUrlMatches : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mRawUrl{};
  FfiValueRustBuffer mCookedUrl{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mRawUrl.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mCookedUrl.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_suggest_fn_func_raw_suggestion_url_matches(
        mRawUrl.IntoRust(),
        mCookedUrl.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreAnyDismissedSuggestions : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_suggest_fn_method_suggeststore_any_dismissed_suggestions(
        mPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreClear : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_suggest_fn_method_suggeststore_clear(
      mPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreClearDismissedSuggestions : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_suggest_fn_method_suggeststore_clear_dismissed_suggestions(
      mPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreDismissByKey : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mPtr{};
  FfiValueRustBuffer mKey{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mKey.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_suggest_fn_method_suggeststore_dismiss_by_key(
      mPtr.IntoRust(),
      mKey.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreDismissBySuggestion : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mPtr{};
  FfiValueRustBuffer mSuggestion{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mSuggestion.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_suggest_fn_method_suggeststore_dismiss_by_suggestion(
      mPtr.IntoRust(),
      mSuggestion.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreDismissSuggestion : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mPtr{};
  FfiValueRustBuffer mSuggestionUrl{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mSuggestionUrl.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_suggest_fn_method_suggeststore_dismiss_suggestion(
      mPtr.IntoRust(),
      mSuggestionUrl.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreFetchGeonames : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mPtr{};
  FfiValueRustBuffer mQuery{};
  FfiValueInt<int8_t> mMatchNamePrefix{};
  FfiValueRustBuffer mGeonameType{};
  FfiValueRustBuffer mFilter{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mQuery.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mMatchNamePrefix.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
    mGeonameType.Lower(aArgs[3], aError);
    if (aError.Failed()) {
      return;
    }
    mFilter.Lower(aArgs[4], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_suggest_fn_method_suggeststore_fetch_geonames(
        mPtr.IntoRust(),
        mQuery.IntoRust(),
        mMatchNamePrefix.IntoRust(),
        mGeonameType.IntoRust(),
        mFilter.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreFetchGlobalConfig : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_suggest_fn_method_suggeststore_fetch_global_config(
        mPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreFetchProviderConfig : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mPtr{};
  FfiValueRustBuffer mProvider{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mProvider.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_suggest_fn_method_suggeststore_fetch_provider_config(
        mPtr.IntoRust(),
        mProvider.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreIngest : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mPtr{};
  FfiValueRustBuffer mConstraints{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mConstraints.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_suggest_fn_method_suggeststore_ingest(
        mPtr.IntoRust(),
        mConstraints.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreInterrupt : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mPtr{};
  FfiValueRustBuffer mKind{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mKind.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_suggest_fn_method_suggeststore_interrupt(
      mPtr.IntoRust(),
      mKind.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreIsDismissedByKey : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mPtr{};
  FfiValueRustBuffer mKey{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mKey.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_suggest_fn_method_suggeststore_is_dismissed_by_key(
        mPtr.IntoRust(),
        mKey.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreIsDismissedBySuggestion : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mPtr{};
  FfiValueRustBuffer mSuggestion{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mSuggestion.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_suggest_fn_method_suggeststore_is_dismissed_by_suggestion(
        mPtr.IntoRust(),
        mSuggestion.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreQuery : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mPtr{};
  FfiValueRustBuffer mQuery{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mQuery.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_suggest_fn_method_suggeststore_query(
        mPtr.IntoRust(),
        mQuery.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreQueryWithMetrics : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mPtr{};
  FfiValueRustBuffer mQuery{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mQuery.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_suggest_fn_method_suggeststore_query_with_metrics(
        mPtr.IntoRust(),
        mQuery.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnConstructorSuggeststoreNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mPath{};
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService mRemoteSettingsService{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPath.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mRemoteSettingsService.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleSuggestSuggestStore::FromRust(
      uniffi_suggest_fn_constructor_suggeststore_new(
        mPath.IntoRust(),
        mRemoteSettingsService.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderBuild : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleSuggestSuggestStore::FromRust(
      uniffi_suggest_fn_method_suggeststorebuilder_build(
        mPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderCachePath : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mPtr{};
  FfiValueRustBuffer mPath{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mPath.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleSuggestSuggestStoreBuilder::FromRust(
      uniffi_suggest_fn_method_suggeststorebuilder_cache_path(
        mPtr.IntoRust(),
        mPath.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderDataPath : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mPtr{};
  FfiValueRustBuffer mPath{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mPath.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleSuggestSuggestStoreBuilder::FromRust(
      uniffi_suggest_fn_method_suggeststorebuilder_data_path(
        mPtr.IntoRust(),
        mPath.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderLoadExtension : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mPtr{};
  FfiValueRustBuffer mLibrary{};
  FfiValueRustBuffer mEntryPoint{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mLibrary.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mEntryPoint.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleSuggestSuggestStoreBuilder::FromRust(
      uniffi_suggest_fn_method_suggeststorebuilder_load_extension(
        mPtr.IntoRust(),
        mLibrary.IntoRust(),
        mEntryPoint.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderRemoteSettingsBucketName : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mPtr{};
  FfiValueRustBuffer mBucketName{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mBucketName.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleSuggestSuggestStoreBuilder::FromRust(
      uniffi_suggest_fn_method_suggeststorebuilder_remote_settings_bucket_name(
        mPtr.IntoRust(),
        mBucketName.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderRemoteSettingsServer : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mPtr{};
  FfiValueRustBuffer mServer{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mServer.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleSuggestSuggestStoreBuilder::FromRust(
      uniffi_suggest_fn_method_suggeststorebuilder_remote_settings_server(
        mPtr.IntoRust(),
        mServer.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderRemoteSettingsService : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mPtr{};
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService mRsService{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mRsService.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleSuggestSuggestStoreBuilder::FromRust(
      uniffi_suggest_fn_method_suggeststorebuilder_remote_settings_service(
        mPtr.IntoRust(),
        mRsService.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnConstructorSuggeststorebuilderNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleSuggestSuggestStoreBuilder::FromRust(
      uniffi_suggest_fn_constructor_suggeststorebuilder_new(
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodRemotecommandstoreAddRemoteCommand : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsRemoteCommandStore mPtr{};
  FfiValueRustBuffer mDeviceId{};
  FfiValueRustBuffer mCommand{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mDeviceId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mCommand.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_tabs_fn_method_remotecommandstore_add_remote_command(
        mPtr.IntoRust(),
        mDeviceId.IntoRust(),
        mCommand.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodRemotecommandstoreAddRemoteCommandAt : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsRemoteCommandStore mPtr{};
  FfiValueRustBuffer mDeviceId{};
  FfiValueRustBuffer mCommand{};
  FfiValueInt<int64_t> mWhen{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mDeviceId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mCommand.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
    mWhen.Lower(aArgs[3], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_tabs_fn_method_remotecommandstore_add_remote_command_at(
        mPtr.IntoRust(),
        mDeviceId.IntoRust(),
        mCommand.IntoRust(),
        mWhen.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodRemotecommandstoreGetUnsentCommands : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsRemoteCommandStore mPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_tabs_fn_method_remotecommandstore_get_unsent_commands(
        mPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodRemotecommandstoreRemoveRemoteCommand : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsRemoteCommandStore mPtr{};
  FfiValueRustBuffer mDeviceId{};
  FfiValueRustBuffer mCommand{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mDeviceId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mCommand.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_tabs_fn_method_remotecommandstore_remove_remote_command(
        mPtr.IntoRust(),
        mDeviceId.IntoRust(),
        mCommand.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodRemotecommandstoreSetPendingCommandSent : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsRemoteCommandStore mPtr{};
  FfiValueRustBuffer mCommand{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mCommand.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_tabs_fn_method_remotecommandstore_set_pending_command_sent(
        mPtr.IntoRust(),
        mCommand.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineApply : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_tabs_fn_method_tabsbridgedengine_apply(
        mPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineEnsureCurrentSyncId : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mPtr{};
  FfiValueRustBuffer mNewSyncId{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mNewSyncId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_tabs_fn_method_tabsbridgedengine_ensure_current_sync_id(
        mPtr.IntoRust(),
        mNewSyncId.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineLastSync : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int64_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int64_t>::FromRust(
      uniffi_tabs_fn_method_tabsbridgedengine_last_sync(
        mPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedenginePrepareForSync : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mPtr{};
  FfiValueRustBuffer mClientData{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mClientData.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsbridgedengine_prepare_for_sync(
      mPtr.IntoRust(),
      mClientData.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineReset : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsbridgedengine_reset(
      mPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineResetSyncId : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_tabs_fn_method_tabsbridgedengine_reset_sync_id(
        mPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineSetLastSync : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mPtr{};
  FfiValueInt<int64_t> mLastSync{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mLastSync.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsbridgedengine_set_last_sync(
      mPtr.IntoRust(),
      mLastSync.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineSetUploaded : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mPtr{};
  FfiValueInt<int64_t> mNewTimestamp{};
  FfiValueRustBuffer mUploadedIds{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mNewTimestamp.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mUploadedIds.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsbridgedengine_set_uploaded(
      mPtr.IntoRust(),
      mNewTimestamp.IntoRust(),
      mUploadedIds.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineStoreIncoming : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mPtr{};
  FfiValueRustBuffer mIncomingEnvelopesAsJson{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mIncomingEnvelopesAsJson.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsbridgedengine_store_incoming(
      mPtr.IntoRust(),
      mIncomingEnvelopesAsJson.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineSyncFinished : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsbridgedengine_sync_finished(
      mPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineSyncId : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_tabs_fn_method_tabsbridgedengine_sync_id(
        mPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineSyncStarted : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsbridgedengine_sync_started(
      mPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineWipe : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsbridgedengine_wipe(
      mPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreBridgedEngine : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsStore mPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleTabsTabsBridgedEngine::FromRust(
      uniffi_tabs_fn_method_tabsstore_bridged_engine(
        mPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreCloseConnection : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsStore mPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsstore_close_connection(
      mPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreGetAll : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsStore mPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_tabs_fn_method_tabsstore_get_all(
        mPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreNewRemoteCommandStore : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsStore mPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleTabsRemoteCommandStore mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleTabsRemoteCommandStore::FromRust(
      uniffi_tabs_fn_method_tabsstore_new_remote_command_store(
        mPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreRegisterWithSyncManager : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsStore mPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsstore_register_with_sync_manager(
      mPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreSetLocalTabs : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsStore mPtr{};
  FfiValueRustBuffer mRemoteTabs{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mRemoteTabs.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsstore_set_local_tabs(
      mPtr.IntoRust(),
      mRemoteTabs.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiTabsFnConstructorTabsstoreNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mPath{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleTabsTabsStore mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPath.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleTabsTabsStore::FromRust(
      uniffi_tabs_fn_constructor_tabsstore_new(
        mPath.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineApply : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_webext_storage_fn_method_webextstoragebridgedengine_apply(
        mPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineEnsureCurrentSyncId : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mPtr{};
  FfiValueRustBuffer mNewSyncId{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mNewSyncId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_webext_storage_fn_method_webextstoragebridgedengine_ensure_current_sync_id(
        mPtr.IntoRust(),
        mNewSyncId.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineLastSync : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int64_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int64_t>::FromRust(
      uniffi_webext_storage_fn_method_webextstoragebridgedengine_last_sync(
        mPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedenginePrepareForSync : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mPtr{};
  FfiValueRustBuffer mClientData{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mClientData.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_webext_storage_fn_method_webextstoragebridgedengine_prepare_for_sync(
      mPtr.IntoRust(),
      mClientData.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineReset : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_webext_storage_fn_method_webextstoragebridgedengine_reset(
      mPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineResetSyncId : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_webext_storage_fn_method_webextstoragebridgedengine_reset_sync_id(
        mPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineSetLastSync : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mPtr{};
  FfiValueInt<int64_t> mLastSync{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mLastSync.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_webext_storage_fn_method_webextstoragebridgedengine_set_last_sync(
      mPtr.IntoRust(),
      mLastSync.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineSetUploaded : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mPtr{};
  FfiValueInt<int64_t> mServerModifiedMillis{};
  FfiValueRustBuffer mGuids{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mServerModifiedMillis.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mGuids.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_webext_storage_fn_method_webextstoragebridgedengine_set_uploaded(
      mPtr.IntoRust(),
      mServerModifiedMillis.IntoRust(),
      mGuids.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineStoreIncoming : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mPtr{};
  FfiValueRustBuffer mIncoming{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mIncoming.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_webext_storage_fn_method_webextstoragebridgedengine_store_incoming(
      mPtr.IntoRust(),
      mIncoming.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineSyncFinished : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_webext_storage_fn_method_webextstoragebridgedengine_sync_finished(
      mPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineSyncId : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_webext_storage_fn_method_webextstoragebridgedengine_sync_id(
        mPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineSyncStarted : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_webext_storage_fn_method_webextstoragebridgedengine_sync_started(
      mPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineWipe : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_webext_storage_fn_method_webextstoragebridgedengine_wipe(
      mPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreBridgedEngine : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageStore mPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine::FromRust(
      uniffi_webext_storage_fn_method_webextstoragestore_bridged_engine(
        mPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreClear : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageStore mPtr{};
  FfiValueRustBuffer mExtId{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mExtId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_webext_storage_fn_method_webextstoragestore_clear(
        mPtr.IntoRust(),
        mExtId.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreClose : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageStore mPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_webext_storage_fn_method_webextstoragestore_close(
      mPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreGet : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageStore mPtr{};
  FfiValueRustBuffer mExtId{};
  FfiValueRustBuffer mKeys{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mExtId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mKeys.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_webext_storage_fn_method_webextstoragestore_get(
        mPtr.IntoRust(),
        mExtId.IntoRust(),
        mKeys.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreGetBytesInUse : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageStore mPtr{};
  FfiValueRustBuffer mExtId{};
  FfiValueRustBuffer mKeys{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint64_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mExtId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mKeys.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint64_t>::FromRust(
      uniffi_webext_storage_fn_method_webextstoragestore_get_bytes_in_use(
        mPtr.IntoRust(),
        mExtId.IntoRust(),
        mKeys.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreGetSyncedChanges : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageStore mPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_webext_storage_fn_method_webextstoragestore_get_synced_changes(
        mPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreRemove : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageStore mPtr{};
  FfiValueRustBuffer mExtId{};
  FfiValueRustBuffer mKeys{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mExtId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mKeys.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_webext_storage_fn_method_webextstoragestore_remove(
        mPtr.IntoRust(),
        mExtId.IntoRust(),
        mKeys.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreSet : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageStore mPtr{};
  FfiValueRustBuffer mExtId{};
  FfiValueRustBuffer mVal{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mExtId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mVal.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_webext_storage_fn_method_webextstoragestore_set(
        mPtr.IntoRust(),
        mExtId.IntoRust(),
        mVal.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnConstructorWebextstoragestoreNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mPath{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageStore mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPath.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleWebextstorageWebExtStorageStore::FromRust(
      uniffi_webext_storage_fn_constructor_webextstoragestore_new(
        mPath.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};

#ifdef MOZ_UNIFFI_FIXTURES
class ScaffoldingCallHandlerUniffiArithmeticalFnFuncAdd : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint64_t> mA{};
  FfiValueInt<uint64_t> mB{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint64_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mB.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint64_t>::FromRust(
      uniffi_arithmetical_fn_func_add(
        mA.IntoRust(),
        mB.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiArithmeticalFnFuncDiv : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint64_t> mDividend{};
  FfiValueInt<uint64_t> mDivisor{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint64_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mDividend.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mDivisor.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint64_t>::FromRust(
      uniffi_arithmetical_fn_func_div(
        mDividend.IntoRust(),
        mDivisor.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiArithmeticalFnFuncEqual : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint64_t> mA{};
  FfiValueInt<uint64_t> mB{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mB.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_arithmetical_fn_func_equal(
        mA.IntoRust(),
        mB.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiArithmeticalFnFuncSub : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint64_t> mA{};
  FfiValueInt<uint64_t> mB{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint64_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mB.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint64_t>::FromRust(
      uniffi_arithmetical_fn_func_sub(
        mA.IntoRust(),
        mB.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiCustomTypesFnFuncGetCustomTypesDemo : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mDemo{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mDemo.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_custom_types_fn_func_get_custom_types_demo(
        mDemo.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiFixtureExternalTypesFnFuncGradient : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueFloat<double> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mValue.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueFloat<double>::FromRust(
      uniffi_uniffi_fixture_external_types_fn_func_gradient(
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiFixtureExternalTypesFnFuncIntersection : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mLn1{};
  FfiValueRustBuffer mLn2{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mLn1.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mLn2.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_fixture_external_types_fn_func_intersection(
        mLn1.IntoRust(),
        mLn2.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiFixtureExternalTypesFnFuncMoveSpriteToOrigin : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSpritesSprite mSprite{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mSprite.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_uniffi_fixture_external_types_fn_func_move_sprite_to_origin(
      mSprite.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiFixtureCallbacksFnFuncCallLogRepeat : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint64_t> mLogger{};
  FfiValueRustBuffer mMessage{};
  FfiValueInt<uint32_t> mCount{};
  FfiValueRustBuffer mExclude{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mLogger.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mMessage.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mCount.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
    mExclude.Lower(aArgs[3], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_uniffi_fixture_callbacks_fn_func_call_log_repeat(
      mLogger.IntoRust(),
      mMessage.IntoRust(),
      mCount.IntoRust(),
      mExclude.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiFixtureCallbacksFnFuncLogEvenNumbers : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint64_t> mLogger{};
  FfiValueRustBuffer mItems{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mLogger.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mItems.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_uniffi_fixture_callbacks_fn_func_log_even_numbers(
      mLogger.IntoRust(),
      mItems.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiFixtureCallbacksFnFuncLogEvenNumbersMainThread : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint64_t> mLogger{};
  FfiValueRustBuffer mItems{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mLogger.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mItems.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_uniffi_fixture_callbacks_fn_func_log_even_numbers_main_thread(
      mLogger.IntoRust(),
      mItems.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncExpensiveComputation : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncExpensiveComputation() : UniffiAsyncCallHandler(ffi_uniffi_fixture_futures_rust_future_poll_u32, ffi_uniffi_fixture_futures_rust_future_free_u32) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueInt<uint32_t> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {

    mFutureHandle = uniffi_uniffi_fixture_futures_fn_func_expensive_computation(
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint32_t>::FromRust(
      ffi_uniffi_fixture_futures_rust_future_complete_u32(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncInitializeGeckoGlobalWorkerQueue : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_uniffi_fixture_futures_fn_func_initialize_gecko_global_worker_queue(
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncInitializeGlobalWorkerQueue : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleFuturesWorkerQueue mWorkerQueue{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mWorkerQueue.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_uniffi_fixture_futures_fn_func_initialize_global_worker_queue(
      mWorkerQueue.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncRoundtripF32 : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncRoundtripF32() : UniffiAsyncCallHandler(ffi_uniffi_fixture_futures_rust_future_poll_f32, ffi_uniffi_fixture_futures_rust_future_free_f32) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueFloat<float> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueFloat<float> mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_fixture_futures_fn_func_roundtrip_f32(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueFloat<float>::FromRust(
      ffi_uniffi_fixture_futures_rust_future_complete_f32(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncRoundtripF64 : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncRoundtripF64() : UniffiAsyncCallHandler(ffi_uniffi_fixture_futures_rust_future_poll_f64, ffi_uniffi_fixture_futures_rust_future_free_f64) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueFloat<double> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueFloat<double> mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_fixture_futures_fn_func_roundtrip_f64(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueFloat<double>::FromRust(
      ffi_uniffi_fixture_futures_rust_future_complete_f64(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncRoundtripI16 : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncRoundtripI16() : UniffiAsyncCallHandler(ffi_uniffi_fixture_futures_rust_future_poll_i16, ffi_uniffi_fixture_futures_rust_future_free_i16) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueInt<int16_t> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueInt<int16_t> mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_fixture_futures_fn_func_roundtrip_i16(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int16_t>::FromRust(
      ffi_uniffi_fixture_futures_rust_future_complete_i16(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncRoundtripI32 : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncRoundtripI32() : UniffiAsyncCallHandler(ffi_uniffi_fixture_futures_rust_future_poll_i32, ffi_uniffi_fixture_futures_rust_future_free_i32) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueInt<int32_t> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueInt<int32_t> mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_fixture_futures_fn_func_roundtrip_i32(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int32_t>::FromRust(
      ffi_uniffi_fixture_futures_rust_future_complete_i32(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncRoundtripI64 : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncRoundtripI64() : UniffiAsyncCallHandler(ffi_uniffi_fixture_futures_rust_future_poll_i64, ffi_uniffi_fixture_futures_rust_future_free_i64) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueInt<int64_t> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueInt<int64_t> mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_fixture_futures_fn_func_roundtrip_i64(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int64_t>::FromRust(
      ffi_uniffi_fixture_futures_rust_future_complete_i64(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncRoundtripI8 : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncRoundtripI8() : UniffiAsyncCallHandler(ffi_uniffi_fixture_futures_rust_future_poll_i8, ffi_uniffi_fixture_futures_rust_future_free_i8) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueInt<int8_t> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueInt<int8_t> mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_fixture_futures_fn_func_roundtrip_i8(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      ffi_uniffi_fixture_futures_rust_future_complete_i8(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncRoundtripMap : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncRoundtripMap() : UniffiAsyncCallHandler(ffi_uniffi_fixture_futures_rust_future_poll_rust_buffer, ffi_uniffi_fixture_futures_rust_future_free_rust_buffer) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueRustBuffer mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueRustBuffer mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_fixture_futures_fn_func_roundtrip_map(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      ffi_uniffi_fixture_futures_rust_future_complete_rust_buffer(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncRoundtripObj : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncRoundtripObj() : UniffiAsyncCallHandler(ffi_uniffi_fixture_futures_rust_future_poll_pointer, ffi_uniffi_fixture_futures_rust_future_free_pointer) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueObjectHandleFuturesTraveller mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueObjectHandleFuturesTraveller mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_fixture_futures_fn_func_roundtrip_obj(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleFuturesTraveller::FromRust(
      ffi_uniffi_fixture_futures_rust_future_complete_pointer(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncRoundtripString : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncRoundtripString() : UniffiAsyncCallHandler(ffi_uniffi_fixture_futures_rust_future_poll_rust_buffer, ffi_uniffi_fixture_futures_rust_future_free_rust_buffer) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueRustBuffer mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueRustBuffer mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_fixture_futures_fn_func_roundtrip_string(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      ffi_uniffi_fixture_futures_rust_future_complete_rust_buffer(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncRoundtripU16 : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncRoundtripU16() : UniffiAsyncCallHandler(ffi_uniffi_fixture_futures_rust_future_poll_u16, ffi_uniffi_fixture_futures_rust_future_free_u16) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueInt<uint16_t> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueInt<uint16_t> mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_fixture_futures_fn_func_roundtrip_u16(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint16_t>::FromRust(
      ffi_uniffi_fixture_futures_rust_future_complete_u16(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncRoundtripU32 : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncRoundtripU32() : UniffiAsyncCallHandler(ffi_uniffi_fixture_futures_rust_future_poll_u32, ffi_uniffi_fixture_futures_rust_future_free_u32) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueInt<uint32_t> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueInt<uint32_t> mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_fixture_futures_fn_func_roundtrip_u32(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint32_t>::FromRust(
      ffi_uniffi_fixture_futures_rust_future_complete_u32(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncRoundtripU64 : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncRoundtripU64() : UniffiAsyncCallHandler(ffi_uniffi_fixture_futures_rust_future_poll_u64, ffi_uniffi_fixture_futures_rust_future_free_u64) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueInt<uint64_t> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueInt<uint64_t> mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_fixture_futures_fn_func_roundtrip_u64(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint64_t>::FromRust(
      ffi_uniffi_fixture_futures_rust_future_complete_u64(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncRoundtripU8 : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncRoundtripU8() : UniffiAsyncCallHandler(ffi_uniffi_fixture_futures_rust_future_poll_u8, ffi_uniffi_fixture_futures_rust_future_free_u8) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueInt<uint8_t> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueInt<uint8_t> mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_fixture_futures_fn_func_roundtrip_u8(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint8_t>::FromRust(
      ffi_uniffi_fixture_futures_rust_future_complete_u8(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncRoundtripVec : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncRoundtripVec() : UniffiAsyncCallHandler(ffi_uniffi_fixture_futures_rust_future_poll_rust_buffer, ffi_uniffi_fixture_futures_rust_future_free_rust_buffer) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueRustBuffer mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueRustBuffer mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_fixture_futures_fn_func_roundtrip_vec(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      ffi_uniffi_fixture_futures_rust_future_complete_rust_buffer(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnMethodFuturetesterCompleteFutures : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleFuturesFutureTester mPtr{};
  FfiValueInt<uint8_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint32_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint32_t>::FromRust(
      uniffi_uniffi_fixture_futures_fn_method_futuretester_complete_futures(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnMethodFuturetesterMakeFuture : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnMethodFuturetesterMakeFuture() : UniffiAsyncCallHandler(ffi_uniffi_fixture_futures_rust_future_poll_u8, ffi_uniffi_fixture_futures_rust_future_free_u8) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueInt<uint8_t> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueObjectHandleFuturesFutureTester mPtr{};
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_fixture_futures_fn_method_futuretester_make_future(
      mPtr.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint8_t>::FromRust(
      ffi_uniffi_fixture_futures_rust_future_complete_u8(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnMethodFuturetesterWakeFutures : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleFuturesFutureTester mPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_uniffi_fixture_futures_fn_method_futuretester_wake_futures(
      mPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnConstructorFuturetesterInit : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleFuturesFutureTester mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleFuturesFutureTester::FromRust(
      uniffi_uniffi_fixture_futures_fn_constructor_futuretester_init(
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnMethodRusttaskRun : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleFuturesRustTask mPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_uniffi_fixture_futures_fn_method_rusttask_run(
      mPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnMethodTravellerName : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleFuturesTraveller mPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_fixture_futures_fn_method_traveller_name(
        mPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnConstructorTravellerNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mName{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleFuturesTraveller mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mName.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleFuturesTraveller::FromRust(
      uniffi_uniffi_fixture_futures_fn_constructor_traveller_new(
        mName.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnMethodWorkerqueueAddTask : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleFuturesWorkerQueue mPtr{};
  FfiValueObjectHandleFuturesRustTask mTask{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mTask.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_uniffi_fixture_futures_fn_method_workerqueue_add_task(
      mPtr.IntoRust(),
      mTask.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiGeometryFnFuncGradient : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mLn{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueFloat<double> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mLn.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueFloat<double>::FromRust(
      uniffi_uniffi_geometry_fn_func_gradient(
        mLn.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiGeometryFnFuncIntersection : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mLn1{};
  FfiValueRustBuffer mLn2{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mLn1.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mLn2.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_geometry_fn_func_intersection(
        mLn1.IntoRust(),
        mLn2.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiFixtureRefcountsFnFuncGetJsRefcount : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int32_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int32_t>::FromRust(
      uniffi_uniffi_fixture_refcounts_fn_func_get_js_refcount(
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiFixtureRefcountsFnFuncGetSingleton : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleRefcountsSingletonObject mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleRefcountsSingletonObject::FromRust(
      uniffi_uniffi_fixture_refcounts_fn_func_get_singleton(
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiFixtureRefcountsFnMethodSingletonobjectMethod : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRefcountsSingletonObject mPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_uniffi_fixture_refcounts_fn_method_singletonobject_method(
      mPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnFuncCopieCarte : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mC{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mC.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_rondpoint_fn_func_copie_carte(
        mC.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnFuncCopieDictionnaire : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mD{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mD.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_rondpoint_fn_func_copie_dictionnaire(
        mD.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnFuncCopieEnumeration : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mE{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mE.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_rondpoint_fn_func_copie_enumeration(
        mE.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnFuncCopieEnumerations : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mE{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mE.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_rondpoint_fn_func_copie_enumerations(
        mE.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnFuncSwitcheroo : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<int8_t> mB{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mB.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_uniffi_rondpoint_fn_func_switcheroo(
        mB.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonBoolean : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointOptionneur mPtr{};
  FfiValueInt<int8_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_boolean(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonEnum : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointOptionneur mPtr{};
  FfiValueRustBuffer mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_enum(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonF32 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointOptionneur mPtr{};
  FfiValueFloat<float> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueFloat<float> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueFloat<float>::FromRust(
      uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_f32(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonF64 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointOptionneur mPtr{};
  FfiValueFloat<double> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueFloat<double> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueFloat<double>::FromRust(
      uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_f64(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonI16Dec : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointOptionneur mPtr{};
  FfiValueInt<int16_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int16_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int16_t>::FromRust(
      uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_i16_dec(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonI16Hex : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointOptionneur mPtr{};
  FfiValueInt<int16_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int16_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int16_t>::FromRust(
      uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_i16_hex(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonI32Dec : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointOptionneur mPtr{};
  FfiValueInt<int32_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int32_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int32_t>::FromRust(
      uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_i32_dec(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonI32Hex : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointOptionneur mPtr{};
  FfiValueInt<int32_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int32_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int32_t>::FromRust(
      uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_i32_hex(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonI64Dec : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointOptionneur mPtr{};
  FfiValueInt<int64_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int64_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int64_t>::FromRust(
      uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_i64_dec(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonI64Hex : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointOptionneur mPtr{};
  FfiValueInt<int64_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int64_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int64_t>::FromRust(
      uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_i64_hex(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonI8Dec : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointOptionneur mPtr{};
  FfiValueInt<int8_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_i8_dec(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonI8Hex : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointOptionneur mPtr{};
  FfiValueInt<int8_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_i8_hex(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonNull : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointOptionneur mPtr{};
  FfiValueRustBuffer mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_null(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonSequence : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointOptionneur mPtr{};
  FfiValueRustBuffer mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_sequence(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonString : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointOptionneur mPtr{};
  FfiValueRustBuffer mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_string(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonU16Dec : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointOptionneur mPtr{};
  FfiValueInt<uint16_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint16_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint16_t>::FromRust(
      uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_u16_dec(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonU16Hex : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointOptionneur mPtr{};
  FfiValueInt<uint16_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint16_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint16_t>::FromRust(
      uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_u16_hex(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonU32Dec : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointOptionneur mPtr{};
  FfiValueInt<uint32_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint32_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint32_t>::FromRust(
      uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_u32_dec(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonU32Hex : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointOptionneur mPtr{};
  FfiValueInt<uint32_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint32_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint32_t>::FromRust(
      uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_u32_hex(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonU32Oct : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointOptionneur mPtr{};
  FfiValueInt<uint32_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint32_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint32_t>::FromRust(
      uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_u32_oct(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonU64Dec : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointOptionneur mPtr{};
  FfiValueInt<uint64_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint64_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint64_t>::FromRust(
      uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_u64_dec(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonU64Hex : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointOptionneur mPtr{};
  FfiValueInt<uint64_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint64_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint64_t>::FromRust(
      uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_u64_hex(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonU8Dec : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointOptionneur mPtr{};
  FfiValueInt<uint8_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint8_t>::FromRust(
      uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_u8_dec(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonU8Hex : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointOptionneur mPtr{};
  FfiValueInt<uint8_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint8_t>::FromRust(
      uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_u8_hex(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonZero : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointOptionneur mPtr{};
  FfiValueRustBuffer mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_rondpoint_fn_method_optionneur_sinon_zero(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnConstructorOptionneurNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleRondpointOptionneur mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleRondpointOptionneur::FromRust(
      uniffi_uniffi_rondpoint_fn_constructor_optionneur_new(
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodRetourneurIdentiqueBoolean : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointRetourneur mPtr{};
  FfiValueInt<int8_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_uniffi_rondpoint_fn_method_retourneur_identique_boolean(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodRetourneurIdentiqueDouble : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointRetourneur mPtr{};
  FfiValueFloat<double> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueFloat<double> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueFloat<double>::FromRust(
      uniffi_uniffi_rondpoint_fn_method_retourneur_identique_double(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodRetourneurIdentiqueFloat : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointRetourneur mPtr{};
  FfiValueFloat<float> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueFloat<float> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueFloat<float>::FromRust(
      uniffi_uniffi_rondpoint_fn_method_retourneur_identique_float(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodRetourneurIdentiqueI16 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointRetourneur mPtr{};
  FfiValueInt<int16_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int16_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int16_t>::FromRust(
      uniffi_uniffi_rondpoint_fn_method_retourneur_identique_i16(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodRetourneurIdentiqueI32 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointRetourneur mPtr{};
  FfiValueInt<int32_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int32_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int32_t>::FromRust(
      uniffi_uniffi_rondpoint_fn_method_retourneur_identique_i32(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodRetourneurIdentiqueI64 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointRetourneur mPtr{};
  FfiValueInt<int64_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int64_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int64_t>::FromRust(
      uniffi_uniffi_rondpoint_fn_method_retourneur_identique_i64(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodRetourneurIdentiqueI8 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointRetourneur mPtr{};
  FfiValueInt<int8_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_uniffi_rondpoint_fn_method_retourneur_identique_i8(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodRetourneurIdentiqueNombres : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointRetourneur mPtr{};
  FfiValueRustBuffer mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_rondpoint_fn_method_retourneur_identique_nombres(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodRetourneurIdentiqueNombresSignes : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointRetourneur mPtr{};
  FfiValueRustBuffer mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_rondpoint_fn_method_retourneur_identique_nombres_signes(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodRetourneurIdentiqueOptionneurDictionnaire : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointRetourneur mPtr{};
  FfiValueRustBuffer mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_rondpoint_fn_method_retourneur_identique_optionneur_dictionnaire(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodRetourneurIdentiqueString : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointRetourneur mPtr{};
  FfiValueRustBuffer mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_rondpoint_fn_method_retourneur_identique_string(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodRetourneurIdentiqueU16 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointRetourneur mPtr{};
  FfiValueInt<uint16_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint16_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint16_t>::FromRust(
      uniffi_uniffi_rondpoint_fn_method_retourneur_identique_u16(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodRetourneurIdentiqueU32 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointRetourneur mPtr{};
  FfiValueInt<uint32_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint32_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint32_t>::FromRust(
      uniffi_uniffi_rondpoint_fn_method_retourneur_identique_u32(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodRetourneurIdentiqueU64 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointRetourneur mPtr{};
  FfiValueInt<uint64_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint64_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint64_t>::FromRust(
      uniffi_uniffi_rondpoint_fn_method_retourneur_identique_u64(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodRetourneurIdentiqueU8 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointRetourneur mPtr{};
  FfiValueInt<uint8_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint8_t>::FromRust(
      uniffi_uniffi_rondpoint_fn_method_retourneur_identique_u8(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnConstructorRetourneurNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleRondpointRetourneur mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleRondpointRetourneur::FromRust(
      uniffi_uniffi_rondpoint_fn_constructor_retourneur_new(
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodStringifierToStringBoolean : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointStringifier mPtr{};
  FfiValueInt<int8_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_boolean(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodStringifierToStringDouble : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointStringifier mPtr{};
  FfiValueFloat<double> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_double(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodStringifierToStringFloat : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointStringifier mPtr{};
  FfiValueFloat<float> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_float(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodStringifierToStringI16 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointStringifier mPtr{};
  FfiValueInt<int16_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_i16(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodStringifierToStringI32 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointStringifier mPtr{};
  FfiValueInt<int32_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_i32(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodStringifierToStringI64 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointStringifier mPtr{};
  FfiValueInt<int64_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_i64(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodStringifierToStringI8 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointStringifier mPtr{};
  FfiValueInt<int8_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_i8(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodStringifierToStringU16 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointStringifier mPtr{};
  FfiValueInt<uint16_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_u16(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodStringifierToStringU32 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointStringifier mPtr{};
  FfiValueInt<uint32_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_u32(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodStringifierToStringU64 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointStringifier mPtr{};
  FfiValueInt<uint64_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_u64(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodStringifierToStringU8 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointStringifier mPtr{};
  FfiValueInt<uint8_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_rondpoint_fn_method_stringifier_to_string_u8(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodStringifierWellKnownString : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRondpointStringifier mPtr{};
  FfiValueRustBuffer mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mValue.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_rondpoint_fn_method_stringifier_well_known_string(
        mPtr.IntoRust(),
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiRondpointFnConstructorStringifierNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleRondpointStringifier mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleRondpointStringifier::FromRust(
      uniffi_uniffi_rondpoint_fn_constructor_stringifier_new(
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiSpritesFnFuncTranslate : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mP{};
  FfiValueRustBuffer mV{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mP.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mV.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_sprites_fn_func_translate(
        mP.IntoRust(),
        mV.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiSpritesFnMethodSpriteGetPosition : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSpritesSprite mPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_sprites_fn_method_sprite_get_position(
        mPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiSpritesFnMethodSpriteMoveBy : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSpritesSprite mPtr{};
  FfiValueRustBuffer mDirection{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mDirection.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_uniffi_sprites_fn_method_sprite_move_by(
      mPtr.IntoRust(),
      mDirection.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiSpritesFnMethodSpriteMoveTo : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSpritesSprite mPtr{};
  FfiValueRustBuffer mPosition{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mPosition.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_uniffi_sprites_fn_method_sprite_move_to(
      mPtr.IntoRust(),
      mPosition.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiSpritesFnConstructorSpriteNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mInitialPosition{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleSpritesSprite mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mInitialPosition.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleSpritesSprite::FromRust(
      uniffi_uniffi_sprites_fn_constructor_sprite_new(
        mInitialPosition.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiSpritesFnConstructorSpriteNewRelativeTo : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mReference{};
  FfiValueRustBuffer mDirection{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleSpritesSprite mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mReference.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mDirection.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleSpritesSprite::FromRust(
      uniffi_uniffi_sprites_fn_constructor_sprite_new_relative_to(
        mReference.IntoRust(),
        mDirection.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiTodolistFnFuncCreateEntryWith : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mTodo{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mTodo.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_todolist_fn_func_create_entry_with(
        mTodo.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiTodolistFnFuncGetDefaultList : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_todolist_fn_func_get_default_list(
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiTodolistFnFuncSetDefaultList : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTodolistTodoList mList{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mList.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_uniffi_todolist_fn_func_set_default_list(
      mList.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiTodolistFnMethodTodolistAddEntries : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTodolistTodoList mPtr{};
  FfiValueRustBuffer mEntries{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mEntries.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_uniffi_todolist_fn_method_todolist_add_entries(
      mPtr.IntoRust(),
      mEntries.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiTodolistFnMethodTodolistAddEntry : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTodolistTodoList mPtr{};
  FfiValueRustBuffer mEntry{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mEntry.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_uniffi_todolist_fn_method_todolist_add_entry(
      mPtr.IntoRust(),
      mEntry.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiTodolistFnMethodTodolistAddItem : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTodolistTodoList mPtr{};
  FfiValueRustBuffer mTodo{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mTodo.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_uniffi_todolist_fn_method_todolist_add_item(
      mPtr.IntoRust(),
      mTodo.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiTodolistFnMethodTodolistAddItems : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTodolistTodoList mPtr{};
  FfiValueRustBuffer mItems{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mItems.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_uniffi_todolist_fn_method_todolist_add_items(
      mPtr.IntoRust(),
      mItems.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiTodolistFnMethodTodolistClearItem : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTodolistTodoList mPtr{};
  FfiValueRustBuffer mTodo{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mTodo.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_uniffi_todolist_fn_method_todolist_clear_item(
      mPtr.IntoRust(),
      mTodo.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiTodolistFnMethodTodolistGetEntries : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTodolistTodoList mPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_todolist_fn_method_todolist_get_entries(
        mPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiTodolistFnMethodTodolistGetFirst : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTodolistTodoList mPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_todolist_fn_method_todolist_get_first(
        mPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiTodolistFnMethodTodolistGetItems : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTodolistTodoList mPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_todolist_fn_method_todolist_get_items(
        mPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiTodolistFnMethodTodolistGetLast : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTodolistTodoList mPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_todolist_fn_method_todolist_get_last(
        mPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiTodolistFnMethodTodolistGetLastEntry : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTodolistTodoList mPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_todolist_fn_method_todolist_get_last_entry(
        mPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiTodolistFnMethodTodolistMakeDefault : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTodolistTodoList mPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_uniffi_todolist_fn_method_todolist_make_default(
      mPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiTodolistFnConstructorTodolistNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleTodolistTodoList mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleTodolistTodoList::FromRust(
      uniffi_uniffi_todolist_fn_constructor_todolist_new(
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiTraitInterfacesFnFuncMakeBuggyCalculator : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleUniffiTraitInterfacesCalc mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleUniffiTraitInterfacesCalc::FromRust(
      uniffi_uniffi_trait_interfaces_fn_func_make_buggy_calculator(
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiTraitInterfacesFnFuncMakeCalculator : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleUniffiTraitInterfacesCalc mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleUniffiTraitInterfacesCalc::FromRust(
      uniffi_uniffi_trait_interfaces_fn_func_make_calculator(
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiTraitInterfacesFnMethodCalcAdd : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleUniffiTraitInterfacesCalc mPtr{};
  FfiValueInt<uint32_t> mA{};
  FfiValueInt<uint32_t> mB{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint32_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mA.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mB.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint32_t>::FromRust(
      uniffi_uniffi_trait_interfaces_fn_method_calc_add(
        mPtr.IntoRust(),
        mA.IntoRust(),
        mB.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
#endif /* MOZ_UNIFFI_FIXTURES */

UniquePtr<UniffiSyncCallHandler> GetSyncCallHandler(uint64_t aId) {
  switch (aId) {

    case 0: {
      return MakeUnique<ScaffoldingCallHandlerUniffiErrorSupportFnFuncSetApplicationErrorReporter>();
    }
    case 1: {
      return MakeUnique<ScaffoldingCallHandlerUniffiErrorSupportFnFuncUnsetApplicationErrorReporter>();
    }
    case 2: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnFuncScore>();
    }
    case 3: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreBanditInit>();
    }
    case 4: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreBanditSelect>();
    }
    case 5: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreBanditUpdate>();
    }
    case 6: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreClose>();
    }
    case 7: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreEnsureInterestDataPopulated>();
    }
    case 8: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreGetBanditData>();
    }
    case 9: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreIngest>();
    }
    case 10: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreInterrupt>();
    }
    case 11: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreUserInterestVector>();
    }
    case 12: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnConstructorRelevancystoreNew>();
    }
    case 13: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsDownloadAttachmentToPath>();
    }
    case 14: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsGetRecords>();
    }
    case 15: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsGetRecordsSince>();
    }
    case 16: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnConstructorRemotesettingsNew>();
    }
    case 17: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientCollectionName>();
    }
    case 18: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientGetAttachment>();
    }
    case 19: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientGetRecords>();
    }
    case 20: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientGetRecordsMap>();
    }
    case 21: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientShutdown>();
    }
    case 22: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientSync>();
    }
    case 23: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsserviceMakeClient>();
    }
    case 24: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsserviceSync>();
    }
    case 25: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsserviceUpdateConfig>();
    }
    case 26: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnConstructorRemotesettingsserviceNew>();
    }
    case 27: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSearchFnMethodSearchengineselectorClearSearchConfig>();
    }
    case 28: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSearchFnMethodSearchengineselectorFilterEngineConfiguration>();
    }
    case 29: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSearchFnMethodSearchengineselectorSetConfigOverrides>();
    }
    case 30: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSearchFnMethodSearchengineselectorSetSearchConfig>();
    }
    case 31: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSearchFnMethodSearchengineselectorUseRemoteSettingsServer>();
    }
    case 32: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSearchFnConstructorSearchengineselectorNew>();
    }
    case 33: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnFuncRawSuggestionUrlMatches>();
    }
    case 34: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreAnyDismissedSuggestions>();
    }
    case 35: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreClear>();
    }
    case 36: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreClearDismissedSuggestions>();
    }
    case 37: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreDismissByKey>();
    }
    case 38: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreDismissBySuggestion>();
    }
    case 39: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreDismissSuggestion>();
    }
    case 40: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreFetchGeonames>();
    }
    case 41: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreFetchGlobalConfig>();
    }
    case 42: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreFetchProviderConfig>();
    }
    case 43: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreIngest>();
    }
    case 44: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreInterrupt>();
    }
    case 45: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreIsDismissedByKey>();
    }
    case 46: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreIsDismissedBySuggestion>();
    }
    case 47: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreQuery>();
    }
    case 48: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreQueryWithMetrics>();
    }
    case 49: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnConstructorSuggeststoreNew>();
    }
    case 50: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderBuild>();
    }
    case 51: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderCachePath>();
    }
    case 52: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderDataPath>();
    }
    case 53: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderLoadExtension>();
    }
    case 54: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderRemoteSettingsBucketName>();
    }
    case 55: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderRemoteSettingsServer>();
    }
    case 56: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderRemoteSettingsService>();
    }
    case 57: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnConstructorSuggeststorebuilderNew>();
    }
    case 58: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodRemotecommandstoreAddRemoteCommand>();
    }
    case 59: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodRemotecommandstoreAddRemoteCommandAt>();
    }
    case 60: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodRemotecommandstoreGetUnsentCommands>();
    }
    case 61: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodRemotecommandstoreRemoveRemoteCommand>();
    }
    case 62: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodRemotecommandstoreSetPendingCommandSent>();
    }
    case 63: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineApply>();
    }
    case 64: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineEnsureCurrentSyncId>();
    }
    case 65: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineLastSync>();
    }
    case 66: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedenginePrepareForSync>();
    }
    case 67: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineReset>();
    }
    case 68: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineResetSyncId>();
    }
    case 69: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineSetLastSync>();
    }
    case 70: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineSetUploaded>();
    }
    case 71: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineStoreIncoming>();
    }
    case 72: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineSyncFinished>();
    }
    case 73: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineSyncId>();
    }
    case 74: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineSyncStarted>();
    }
    case 75: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineWipe>();
    }
    case 76: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreBridgedEngine>();
    }
    case 77: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreCloseConnection>();
    }
    case 78: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreGetAll>();
    }
    case 79: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreNewRemoteCommandStore>();
    }
    case 80: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreRegisterWithSyncManager>();
    }
    case 81: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreSetLocalTabs>();
    }
    case 82: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnConstructorTabsstoreNew>();
    }
    case 83: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineApply>();
    }
    case 84: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineEnsureCurrentSyncId>();
    }
    case 85: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineLastSync>();
    }
    case 86: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedenginePrepareForSync>();
    }
    case 87: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineReset>();
    }
    case 88: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineResetSyncId>();
    }
    case 89: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineSetLastSync>();
    }
    case 90: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineSetUploaded>();
    }
    case 91: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineStoreIncoming>();
    }
    case 92: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineSyncFinished>();
    }
    case 93: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineSyncId>();
    }
    case 94: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineSyncStarted>();
    }
    case 95: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineWipe>();
    }
    case 96: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreBridgedEngine>();
    }
    case 97: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreClear>();
    }
    case 98: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreClose>();
    }
    case 99: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreGet>();
    }
    case 100: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreGetBytesInUse>();
    }
    case 101: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreGetSyncedChanges>();
    }
    case 102: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreRemove>();
    }
    case 103: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreSet>();
    }
    case 104: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnConstructorWebextstoragestoreNew>();
    }

#ifdef MOZ_UNIFFI_FIXTURES
    case 105: {
      return MakeUnique<ScaffoldingCallHandlerUniffiArithmeticalFnFuncAdd>();
    }
    case 106: {
      return MakeUnique<ScaffoldingCallHandlerUniffiArithmeticalFnFuncDiv>();
    }
    case 107: {
      return MakeUnique<ScaffoldingCallHandlerUniffiArithmeticalFnFuncEqual>();
    }
    case 108: {
      return MakeUnique<ScaffoldingCallHandlerUniffiArithmeticalFnFuncSub>();
    }
    case 109: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiCustomTypesFnFuncGetCustomTypesDemo>();
    }
    case 110: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiFixtureExternalTypesFnFuncGradient>();
    }
    case 111: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiFixtureExternalTypesFnFuncIntersection>();
    }
    case 112: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiFixtureExternalTypesFnFuncMoveSpriteToOrigin>();
    }
    case 113: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiFixtureCallbacksFnFuncCallLogRepeat>();
    }
    case 114: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiFixtureCallbacksFnFuncLogEvenNumbers>();
    }
    case 115: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiFixtureCallbacksFnFuncLogEvenNumbersMainThread>();
    }
    case 117: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncInitializeGeckoGlobalWorkerQueue>();
    }
    case 118: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncInitializeGlobalWorkerQueue>();
    }
    case 133: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnMethodFuturetesterCompleteFutures>();
    }
    case 135: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnMethodFuturetesterWakeFutures>();
    }
    case 136: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnConstructorFuturetesterInit>();
    }
    case 137: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnMethodRusttaskRun>();
    }
    case 138: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnMethodTravellerName>();
    }
    case 139: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnConstructorTravellerNew>();
    }
    case 140: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnMethodWorkerqueueAddTask>();
    }
    case 141: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiGeometryFnFuncGradient>();
    }
    case 142: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiGeometryFnFuncIntersection>();
    }
    case 143: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiFixtureRefcountsFnFuncGetJsRefcount>();
    }
    case 144: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiFixtureRefcountsFnFuncGetSingleton>();
    }
    case 145: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiFixtureRefcountsFnMethodSingletonobjectMethod>();
    }
    case 146: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnFuncCopieCarte>();
    }
    case 147: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnFuncCopieDictionnaire>();
    }
    case 148: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnFuncCopieEnumeration>();
    }
    case 149: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnFuncCopieEnumerations>();
    }
    case 150: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnFuncSwitcheroo>();
    }
    case 151: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonBoolean>();
    }
    case 152: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonEnum>();
    }
    case 153: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonF32>();
    }
    case 154: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonF64>();
    }
    case 155: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonI16Dec>();
    }
    case 156: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonI16Hex>();
    }
    case 157: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonI32Dec>();
    }
    case 158: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonI32Hex>();
    }
    case 159: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonI64Dec>();
    }
    case 160: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonI64Hex>();
    }
    case 161: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonI8Dec>();
    }
    case 162: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonI8Hex>();
    }
    case 163: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonNull>();
    }
    case 164: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonSequence>();
    }
    case 165: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonString>();
    }
    case 166: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonU16Dec>();
    }
    case 167: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonU16Hex>();
    }
    case 168: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonU32Dec>();
    }
    case 169: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonU32Hex>();
    }
    case 170: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonU32Oct>();
    }
    case 171: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonU64Dec>();
    }
    case 172: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonU64Hex>();
    }
    case 173: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonU8Dec>();
    }
    case 174: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonU8Hex>();
    }
    case 175: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodOptionneurSinonZero>();
    }
    case 176: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnConstructorOptionneurNew>();
    }
    case 177: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodRetourneurIdentiqueBoolean>();
    }
    case 178: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodRetourneurIdentiqueDouble>();
    }
    case 179: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodRetourneurIdentiqueFloat>();
    }
    case 180: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodRetourneurIdentiqueI16>();
    }
    case 181: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodRetourneurIdentiqueI32>();
    }
    case 182: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodRetourneurIdentiqueI64>();
    }
    case 183: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodRetourneurIdentiqueI8>();
    }
    case 184: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodRetourneurIdentiqueNombres>();
    }
    case 185: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodRetourneurIdentiqueNombresSignes>();
    }
    case 186: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodRetourneurIdentiqueOptionneurDictionnaire>();
    }
    case 187: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodRetourneurIdentiqueString>();
    }
    case 188: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodRetourneurIdentiqueU16>();
    }
    case 189: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodRetourneurIdentiqueU32>();
    }
    case 190: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodRetourneurIdentiqueU64>();
    }
    case 191: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodRetourneurIdentiqueU8>();
    }
    case 192: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnConstructorRetourneurNew>();
    }
    case 193: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodStringifierToStringBoolean>();
    }
    case 194: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodStringifierToStringDouble>();
    }
    case 195: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodStringifierToStringFloat>();
    }
    case 196: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodStringifierToStringI16>();
    }
    case 197: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodStringifierToStringI32>();
    }
    case 198: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodStringifierToStringI64>();
    }
    case 199: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodStringifierToStringI8>();
    }
    case 200: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodStringifierToStringU16>();
    }
    case 201: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodStringifierToStringU32>();
    }
    case 202: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodStringifierToStringU64>();
    }
    case 203: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodStringifierToStringU8>();
    }
    case 204: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnMethodStringifierWellKnownString>();
    }
    case 205: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiRondpointFnConstructorStringifierNew>();
    }
    case 206: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiSpritesFnFuncTranslate>();
    }
    case 207: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiSpritesFnMethodSpriteGetPosition>();
    }
    case 208: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiSpritesFnMethodSpriteMoveBy>();
    }
    case 209: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiSpritesFnMethodSpriteMoveTo>();
    }
    case 210: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiSpritesFnConstructorSpriteNew>();
    }
    case 211: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiSpritesFnConstructorSpriteNewRelativeTo>();
    }
    case 212: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiTodolistFnFuncCreateEntryWith>();
    }
    case 213: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiTodolistFnFuncGetDefaultList>();
    }
    case 214: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiTodolistFnFuncSetDefaultList>();
    }
    case 215: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiTodolistFnMethodTodolistAddEntries>();
    }
    case 216: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiTodolistFnMethodTodolistAddEntry>();
    }
    case 217: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiTodolistFnMethodTodolistAddItem>();
    }
    case 218: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiTodolistFnMethodTodolistAddItems>();
    }
    case 219: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiTodolistFnMethodTodolistClearItem>();
    }
    case 220: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiTodolistFnMethodTodolistGetEntries>();
    }
    case 221: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiTodolistFnMethodTodolistGetFirst>();
    }
    case 222: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiTodolistFnMethodTodolistGetItems>();
    }
    case 223: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiTodolistFnMethodTodolistGetLast>();
    }
    case 224: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiTodolistFnMethodTodolistGetLastEntry>();
    }
    case 225: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiTodolistFnMethodTodolistMakeDefault>();
    }
    case 226: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiTodolistFnConstructorTodolistNew>();
    }
    case 227: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiTraitInterfacesFnFuncMakeBuggyCalculator>();
    }
    case 228: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiTraitInterfacesFnFuncMakeCalculator>();
    }
    case 229: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiTraitInterfacesFnMethodCalcAdd>();
    }
#endif /* MOZ_UNIFFI_FIXTURES */

    default:
      return nullptr;
  }
}

UniquePtr<UniffiAsyncCallHandler> GetAsyncCallHandler(uint64_t aId) {
  switch (aId) {


#ifdef MOZ_UNIFFI_FIXTURES
    case 116: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncExpensiveComputation>();
    }
    case 119: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncRoundtripF32>();
    }
    case 120: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncRoundtripF64>();
    }
    case 121: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncRoundtripI16>();
    }
    case 122: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncRoundtripI32>();
    }
    case 123: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncRoundtripI64>();
    }
    case 124: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncRoundtripI8>();
    }
    case 125: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncRoundtripMap>();
    }
    case 126: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncRoundtripObj>();
    }
    case 127: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncRoundtripString>();
    }
    case 128: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncRoundtripU16>();
    }
    case 129: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncRoundtripU32>();
    }
    case 130: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncRoundtripU64>();
    }
    case 131: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncRoundtripU8>();
    }
    case 132: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnFuncRoundtripVec>();
    }
    case 134: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiFixtureFuturesFnMethodFuturetesterMakeFuture>();
    }
#endif /* MOZ_UNIFFI_FIXTURES */

    default:
      return nullptr;
  }
}


Maybe<already_AddRefed<UniFFIPointer>> ReadPointer(const GlobalObject& aGlobal, uint64_t aId, const ArrayBuffer& aArrayBuff, long aPosition, ErrorResult& aError) {
  const UniFFIPointerType* type;
  switch (aId) {

    case 0: {
      type = &kRelevancyRelevancyStorePointerType;
      break;
    }
    case 1: {
      type = &kRemoteSettingsRemoteSettingsPointerType;
      break;
    }
    case 2: {
      type = &kRemoteSettingsRemoteSettingsClientPointerType;
      break;
    }
    case 3: {
      type = &kRemoteSettingsRemoteSettingsServicePointerType;
      break;
    }
    case 4: {
      type = &kSearchSearchEngineSelectorPointerType;
      break;
    }
    case 5: {
      type = &kSuggestSuggestStorePointerType;
      break;
    }
    case 6: {
      type = &kSuggestSuggestStoreBuilderPointerType;
      break;
    }
    case 7: {
      type = &kTabsRemoteCommandStorePointerType;
      break;
    }
    case 8: {
      type = &kTabsTabsBridgedEnginePointerType;
      break;
    }
    case 9: {
      type = &kTabsTabsStorePointerType;
      break;
    }
    case 10: {
      type = &kWebextstorageWebExtStorageBridgedEnginePointerType;
      break;
    }
    case 11: {
      type = &kWebextstorageWebExtStorageStorePointerType;
      break;
    }

#ifdef MOZ_UNIFFI_FIXTURES
    case 12: {
      type = &kFuturesFutureTesterPointerType;
      break;
    }
    case 13: {
      type = &kFuturesRustTaskPointerType;
      break;
    }
    case 14: {
      type = &kFuturesTravellerPointerType;
      break;
    }
    case 15: {
      type = &kFuturesWorkerQueuePointerType;
      break;
    }
    case 16: {
      type = &kRefcountsSingletonObjectPointerType;
      break;
    }
    case 17: {
      type = &kRondpointOptionneurPointerType;
      break;
    }
    case 18: {
      type = &kRondpointRetourneurPointerType;
      break;
    }
    case 19: {
      type = &kRondpointStringifierPointerType;
      break;
    }
    case 20: {
      type = &kSpritesSpritePointerType;
      break;
    }
    case 21: {
      type = &kTodolistTodoListPointerType;
      break;
    }
    case 22: {
      type = &kUniffiTraitInterfacesCalcPointerType;
      break;
    }
#endif /* MOZ_UNIFFI_FIXTURES */
    default:
      return Nothing();
  }
  return Some(UniFFIPointer::Read(aArrayBuff, aPosition, type, aError));
}

bool WritePointer(const GlobalObject& aGlobal, uint64_t aId, const UniFFIPointer& aPtr, const ArrayBuffer& aArrayBuff, long aPosition, ErrorResult& aError) {
  const UniFFIPointerType* type;
  switch (aId) {

    case 0: {
      type = &kRelevancyRelevancyStorePointerType;
      break;
    }
    case 1: {
      type = &kRemoteSettingsRemoteSettingsPointerType;
      break;
    }
    case 2: {
      type = &kRemoteSettingsRemoteSettingsClientPointerType;
      break;
    }
    case 3: {
      type = &kRemoteSettingsRemoteSettingsServicePointerType;
      break;
    }
    case 4: {
      type = &kSearchSearchEngineSelectorPointerType;
      break;
    }
    case 5: {
      type = &kSuggestSuggestStorePointerType;
      break;
    }
    case 6: {
      type = &kSuggestSuggestStoreBuilderPointerType;
      break;
    }
    case 7: {
      type = &kTabsRemoteCommandStorePointerType;
      break;
    }
    case 8: {
      type = &kTabsTabsBridgedEnginePointerType;
      break;
    }
    case 9: {
      type = &kTabsTabsStorePointerType;
      break;
    }
    case 10: {
      type = &kWebextstorageWebExtStorageBridgedEnginePointerType;
      break;
    }
    case 11: {
      type = &kWebextstorageWebExtStorageStorePointerType;
      break;
    }

#ifdef MOZ_UNIFFI_FIXTURES
    case 12: {
      type = &kFuturesFutureTesterPointerType;
      break;
    }
    case 13: {
      type = &kFuturesRustTaskPointerType;
      break;
    }
    case 14: {
      type = &kFuturesTravellerPointerType;
      break;
    }
    case 15: {
      type = &kFuturesWorkerQueuePointerType;
      break;
    }
    case 16: {
      type = &kRefcountsSingletonObjectPointerType;
      break;
    }
    case 17: {
      type = &kRondpointOptionneurPointerType;
      break;
    }
    case 18: {
      type = &kRondpointRetourneurPointerType;
      break;
    }
    case 19: {
      type = &kRondpointStringifierPointerType;
      break;
    }
    case 20: {
      type = &kSpritesSpritePointerType;
      break;
    }
    case 21: {
      type = &kTodolistTodoListPointerType;
      break;
    }
    case 22: {
      type = &kUniffiTraitInterfacesCalcPointerType;
      break;
    }
#endif /* MOZ_UNIFFI_FIXTURES */
    default:
      return false;
  }
  aPtr.Write(aArrayBuff, aPosition, type, aError);
  return true;
}

}  // namespace mozilla::uniffi
