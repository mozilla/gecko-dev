/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set ts=8 sts=2 et sw=2 tw=80: */

// Generated by uniffi-bindgen-gecko-js.  DO NOT EDIT.

#include "nsString.h"
#include "nsPrintfCString.h"
#include "mozilla/Logging.h"
#include "mozilla/Maybe.h"
#include "mozilla/StaticPtr.h"
#include "mozilla/UniquePtr.h"
#include "mozilla/dom/Promise.h"
#include "mozilla/dom/UniFFIScaffolding.h"
#include "mozilla/uniffi/Call.h"
#include "mozilla/uniffi/Callbacks.h"
#include "mozilla/uniffi/FfiValue.h"
#include "mozilla/uniffi/PointerType.h"
#include "mozilla/uniffi/Rust.h"

namespace mozilla::uniffi {

using dom::ArrayBuffer;
using dom::AutoEntryScript;
using dom::GlobalObject;
using dom::RootedDictionary;
using dom::NullableRootedUnion;
using dom::Promise;
using dom::Sequence;
using dom::UniFFICallbackHandler;
using dom::UniFFIPointer;
using dom::UniFFIScaffoldingCallResult;


/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

extern "C" {

  RustBuffer ffi_context_id_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_context_id_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_context_id_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_context_id_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  typedef void (*RustFutureContinuationCallback)(uint64_t, int8_t);
  typedef void (*ForeignFutureFree)(uint64_t);
  struct ForeignFuture {
    uint64_t handle;
    ForeignFutureFree free;
  };
  void ffi_context_id_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_context_id_rust_future_cancel_u8(uint64_t);
  uint8_t ffi_context_id_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_context_id_rust_future_free_u8(uint64_t);
  void ffi_context_id_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_context_id_rust_future_cancel_i8(uint64_t);
  int8_t ffi_context_id_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_context_id_rust_future_free_i8(uint64_t);
  void ffi_context_id_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_context_id_rust_future_cancel_u16(uint64_t);
  uint16_t ffi_context_id_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_context_id_rust_future_free_u16(uint64_t);
  void ffi_context_id_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_context_id_rust_future_cancel_i16(uint64_t);
  int16_t ffi_context_id_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_context_id_rust_future_free_i16(uint64_t);
  void ffi_context_id_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_context_id_rust_future_cancel_u32(uint64_t);
  uint32_t ffi_context_id_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_context_id_rust_future_free_u32(uint64_t);
  void ffi_context_id_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_context_id_rust_future_cancel_i32(uint64_t);
  int32_t ffi_context_id_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_context_id_rust_future_free_i32(uint64_t);
  void ffi_context_id_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_context_id_rust_future_cancel_u64(uint64_t);
  uint64_t ffi_context_id_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_context_id_rust_future_free_u64(uint64_t);
  void ffi_context_id_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_context_id_rust_future_cancel_i64(uint64_t);
  int64_t ffi_context_id_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_context_id_rust_future_free_i64(uint64_t);
  void ffi_context_id_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_context_id_rust_future_cancel_f32(uint64_t);
  float ffi_context_id_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_context_id_rust_future_free_f32(uint64_t);
  void ffi_context_id_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_context_id_rust_future_cancel_f64(uint64_t);
  double ffi_context_id_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_context_id_rust_future_free_f64(uint64_t);
  void ffi_context_id_rust_future_poll_pointer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_context_id_rust_future_cancel_pointer(uint64_t);
  void* ffi_context_id_rust_future_complete_pointer(uint64_t, RustCallStatus*);
  void ffi_context_id_rust_future_free_pointer(uint64_t);
  void ffi_context_id_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_context_id_rust_future_cancel_rust_buffer(uint64_t);
  RustBuffer ffi_context_id_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_context_id_rust_future_free_rust_buffer(uint64_t);
  void ffi_context_id_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_context_id_rust_future_cancel_void(uint64_t);
  void ffi_context_id_rust_future_complete_void(uint64_t, RustCallStatus*);
  void ffi_context_id_rust_future_free_void(uint64_t);
  void* uniffi_context_id_fn_clone_contextidcomponent(void*, RustCallStatus*);
  void uniffi_context_id_fn_free_contextidcomponent(void*, RustCallStatus*);
  typedef void (*CallbackInterfaceContextIdCallbackMethod0)(uint64_t, RustBuffer, int64_t, void*, RustCallStatus*);
  typedef void (*CallbackInterfaceContextIdCallbackMethod1)(uint64_t, RustBuffer, void*, RustCallStatus*);
  typedef void (*CallbackInterfaceFreecontext_id_ContextIdCallback)(uint64_t);
  struct VTableCallbackInterfaceContextIdCallback {
    CallbackInterfaceContextIdCallbackMethod0 persist;
    CallbackInterfaceContextIdCallbackMethod1 rotated;
    CallbackInterfaceFreecontext_id_ContextIdCallback uniffi_free;
  };
  void uniffi_context_id_fn_init_callback_vtable_contextidcallback(VTableCallbackInterfaceContextIdCallback*);
  void* uniffi_context_id_fn_constructor_contextidcomponent_new(RustBuffer, int64_t, int8_t, uint64_t, RustCallStatus*);
  void uniffi_context_id_fn_method_contextidcomponent_force_rotation(void*, RustCallStatus*);
  RustBuffer uniffi_context_id_fn_method_contextidcomponent_request(void*, uint8_t, RustCallStatus*);
  void uniffi_context_id_fn_method_contextidcomponent_unset_callback(void*, RustCallStatus*);
  uint32_t ffi_context_id_uniffi_contract_version();
  uint16_t uniffi_context_id_checksum_constructor_contextidcomponent_new();
  uint16_t uniffi_context_id_checksum_method_contextidcomponent_force_rotation();
  uint16_t uniffi_context_id_checksum_method_contextidcomponent_request();
  uint16_t uniffi_context_id_checksum_method_contextidcomponent_unset_callback();
  uint16_t uniffi_context_id_checksum_method_contextidcallback_persist();
  uint16_t uniffi_context_id_checksum_method_contextidcallback_rotated();
  RustBuffer ffi_error_support_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_error_support_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_error_support_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_error_support_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_u8(uint64_t);
  uint8_t ffi_error_support_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_free_u8(uint64_t);
  void ffi_error_support_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_i8(uint64_t);
  int8_t ffi_error_support_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_free_i8(uint64_t);
  void ffi_error_support_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_u16(uint64_t);
  uint16_t ffi_error_support_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_free_u16(uint64_t);
  void ffi_error_support_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_i16(uint64_t);
  int16_t ffi_error_support_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_free_i16(uint64_t);
  void ffi_error_support_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_u32(uint64_t);
  uint32_t ffi_error_support_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_free_u32(uint64_t);
  void ffi_error_support_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_i32(uint64_t);
  int32_t ffi_error_support_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_free_i32(uint64_t);
  void ffi_error_support_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_u64(uint64_t);
  uint64_t ffi_error_support_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_free_u64(uint64_t);
  void ffi_error_support_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_i64(uint64_t);
  int64_t ffi_error_support_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_free_i64(uint64_t);
  void ffi_error_support_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_f32(uint64_t);
  float ffi_error_support_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_free_f32(uint64_t);
  void ffi_error_support_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_f64(uint64_t);
  double ffi_error_support_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_free_f64(uint64_t);
  void ffi_error_support_rust_future_poll_pointer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_pointer(uint64_t);
  void* ffi_error_support_rust_future_complete_pointer(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_free_pointer(uint64_t);
  void ffi_error_support_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_rust_buffer(uint64_t);
  RustBuffer ffi_error_support_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_free_rust_buffer(uint64_t);
  void ffi_error_support_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_error_support_rust_future_cancel_void(uint64_t);
  void ffi_error_support_rust_future_complete_void(uint64_t, RustCallStatus*);
  void ffi_error_support_rust_future_free_void(uint64_t);
  typedef void (*CallbackInterfaceApplicationErrorReporterMethod0)(uint64_t, RustBuffer, RustBuffer, void*, RustCallStatus*);
  typedef void (*CallbackInterfaceApplicationErrorReporterMethod1)(uint64_t, RustBuffer, RustBuffer, uint32_t, uint32_t, void*, RustCallStatus*);
  typedef void (*CallbackInterfaceFreeerrorsupport_ApplicationErrorReporter)(uint64_t);
  struct VTableCallbackInterfaceApplicationErrorReporter {
    CallbackInterfaceApplicationErrorReporterMethod0 report_error;
    CallbackInterfaceApplicationErrorReporterMethod1 report_breadcrumb;
    CallbackInterfaceFreeerrorsupport_ApplicationErrorReporter uniffi_free;
  };
  void uniffi_error_support_fn_init_callback_vtable_applicationerrorreporter(VTableCallbackInterfaceApplicationErrorReporter*);
  void uniffi_error_support_fn_func_set_application_error_reporter(uint64_t, RustCallStatus*);
  void uniffi_error_support_fn_func_unset_application_error_reporter(RustCallStatus*);
  uint32_t ffi_error_support_uniffi_contract_version();
  uint16_t uniffi_error_support_checksum_func_set_application_error_reporter();
  uint16_t uniffi_error_support_checksum_func_unset_application_error_reporter();
  uint16_t uniffi_error_support_checksum_method_applicationerrorreporter_report_error();
  uint16_t uniffi_error_support_checksum_method_applicationerrorreporter_report_breadcrumb();
  RustBuffer ffi_relevancy_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_relevancy_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_relevancy_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_relevancy_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_u8(uint64_t);
  uint8_t ffi_relevancy_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_free_u8(uint64_t);
  void ffi_relevancy_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_i8(uint64_t);
  int8_t ffi_relevancy_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_free_i8(uint64_t);
  void ffi_relevancy_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_u16(uint64_t);
  uint16_t ffi_relevancy_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_free_u16(uint64_t);
  void ffi_relevancy_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_i16(uint64_t);
  int16_t ffi_relevancy_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_free_i16(uint64_t);
  void ffi_relevancy_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_u32(uint64_t);
  uint32_t ffi_relevancy_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_free_u32(uint64_t);
  void ffi_relevancy_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_i32(uint64_t);
  int32_t ffi_relevancy_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_free_i32(uint64_t);
  void ffi_relevancy_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_u64(uint64_t);
  uint64_t ffi_relevancy_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_free_u64(uint64_t);
  void ffi_relevancy_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_i64(uint64_t);
  int64_t ffi_relevancy_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_free_i64(uint64_t);
  void ffi_relevancy_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_f32(uint64_t);
  float ffi_relevancy_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_free_f32(uint64_t);
  void ffi_relevancy_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_f64(uint64_t);
  double ffi_relevancy_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_free_f64(uint64_t);
  void ffi_relevancy_rust_future_poll_pointer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_pointer(uint64_t);
  void* ffi_relevancy_rust_future_complete_pointer(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_free_pointer(uint64_t);
  void ffi_relevancy_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_rust_buffer(uint64_t);
  RustBuffer ffi_relevancy_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_free_rust_buffer(uint64_t);
  void ffi_relevancy_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_relevancy_rust_future_cancel_void(uint64_t);
  void ffi_relevancy_rust_future_complete_void(uint64_t, RustCallStatus*);
  void ffi_relevancy_rust_future_free_void(uint64_t);
  void* uniffi_relevancy_fn_clone_relevancystore(void*, RustCallStatus*);
  void uniffi_relevancy_fn_free_relevancystore(void*, RustCallStatus*);
  double uniffi_relevancy_fn_func_score(RustBuffer, RustBuffer, RustCallStatus*);
  void* uniffi_relevancy_fn_constructor_relevancystore_new(RustBuffer, void*, RustCallStatus*);
  void uniffi_relevancy_fn_method_relevancystore_bandit_init(void*, RustBuffer, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_relevancy_fn_method_relevancystore_bandit_select(void*, RustBuffer, RustBuffer, RustCallStatus*);
  void uniffi_relevancy_fn_method_relevancystore_bandit_update(void*, RustBuffer, RustBuffer, int8_t, RustCallStatus*);
  void uniffi_relevancy_fn_method_relevancystore_close(void*, RustCallStatus*);
  void uniffi_relevancy_fn_method_relevancystore_ensure_interest_data_populated(void*, RustCallStatus*);
  RustBuffer uniffi_relevancy_fn_method_relevancystore_get_bandit_data(void*, RustBuffer, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_relevancy_fn_method_relevancystore_ingest(void*, RustBuffer, RustCallStatus*);
  void uniffi_relevancy_fn_method_relevancystore_interrupt(void*, RustCallStatus*);
  RustBuffer uniffi_relevancy_fn_method_relevancystore_user_interest_vector(void*, RustCallStatus*);
  uint32_t ffi_relevancy_uniffi_contract_version();
  uint16_t uniffi_relevancy_checksum_func_score();
  uint16_t uniffi_relevancy_checksum_constructor_relevancystore_new();
  uint16_t uniffi_relevancy_checksum_method_relevancystore_bandit_init();
  uint16_t uniffi_relevancy_checksum_method_relevancystore_bandit_select();
  uint16_t uniffi_relevancy_checksum_method_relevancystore_bandit_update();
  uint16_t uniffi_relevancy_checksum_method_relevancystore_close();
  uint16_t uniffi_relevancy_checksum_method_relevancystore_ensure_interest_data_populated();
  uint16_t uniffi_relevancy_checksum_method_relevancystore_get_bandit_data();
  uint16_t uniffi_relevancy_checksum_method_relevancystore_ingest();
  uint16_t uniffi_relevancy_checksum_method_relevancystore_interrupt();
  uint16_t uniffi_relevancy_checksum_method_relevancystore_user_interest_vector();
  RustBuffer ffi_remote_settings_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_remote_settings_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_remote_settings_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_remote_settings_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_u8(uint64_t);
  uint8_t ffi_remote_settings_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_free_u8(uint64_t);
  void ffi_remote_settings_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_i8(uint64_t);
  int8_t ffi_remote_settings_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_free_i8(uint64_t);
  void ffi_remote_settings_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_u16(uint64_t);
  uint16_t ffi_remote_settings_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_free_u16(uint64_t);
  void ffi_remote_settings_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_i16(uint64_t);
  int16_t ffi_remote_settings_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_free_i16(uint64_t);
  void ffi_remote_settings_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_u32(uint64_t);
  uint32_t ffi_remote_settings_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_free_u32(uint64_t);
  void ffi_remote_settings_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_i32(uint64_t);
  int32_t ffi_remote_settings_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_free_i32(uint64_t);
  void ffi_remote_settings_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_u64(uint64_t);
  uint64_t ffi_remote_settings_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_free_u64(uint64_t);
  void ffi_remote_settings_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_i64(uint64_t);
  int64_t ffi_remote_settings_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_free_i64(uint64_t);
  void ffi_remote_settings_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_f32(uint64_t);
  float ffi_remote_settings_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_free_f32(uint64_t);
  void ffi_remote_settings_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_f64(uint64_t);
  double ffi_remote_settings_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_free_f64(uint64_t);
  void ffi_remote_settings_rust_future_poll_pointer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_pointer(uint64_t);
  void* ffi_remote_settings_rust_future_complete_pointer(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_free_pointer(uint64_t);
  void ffi_remote_settings_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_rust_buffer(uint64_t);
  RustBuffer ffi_remote_settings_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_free_rust_buffer(uint64_t);
  void ffi_remote_settings_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_remote_settings_rust_future_cancel_void(uint64_t);
  void ffi_remote_settings_rust_future_complete_void(uint64_t, RustCallStatus*);
  void ffi_remote_settings_rust_future_free_void(uint64_t);
  void* uniffi_remote_settings_fn_clone_remotesettings(void*, RustCallStatus*);
  void uniffi_remote_settings_fn_free_remotesettings(void*, RustCallStatus*);
  void* uniffi_remote_settings_fn_clone_remotesettingsclient(void*, RustCallStatus*);
  void uniffi_remote_settings_fn_free_remotesettingsclient(void*, RustCallStatus*);
  void* uniffi_remote_settings_fn_clone_remotesettingsservice(void*, RustCallStatus*);
  void uniffi_remote_settings_fn_free_remotesettingsservice(void*, RustCallStatus*);
  void* uniffi_remote_settings_fn_constructor_remotesettings_new(RustBuffer, RustCallStatus*);
  void uniffi_remote_settings_fn_method_remotesettings_download_attachment_to_path(void*, RustBuffer, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_remote_settings_fn_method_remotesettings_get_records(void*, RustCallStatus*);
  RustBuffer uniffi_remote_settings_fn_method_remotesettings_get_records_since(void*, uint64_t, RustCallStatus*);
  RustBuffer uniffi_remote_settings_fn_method_remotesettingsclient_collection_name(void*, RustCallStatus*);
  RustBuffer uniffi_remote_settings_fn_method_remotesettingsclient_get_attachment(void*, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_remote_settings_fn_method_remotesettingsclient_get_records(void*, int8_t, RustCallStatus*);
  RustBuffer uniffi_remote_settings_fn_method_remotesettingsclient_get_records_map(void*, int8_t, RustCallStatus*);
  void uniffi_remote_settings_fn_method_remotesettingsclient_shutdown(void*, RustCallStatus*);
  void uniffi_remote_settings_fn_method_remotesettingsclient_sync(void*, RustCallStatus*);
  void* uniffi_remote_settings_fn_constructor_remotesettingsservice_new(RustBuffer, RustBuffer, RustCallStatus*);
  void* uniffi_remote_settings_fn_method_remotesettingsservice_make_client(void*, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_remote_settings_fn_method_remotesettingsservice_sync(void*, RustCallStatus*);
  void uniffi_remote_settings_fn_method_remotesettingsservice_update_config(void*, RustBuffer, RustCallStatus*);
  uint32_t ffi_remote_settings_uniffi_contract_version();
  uint16_t uniffi_remote_settings_checksum_constructor_remotesettings_new();
  uint16_t uniffi_remote_settings_checksum_method_remotesettings_download_attachment_to_path();
  uint16_t uniffi_remote_settings_checksum_method_remotesettings_get_records();
  uint16_t uniffi_remote_settings_checksum_method_remotesettings_get_records_since();
  uint16_t uniffi_remote_settings_checksum_method_remotesettingsclient_collection_name();
  uint16_t uniffi_remote_settings_checksum_method_remotesettingsclient_get_attachment();
  uint16_t uniffi_remote_settings_checksum_method_remotesettingsclient_get_records();
  uint16_t uniffi_remote_settings_checksum_method_remotesettingsclient_get_records_map();
  uint16_t uniffi_remote_settings_checksum_method_remotesettingsclient_shutdown();
  uint16_t uniffi_remote_settings_checksum_method_remotesettingsclient_sync();
  uint16_t uniffi_remote_settings_checksum_constructor_remotesettingsservice_new();
  uint16_t uniffi_remote_settings_checksum_method_remotesettingsservice_make_client();
  uint16_t uniffi_remote_settings_checksum_method_remotesettingsservice_sync();
  uint16_t uniffi_remote_settings_checksum_method_remotesettingsservice_update_config();
  RustBuffer ffi_search_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_search_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_search_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_search_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_search_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_u8(uint64_t);
  uint8_t ffi_search_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_free_u8(uint64_t);
  void ffi_search_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_i8(uint64_t);
  int8_t ffi_search_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_free_i8(uint64_t);
  void ffi_search_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_u16(uint64_t);
  uint16_t ffi_search_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_free_u16(uint64_t);
  void ffi_search_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_i16(uint64_t);
  int16_t ffi_search_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_free_i16(uint64_t);
  void ffi_search_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_u32(uint64_t);
  uint32_t ffi_search_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_free_u32(uint64_t);
  void ffi_search_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_i32(uint64_t);
  int32_t ffi_search_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_free_i32(uint64_t);
  void ffi_search_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_u64(uint64_t);
  uint64_t ffi_search_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_free_u64(uint64_t);
  void ffi_search_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_i64(uint64_t);
  int64_t ffi_search_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_free_i64(uint64_t);
  void ffi_search_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_f32(uint64_t);
  float ffi_search_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_free_f32(uint64_t);
  void ffi_search_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_f64(uint64_t);
  double ffi_search_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_free_f64(uint64_t);
  void ffi_search_rust_future_poll_pointer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_pointer(uint64_t);
  void* ffi_search_rust_future_complete_pointer(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_free_pointer(uint64_t);
  void ffi_search_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_rust_buffer(uint64_t);
  RustBuffer ffi_search_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_free_rust_buffer(uint64_t);
  void ffi_search_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_search_rust_future_cancel_void(uint64_t);
  void ffi_search_rust_future_complete_void(uint64_t, RustCallStatus*);
  void ffi_search_rust_future_free_void(uint64_t);
  void* uniffi_search_fn_clone_searchengineselector(void*, RustCallStatus*);
  void uniffi_search_fn_free_searchengineselector(void*, RustCallStatus*);
  void* uniffi_search_fn_constructor_searchengineselector_new(RustCallStatus*);
  void uniffi_search_fn_method_searchengineselector_clear_search_config(void*, RustCallStatus*);
  RustBuffer uniffi_search_fn_method_searchengineselector_filter_engine_configuration(void*, RustBuffer, RustCallStatus*);
  void uniffi_search_fn_method_searchengineselector_set_config_overrides(void*, RustBuffer, RustCallStatus*);
  void uniffi_search_fn_method_searchengineselector_set_search_config(void*, RustBuffer, RustCallStatus*);
  void uniffi_search_fn_method_searchengineselector_use_remote_settings_server(void*, void*, int8_t, RustCallStatus*);
  uint32_t ffi_search_uniffi_contract_version();
  uint16_t uniffi_search_checksum_constructor_searchengineselector_new();
  uint16_t uniffi_search_checksum_method_searchengineselector_clear_search_config();
  uint16_t uniffi_search_checksum_method_searchengineselector_filter_engine_configuration();
  uint16_t uniffi_search_checksum_method_searchengineselector_set_config_overrides();
  uint16_t uniffi_search_checksum_method_searchengineselector_set_search_config();
  uint16_t uniffi_search_checksum_method_searchengineselector_use_remote_settings_server();
  RustBuffer ffi_suggest_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_suggest_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_suggest_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_suggest_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_u8(uint64_t);
  uint8_t ffi_suggest_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_free_u8(uint64_t);
  void ffi_suggest_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_i8(uint64_t);
  int8_t ffi_suggest_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_free_i8(uint64_t);
  void ffi_suggest_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_u16(uint64_t);
  uint16_t ffi_suggest_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_free_u16(uint64_t);
  void ffi_suggest_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_i16(uint64_t);
  int16_t ffi_suggest_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_free_i16(uint64_t);
  void ffi_suggest_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_u32(uint64_t);
  uint32_t ffi_suggest_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_free_u32(uint64_t);
  void ffi_suggest_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_i32(uint64_t);
  int32_t ffi_suggest_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_free_i32(uint64_t);
  void ffi_suggest_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_u64(uint64_t);
  uint64_t ffi_suggest_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_free_u64(uint64_t);
  void ffi_suggest_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_i64(uint64_t);
  int64_t ffi_suggest_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_free_i64(uint64_t);
  void ffi_suggest_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_f32(uint64_t);
  float ffi_suggest_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_free_f32(uint64_t);
  void ffi_suggest_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_f64(uint64_t);
  double ffi_suggest_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_free_f64(uint64_t);
  void ffi_suggest_rust_future_poll_pointer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_pointer(uint64_t);
  void* ffi_suggest_rust_future_complete_pointer(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_free_pointer(uint64_t);
  void ffi_suggest_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_rust_buffer(uint64_t);
  RustBuffer ffi_suggest_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_free_rust_buffer(uint64_t);
  void ffi_suggest_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_suggest_rust_future_cancel_void(uint64_t);
  void ffi_suggest_rust_future_complete_void(uint64_t, RustCallStatus*);
  void ffi_suggest_rust_future_free_void(uint64_t);
  void* uniffi_suggest_fn_clone_suggeststore(void*, RustCallStatus*);
  void uniffi_suggest_fn_free_suggeststore(void*, RustCallStatus*);
  void* uniffi_suggest_fn_clone_suggeststorebuilder(void*, RustCallStatus*);
  void uniffi_suggest_fn_free_suggeststorebuilder(void*, RustCallStatus*);
  int8_t uniffi_suggest_fn_func_raw_suggestion_url_matches(RustBuffer, RustBuffer, RustCallStatus*);
  void* uniffi_suggest_fn_constructor_suggeststore_new(RustBuffer, void*, RustCallStatus*);
  int8_t uniffi_suggest_fn_method_suggeststore_any_dismissed_suggestions(void*, RustCallStatus*);
  void uniffi_suggest_fn_method_suggeststore_clear(void*, RustCallStatus*);
  void uniffi_suggest_fn_method_suggeststore_clear_dismissed_suggestions(void*, RustCallStatus*);
  void uniffi_suggest_fn_method_suggeststore_dismiss_by_key(void*, RustBuffer, RustCallStatus*);
  void uniffi_suggest_fn_method_suggeststore_dismiss_by_suggestion(void*, RustBuffer, RustCallStatus*);
  void uniffi_suggest_fn_method_suggeststore_dismiss_suggestion(void*, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_suggest_fn_method_suggeststore_fetch_geoname_alternates(void*, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_suggest_fn_method_suggeststore_fetch_geonames(void*, RustBuffer, int8_t, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_suggest_fn_method_suggeststore_fetch_global_config(void*, RustCallStatus*);
  RustBuffer uniffi_suggest_fn_method_suggeststore_fetch_provider_config(void*, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_suggest_fn_method_suggeststore_ingest(void*, RustBuffer, RustCallStatus*);
  void uniffi_suggest_fn_method_suggeststore_interrupt(void*, RustBuffer, RustCallStatus*);
  int8_t uniffi_suggest_fn_method_suggeststore_is_dismissed_by_key(void*, RustBuffer, RustCallStatus*);
  int8_t uniffi_suggest_fn_method_suggeststore_is_dismissed_by_suggestion(void*, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_suggest_fn_method_suggeststore_query(void*, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_suggest_fn_method_suggeststore_query_with_metrics(void*, RustBuffer, RustCallStatus*);
  void* uniffi_suggest_fn_constructor_suggeststorebuilder_new(RustCallStatus*);
  void* uniffi_suggest_fn_method_suggeststorebuilder_build(void*, RustCallStatus*);
  void* uniffi_suggest_fn_method_suggeststorebuilder_cache_path(void*, RustBuffer, RustCallStatus*);
  void* uniffi_suggest_fn_method_suggeststorebuilder_data_path(void*, RustBuffer, RustCallStatus*);
  void* uniffi_suggest_fn_method_suggeststorebuilder_load_extension(void*, RustBuffer, RustBuffer, RustCallStatus*);
  void* uniffi_suggest_fn_method_suggeststorebuilder_remote_settings_bucket_name(void*, RustBuffer, RustCallStatus*);
  void* uniffi_suggest_fn_method_suggeststorebuilder_remote_settings_server(void*, RustBuffer, RustCallStatus*);
  void* uniffi_suggest_fn_method_suggeststorebuilder_remote_settings_service(void*, void*, RustCallStatus*);
  uint32_t ffi_suggest_uniffi_contract_version();
  uint16_t uniffi_suggest_checksum_func_raw_suggestion_url_matches();
  uint16_t uniffi_suggest_checksum_constructor_suggeststore_new();
  uint16_t uniffi_suggest_checksum_method_suggeststore_any_dismissed_suggestions();
  uint16_t uniffi_suggest_checksum_method_suggeststore_clear();
  uint16_t uniffi_suggest_checksum_method_suggeststore_clear_dismissed_suggestions();
  uint16_t uniffi_suggest_checksum_method_suggeststore_dismiss_by_key();
  uint16_t uniffi_suggest_checksum_method_suggeststore_dismiss_by_suggestion();
  uint16_t uniffi_suggest_checksum_method_suggeststore_dismiss_suggestion();
  uint16_t uniffi_suggest_checksum_method_suggeststore_fetch_geoname_alternates();
  uint16_t uniffi_suggest_checksum_method_suggeststore_fetch_geonames();
  uint16_t uniffi_suggest_checksum_method_suggeststore_fetch_global_config();
  uint16_t uniffi_suggest_checksum_method_suggeststore_fetch_provider_config();
  uint16_t uniffi_suggest_checksum_method_suggeststore_ingest();
  uint16_t uniffi_suggest_checksum_method_suggeststore_interrupt();
  uint16_t uniffi_suggest_checksum_method_suggeststore_is_dismissed_by_key();
  uint16_t uniffi_suggest_checksum_method_suggeststore_is_dismissed_by_suggestion();
  uint16_t uniffi_suggest_checksum_method_suggeststore_query();
  uint16_t uniffi_suggest_checksum_method_suggeststore_query_with_metrics();
  uint16_t uniffi_suggest_checksum_constructor_suggeststorebuilder_new();
  uint16_t uniffi_suggest_checksum_method_suggeststorebuilder_build();
  uint16_t uniffi_suggest_checksum_method_suggeststorebuilder_cache_path();
  uint16_t uniffi_suggest_checksum_method_suggeststorebuilder_data_path();
  uint16_t uniffi_suggest_checksum_method_suggeststorebuilder_load_extension();
  uint16_t uniffi_suggest_checksum_method_suggeststorebuilder_remote_settings_bucket_name();
  uint16_t uniffi_suggest_checksum_method_suggeststorebuilder_remote_settings_server();
  uint16_t uniffi_suggest_checksum_method_suggeststorebuilder_remote_settings_service();
  RustBuffer ffi_sync15_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_sync15_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_sync15_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_sync15_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_u8(uint64_t);
  uint8_t ffi_sync15_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_free_u8(uint64_t);
  void ffi_sync15_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_i8(uint64_t);
  int8_t ffi_sync15_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_free_i8(uint64_t);
  void ffi_sync15_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_u16(uint64_t);
  uint16_t ffi_sync15_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_free_u16(uint64_t);
  void ffi_sync15_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_i16(uint64_t);
  int16_t ffi_sync15_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_free_i16(uint64_t);
  void ffi_sync15_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_u32(uint64_t);
  uint32_t ffi_sync15_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_free_u32(uint64_t);
  void ffi_sync15_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_i32(uint64_t);
  int32_t ffi_sync15_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_free_i32(uint64_t);
  void ffi_sync15_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_u64(uint64_t);
  uint64_t ffi_sync15_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_free_u64(uint64_t);
  void ffi_sync15_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_i64(uint64_t);
  int64_t ffi_sync15_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_free_i64(uint64_t);
  void ffi_sync15_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_f32(uint64_t);
  float ffi_sync15_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_free_f32(uint64_t);
  void ffi_sync15_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_f64(uint64_t);
  double ffi_sync15_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_free_f64(uint64_t);
  void ffi_sync15_rust_future_poll_pointer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_pointer(uint64_t);
  void* ffi_sync15_rust_future_complete_pointer(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_free_pointer(uint64_t);
  void ffi_sync15_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_rust_buffer(uint64_t);
  RustBuffer ffi_sync15_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_free_rust_buffer(uint64_t);
  void ffi_sync15_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_sync15_rust_future_cancel_void(uint64_t);
  void ffi_sync15_rust_future_complete_void(uint64_t, RustCallStatus*);
  void ffi_sync15_rust_future_free_void(uint64_t);
  uint32_t ffi_sync15_uniffi_contract_version();
  RustBuffer ffi_tabs_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_tabs_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_tabs_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_tabs_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_u8(uint64_t);
  uint8_t ffi_tabs_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_free_u8(uint64_t);
  void ffi_tabs_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_i8(uint64_t);
  int8_t ffi_tabs_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_free_i8(uint64_t);
  void ffi_tabs_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_u16(uint64_t);
  uint16_t ffi_tabs_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_free_u16(uint64_t);
  void ffi_tabs_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_i16(uint64_t);
  int16_t ffi_tabs_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_free_i16(uint64_t);
  void ffi_tabs_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_u32(uint64_t);
  uint32_t ffi_tabs_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_free_u32(uint64_t);
  void ffi_tabs_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_i32(uint64_t);
  int32_t ffi_tabs_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_free_i32(uint64_t);
  void ffi_tabs_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_u64(uint64_t);
  uint64_t ffi_tabs_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_free_u64(uint64_t);
  void ffi_tabs_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_i64(uint64_t);
  int64_t ffi_tabs_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_free_i64(uint64_t);
  void ffi_tabs_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_f32(uint64_t);
  float ffi_tabs_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_free_f32(uint64_t);
  void ffi_tabs_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_f64(uint64_t);
  double ffi_tabs_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_free_f64(uint64_t);
  void ffi_tabs_rust_future_poll_pointer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_pointer(uint64_t);
  void* ffi_tabs_rust_future_complete_pointer(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_free_pointer(uint64_t);
  void ffi_tabs_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_rust_buffer(uint64_t);
  RustBuffer ffi_tabs_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_free_rust_buffer(uint64_t);
  void ffi_tabs_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_tabs_rust_future_cancel_void(uint64_t);
  void ffi_tabs_rust_future_complete_void(uint64_t, RustCallStatus*);
  void ffi_tabs_rust_future_free_void(uint64_t);
  void* uniffi_tabs_fn_clone_remotecommandstore(void*, RustCallStatus*);
  void uniffi_tabs_fn_free_remotecommandstore(void*, RustCallStatus*);
  void* uniffi_tabs_fn_clone_tabsbridgedengine(void*, RustCallStatus*);
  void uniffi_tabs_fn_free_tabsbridgedengine(void*, RustCallStatus*);
  void* uniffi_tabs_fn_clone_tabsstore(void*, RustCallStatus*);
  void uniffi_tabs_fn_free_tabsstore(void*, RustCallStatus*);
  int8_t uniffi_tabs_fn_method_remotecommandstore_add_remote_command(void*, RustBuffer, RustBuffer, RustCallStatus*);
  int8_t uniffi_tabs_fn_method_remotecommandstore_add_remote_command_at(void*, RustBuffer, RustBuffer, int64_t, RustCallStatus*);
  RustBuffer uniffi_tabs_fn_method_remotecommandstore_get_unsent_commands(void*, RustCallStatus*);
  int8_t uniffi_tabs_fn_method_remotecommandstore_remove_remote_command(void*, RustBuffer, RustBuffer, RustCallStatus*);
  int8_t uniffi_tabs_fn_method_remotecommandstore_set_pending_command_sent(void*, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_tabs_fn_method_tabsbridgedengine_apply(void*, RustCallStatus*);
  RustBuffer uniffi_tabs_fn_method_tabsbridgedengine_ensure_current_sync_id(void*, RustBuffer, RustCallStatus*);
  int64_t uniffi_tabs_fn_method_tabsbridgedengine_last_sync(void*, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsbridgedengine_prepare_for_sync(void*, RustBuffer, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsbridgedengine_reset(void*, RustCallStatus*);
  RustBuffer uniffi_tabs_fn_method_tabsbridgedengine_reset_sync_id(void*, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsbridgedengine_set_last_sync(void*, int64_t, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsbridgedengine_set_uploaded(void*, int64_t, RustBuffer, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsbridgedengine_store_incoming(void*, RustBuffer, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsbridgedengine_sync_finished(void*, RustCallStatus*);
  RustBuffer uniffi_tabs_fn_method_tabsbridgedengine_sync_id(void*, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsbridgedengine_sync_started(void*, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsbridgedengine_wipe(void*, RustCallStatus*);
  void* uniffi_tabs_fn_constructor_tabsstore_new(RustBuffer, RustCallStatus*);
  void* uniffi_tabs_fn_method_tabsstore_bridged_engine(void*, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsstore_close_connection(void*, RustCallStatus*);
  RustBuffer uniffi_tabs_fn_method_tabsstore_get_all(void*, RustCallStatus*);
  void* uniffi_tabs_fn_method_tabsstore_new_remote_command_store(void*, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsstore_register_with_sync_manager(void*, RustCallStatus*);
  void uniffi_tabs_fn_method_tabsstore_set_local_tabs(void*, RustBuffer, RustCallStatus*);
  uint32_t ffi_tabs_uniffi_contract_version();
  uint16_t uniffi_tabs_checksum_method_remotecommandstore_add_remote_command();
  uint16_t uniffi_tabs_checksum_method_remotecommandstore_add_remote_command_at();
  uint16_t uniffi_tabs_checksum_method_remotecommandstore_get_unsent_commands();
  uint16_t uniffi_tabs_checksum_method_remotecommandstore_remove_remote_command();
  uint16_t uniffi_tabs_checksum_method_remotecommandstore_set_pending_command_sent();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_apply();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_ensure_current_sync_id();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_last_sync();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_prepare_for_sync();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_reset();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_reset_sync_id();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_set_last_sync();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_set_uploaded();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_store_incoming();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_sync_finished();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_sync_id();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_sync_started();
  uint16_t uniffi_tabs_checksum_method_tabsbridgedengine_wipe();
  uint16_t uniffi_tabs_checksum_constructor_tabsstore_new();
  uint16_t uniffi_tabs_checksum_method_tabsstore_bridged_engine();
  uint16_t uniffi_tabs_checksum_method_tabsstore_close_connection();
  uint16_t uniffi_tabs_checksum_method_tabsstore_get_all();
  uint16_t uniffi_tabs_checksum_method_tabsstore_new_remote_command_store();
  uint16_t uniffi_tabs_checksum_method_tabsstore_register_with_sync_manager();
  uint16_t uniffi_tabs_checksum_method_tabsstore_set_local_tabs();
  RustBuffer ffi_webext_storage_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_webext_storage_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_webext_storage_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_webext_storage_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_u8(uint64_t);
  uint8_t ffi_webext_storage_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_free_u8(uint64_t);
  void ffi_webext_storage_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_i8(uint64_t);
  int8_t ffi_webext_storage_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_free_i8(uint64_t);
  void ffi_webext_storage_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_u16(uint64_t);
  uint16_t ffi_webext_storage_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_free_u16(uint64_t);
  void ffi_webext_storage_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_i16(uint64_t);
  int16_t ffi_webext_storage_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_free_i16(uint64_t);
  void ffi_webext_storage_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_u32(uint64_t);
  uint32_t ffi_webext_storage_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_free_u32(uint64_t);
  void ffi_webext_storage_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_i32(uint64_t);
  int32_t ffi_webext_storage_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_free_i32(uint64_t);
  void ffi_webext_storage_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_u64(uint64_t);
  uint64_t ffi_webext_storage_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_free_u64(uint64_t);
  void ffi_webext_storage_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_i64(uint64_t);
  int64_t ffi_webext_storage_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_free_i64(uint64_t);
  void ffi_webext_storage_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_f32(uint64_t);
  float ffi_webext_storage_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_free_f32(uint64_t);
  void ffi_webext_storage_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_f64(uint64_t);
  double ffi_webext_storage_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_free_f64(uint64_t);
  void ffi_webext_storage_rust_future_poll_pointer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_pointer(uint64_t);
  void* ffi_webext_storage_rust_future_complete_pointer(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_free_pointer(uint64_t);
  void ffi_webext_storage_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_rust_buffer(uint64_t);
  RustBuffer ffi_webext_storage_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_free_rust_buffer(uint64_t);
  void ffi_webext_storage_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_webext_storage_rust_future_cancel_void(uint64_t);
  void ffi_webext_storage_rust_future_complete_void(uint64_t, RustCallStatus*);
  void ffi_webext_storage_rust_future_free_void(uint64_t);
  void* uniffi_webext_storage_fn_clone_webextstoragebridgedengine(void*, RustCallStatus*);
  void uniffi_webext_storage_fn_free_webextstoragebridgedengine(void*, RustCallStatus*);
  void* uniffi_webext_storage_fn_clone_webextstoragestore(void*, RustCallStatus*);
  void uniffi_webext_storage_fn_free_webextstoragestore(void*, RustCallStatus*);
  RustBuffer uniffi_webext_storage_fn_method_webextstoragebridgedengine_apply(void*, RustCallStatus*);
  RustBuffer uniffi_webext_storage_fn_method_webextstoragebridgedengine_ensure_current_sync_id(void*, RustBuffer, RustCallStatus*);
  int64_t uniffi_webext_storage_fn_method_webextstoragebridgedengine_last_sync(void*, RustCallStatus*);
  void uniffi_webext_storage_fn_method_webextstoragebridgedengine_prepare_for_sync(void*, RustBuffer, RustCallStatus*);
  void uniffi_webext_storage_fn_method_webextstoragebridgedengine_reset(void*, RustCallStatus*);
  RustBuffer uniffi_webext_storage_fn_method_webextstoragebridgedengine_reset_sync_id(void*, RustCallStatus*);
  void uniffi_webext_storage_fn_method_webextstoragebridgedengine_set_last_sync(void*, int64_t, RustCallStatus*);
  void uniffi_webext_storage_fn_method_webextstoragebridgedengine_set_uploaded(void*, int64_t, RustBuffer, RustCallStatus*);
  void uniffi_webext_storage_fn_method_webextstoragebridgedengine_store_incoming(void*, RustBuffer, RustCallStatus*);
  void uniffi_webext_storage_fn_method_webextstoragebridgedengine_sync_finished(void*, RustCallStatus*);
  RustBuffer uniffi_webext_storage_fn_method_webextstoragebridgedengine_sync_id(void*, RustCallStatus*);
  void uniffi_webext_storage_fn_method_webextstoragebridgedengine_sync_started(void*, RustCallStatus*);
  void uniffi_webext_storage_fn_method_webextstoragebridgedengine_wipe(void*, RustCallStatus*);
  void* uniffi_webext_storage_fn_constructor_webextstoragestore_new(RustBuffer, RustCallStatus*);
  void* uniffi_webext_storage_fn_method_webextstoragestore_bridged_engine(void*, RustCallStatus*);
  RustBuffer uniffi_webext_storage_fn_method_webextstoragestore_clear(void*, RustBuffer, RustCallStatus*);
  void uniffi_webext_storage_fn_method_webextstoragestore_close(void*, RustCallStatus*);
  RustBuffer uniffi_webext_storage_fn_method_webextstoragestore_get(void*, RustBuffer, RustBuffer, RustCallStatus*);
  uint64_t uniffi_webext_storage_fn_method_webextstoragestore_get_bytes_in_use(void*, RustBuffer, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_webext_storage_fn_method_webextstoragestore_get_synced_changes(void*, RustCallStatus*);
  RustBuffer uniffi_webext_storage_fn_method_webextstoragestore_remove(void*, RustBuffer, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_webext_storage_fn_method_webextstoragestore_set(void*, RustBuffer, RustBuffer, RustCallStatus*);
  uint32_t ffi_webext_storage_uniffi_contract_version();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_apply();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_ensure_current_sync_id();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_last_sync();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_prepare_for_sync();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_reset();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_reset_sync_id();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_set_last_sync();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_set_uploaded();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_store_incoming();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_sync_finished();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_sync_id();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_sync_started();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragebridgedengine_wipe();
  uint16_t uniffi_webext_storage_checksum_constructor_webextstoragestore_new();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragestore_bridged_engine();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragestore_clear();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragestore_close();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragestore_get();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragestore_get_bytes_in_use();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragestore_get_synced_changes();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragestore_remove();
  uint16_t uniffi_webext_storage_checksum_method_webextstoragestore_set();

#ifdef MOZ_UNIFFI_FIXTURES
  RustBuffer ffi_uniffi_bindings_tests_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_uniffi_bindings_tests_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_uniffi_bindings_tests_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_cancel_u8(uint64_t);
  uint8_t ffi_uniffi_bindings_tests_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rust_future_free_u8(uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_cancel_i8(uint64_t);
  int8_t ffi_uniffi_bindings_tests_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rust_future_free_i8(uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_cancel_u16(uint64_t);
  uint16_t ffi_uniffi_bindings_tests_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rust_future_free_u16(uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_cancel_i16(uint64_t);
  int16_t ffi_uniffi_bindings_tests_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rust_future_free_i16(uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_cancel_u32(uint64_t);
  uint32_t ffi_uniffi_bindings_tests_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rust_future_free_u32(uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_cancel_i32(uint64_t);
  int32_t ffi_uniffi_bindings_tests_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rust_future_free_i32(uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_cancel_u64(uint64_t);
  uint64_t ffi_uniffi_bindings_tests_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rust_future_free_u64(uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_cancel_i64(uint64_t);
  int64_t ffi_uniffi_bindings_tests_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rust_future_free_i64(uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_cancel_f32(uint64_t);
  float ffi_uniffi_bindings_tests_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rust_future_free_f32(uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_cancel_f64(uint64_t);
  double ffi_uniffi_bindings_tests_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rust_future_free_f64(uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_poll_pointer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_cancel_pointer(uint64_t);
  void* ffi_uniffi_bindings_tests_rust_future_complete_pointer(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rust_future_free_pointer(uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_cancel_rust_buffer(uint64_t);
  RustBuffer ffi_uniffi_bindings_tests_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rust_future_free_rust_buffer(uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_cancel_void(uint64_t);
  void ffi_uniffi_bindings_tests_rust_future_complete_void(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_rust_future_free_void(uint64_t);
  void* uniffi_uniffi_bindings_tests_fn_clone_asyncinterface(void*, RustCallStatus*);
  void uniffi_uniffi_bindings_tests_fn_free_asyncinterface(void*, RustCallStatus*);
  void* uniffi_uniffi_bindings_tests_fn_clone_complexmethods(void*, RustCallStatus*);
  void uniffi_uniffi_bindings_tests_fn_free_complexmethods(void*, RustCallStatus*);
  void* uniffi_uniffi_bindings_tests_fn_clone_testinterface(void*, RustCallStatus*);
  void uniffi_uniffi_bindings_tests_fn_free_testinterface(void*, RustCallStatus*);
  typedef void (*CallbackInterfaceTestCallbackInterfaceMethod0)(uint64_t, uint32_t*, RustCallStatus*);
  typedef void (*CallbackInterfaceFreeuniffi_bindings_tests_TestCallbackInterface)(uint64_t);
  struct VTableCallbackInterfaceTestCallbackInterface {
    CallbackInterfaceTestCallbackInterfaceMethod0 get_value;
    CallbackInterfaceFreeuniffi_bindings_tests_TestCallbackInterface uniffi_free;
  };
  void uniffi_uniffi_bindings_tests_fn_init_callback_vtable_testcallbackinterface(VTableCallbackInterfaceTestCallbackInterface*);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_f32(float);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_f64(double);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_i16(int16_t);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_i32(int32_t);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_i64(int64_t);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_i8(int8_t);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_map(RustBuffer);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_obj(void*);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_string(RustBuffer);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_u16(uint16_t);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_u32(uint32_t);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_u64(uint64_t);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_u8(uint8_t);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_vec(RustBuffer);
  void* uniffi_uniffi_bindings_tests_fn_func_clone_interface(void*, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_func_with_default(RustBuffer, RustCallStatus*);
  void uniffi_uniffi_bindings_tests_fn_func_func_with_error(uint32_t, RustCallStatus*);
  void uniffi_uniffi_bindings_tests_fn_func_func_with_flat_error(uint32_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_func_with_multi_word_arg(RustBuffer, RustCallStatus*);
  uint32_t uniffi_uniffi_bindings_tests_fn_func_invoke_test_callback_interface_method(uint64_t, RustCallStatus*);
  int8_t uniffi_uniffi_bindings_tests_fn_func_roundtrip_bool(int8_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_roundtrip_complex_compound(RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_roundtrip_complex_enum(RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_roundtrip_complex_rec(RustBuffer, RustCallStatus*);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_roundtrip_custom_type(uint64_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_roundtrip_enum_no_data(RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_roundtrip_enum_with_data(RustBuffer, RustCallStatus*);
  float uniffi_uniffi_bindings_tests_fn_func_roundtrip_f32(float, RustCallStatus*);
  double uniffi_uniffi_bindings_tests_fn_func_roundtrip_f64(double, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_roundtrip_hash_map(RustBuffer, RustCallStatus*);
  int16_t uniffi_uniffi_bindings_tests_fn_func_roundtrip_i16(int16_t, RustCallStatus*);
  int32_t uniffi_uniffi_bindings_tests_fn_func_roundtrip_i32(int32_t, RustCallStatus*);
  int64_t uniffi_uniffi_bindings_tests_fn_func_roundtrip_i64(int64_t, RustCallStatus*);
  int8_t uniffi_uniffi_bindings_tests_fn_func_roundtrip_i8(int8_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_roundtrip_option(RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_roundtrip_simple_rec(RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_roundtrip_string(RustBuffer, RustCallStatus*);
  uint16_t uniffi_uniffi_bindings_tests_fn_func_roundtrip_u16(uint16_t, RustCallStatus*);
  uint32_t uniffi_uniffi_bindings_tests_fn_func_roundtrip_u32(uint32_t, RustCallStatus*);
  uint64_t uniffi_uniffi_bindings_tests_fn_func_roundtrip_u64(uint64_t, RustCallStatus*);
  uint8_t uniffi_uniffi_bindings_tests_fn_func_roundtrip_u8(uint8_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_roundtrip_vec(RustBuffer, RustCallStatus*);
  double uniffi_uniffi_bindings_tests_fn_func_sum_with_many_types(uint8_t, int8_t, uint16_t, int16_t, uint32_t, int32_t, uint64_t, int64_t, float, double, int8_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_func_swap_test_interfaces(RustBuffer, RustCallStatus*);
  void uniffi_uniffi_bindings_tests_fn_func_test_func(RustCallStatus*);
  void* uniffi_uniffi_bindings_tests_fn_constructor_asyncinterface_new(RustBuffer, RustCallStatus*);
  uint64_t uniffi_uniffi_bindings_tests_fn_method_asyncinterface_name(void*);
  void* uniffi_uniffi_bindings_tests_fn_constructor_complexmethods_new(RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_method_complexmethods_method_with_default(void*, RustBuffer, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_fn_method_complexmethods_method_with_multi_word_arg(void*, RustBuffer, RustCallStatus*);
  void* uniffi_uniffi_bindings_tests_fn_constructor_testinterface_new(uint32_t, RustCallStatus*);
  uint32_t uniffi_uniffi_bindings_tests_fn_method_testinterface_get_value(void*, RustCallStatus*);
  uint32_t uniffi_uniffi_bindings_tests_fn_method_testinterface_ref_count(void*, RustCallStatus*);
  uint32_t ffi_uniffi_bindings_tests_uniffi_contract_version();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_roundtrip_f32();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_roundtrip_f64();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_roundtrip_i16();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_roundtrip_i32();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_roundtrip_i64();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_roundtrip_i8();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_roundtrip_map();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_roundtrip_obj();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_roundtrip_string();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_roundtrip_u16();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_roundtrip_u32();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_roundtrip_u64();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_roundtrip_u8();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_async_roundtrip_vec();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_clone_interface();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_func_with_default();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_func_with_error();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_func_with_flat_error();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_func_with_multi_word_arg();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_invoke_test_callback_interface_method();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_bool();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_complex_compound();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_complex_enum();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_complex_rec();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_custom_type();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_enum_no_data();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_enum_with_data();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_f32();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_f64();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_hash_map();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_i16();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_i32();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_i64();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_i8();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_option();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_simple_rec();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_string();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_u16();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_u32();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_u64();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_u8();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_roundtrip_vec();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_sum_with_many_types();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_swap_test_interfaces();
  uint16_t uniffi_uniffi_bindings_tests_checksum_func_test_func();
  uint16_t uniffi_uniffi_bindings_tests_checksum_constructor_asyncinterface_new();
  uint16_t uniffi_uniffi_bindings_tests_checksum_method_asyncinterface_name();
  uint16_t uniffi_uniffi_bindings_tests_checksum_constructor_complexmethods_new();
  uint16_t uniffi_uniffi_bindings_tests_checksum_method_complexmethods_method_with_default();
  uint16_t uniffi_uniffi_bindings_tests_checksum_method_complexmethods_method_with_multi_word_arg();
  uint16_t uniffi_uniffi_bindings_tests_checksum_constructor_testinterface_new();
  uint16_t uniffi_uniffi_bindings_tests_checksum_method_testinterface_get_value();
  uint16_t uniffi_uniffi_bindings_tests_checksum_method_testinterface_ref_count();
  uint16_t uniffi_uniffi_bindings_tests_checksum_method_testcallbackinterface_get_value();
  RustBuffer ffi_uniffi_bindings_tests_external_types_rustbuffer_alloc(uint64_t, RustCallStatus*);
  RustBuffer ffi_uniffi_bindings_tests_external_types_rustbuffer_from_bytes(ForeignBytes, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rustbuffer_free(RustBuffer, RustCallStatus*);
  RustBuffer ffi_uniffi_bindings_tests_external_types_rustbuffer_reserve(RustBuffer, uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rust_future_poll_u8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_cancel_u8(uint64_t);
  uint8_t ffi_uniffi_bindings_tests_external_types_rust_future_complete_u8(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rust_future_free_u8(uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_poll_i8(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_cancel_i8(uint64_t);
  int8_t ffi_uniffi_bindings_tests_external_types_rust_future_complete_i8(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rust_future_free_i8(uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_poll_u16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_cancel_u16(uint64_t);
  uint16_t ffi_uniffi_bindings_tests_external_types_rust_future_complete_u16(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rust_future_free_u16(uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_poll_i16(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_cancel_i16(uint64_t);
  int16_t ffi_uniffi_bindings_tests_external_types_rust_future_complete_i16(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rust_future_free_i16(uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_poll_u32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_cancel_u32(uint64_t);
  uint32_t ffi_uniffi_bindings_tests_external_types_rust_future_complete_u32(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rust_future_free_u32(uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_poll_i32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_cancel_i32(uint64_t);
  int32_t ffi_uniffi_bindings_tests_external_types_rust_future_complete_i32(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rust_future_free_i32(uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_poll_u64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_cancel_u64(uint64_t);
  uint64_t ffi_uniffi_bindings_tests_external_types_rust_future_complete_u64(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rust_future_free_u64(uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_poll_i64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_cancel_i64(uint64_t);
  int64_t ffi_uniffi_bindings_tests_external_types_rust_future_complete_i64(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rust_future_free_i64(uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_poll_f32(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_cancel_f32(uint64_t);
  float ffi_uniffi_bindings_tests_external_types_rust_future_complete_f32(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rust_future_free_f32(uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_poll_f64(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_cancel_f64(uint64_t);
  double ffi_uniffi_bindings_tests_external_types_rust_future_complete_f64(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rust_future_free_f64(uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_poll_pointer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_cancel_pointer(uint64_t);
  void* ffi_uniffi_bindings_tests_external_types_rust_future_complete_pointer(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rust_future_free_pointer(uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_poll_rust_buffer(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_cancel_rust_buffer(uint64_t);
  RustBuffer ffi_uniffi_bindings_tests_external_types_rust_future_complete_rust_buffer(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rust_future_free_rust_buffer(uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_poll_void(uint64_t, RustFutureContinuationCallback, uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_cancel_void(uint64_t);
  void ffi_uniffi_bindings_tests_external_types_rust_future_complete_void(uint64_t, RustCallStatus*);
  void ffi_uniffi_bindings_tests_external_types_rust_future_free_void(uint64_t);
  uint64_t uniffi_uniffi_bindings_tests_external_types_fn_func_roundtrip_ext_custom_type(uint64_t, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_external_types_fn_func_roundtrip_ext_enum(RustBuffer, RustCallStatus*);
  void* uniffi_uniffi_bindings_tests_external_types_fn_func_roundtrip_ext_interface(void*, RustCallStatus*);
  RustBuffer uniffi_uniffi_bindings_tests_external_types_fn_func_roundtrip_ext_record(RustBuffer, RustCallStatus*);
  uint32_t ffi_uniffi_bindings_tests_external_types_uniffi_contract_version();
  uint16_t uniffi_uniffi_bindings_tests_external_types_checksum_func_roundtrip_ext_custom_type();
  uint16_t uniffi_uniffi_bindings_tests_external_types_checksum_func_roundtrip_ext_enum();
  uint16_t uniffi_uniffi_bindings_tests_external_types_checksum_func_roundtrip_ext_interface();
  uint16_t uniffi_uniffi_bindings_tests_external_types_checksum_func_roundtrip_ext_record();
#endif /* MOZ_UNIFFI_FIXTURES */
}
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

// Define pointer types

const static mozilla::uniffi::UniFFIPointerType kContextIdContextIdComponentPointerType {
  "context_id::ContextIDComponent"_ns,
  uniffi_context_id_fn_clone_contextidcomponent,
  uniffi_context_id_fn_free_contextidcomponent,
};

class FfiValueObjectHandleContextIdContextIdComponent {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleContextIdContextIdComponent() = default;
  explicit FfiValueObjectHandleContextIdContextIdComponent(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleContextIdContextIdComponent(const FfiValueObjectHandleContextIdContextIdComponent&) = delete;
  FfiValueObjectHandleContextIdContextIdComponent& operator=(const FfiValueObjectHandleContextIdContextIdComponent&) = delete;

    FfiValueObjectHandleContextIdContextIdComponent& operator=(FfiValueObjectHandleContextIdContextIdComponent&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kContextIdContextIdComponentPointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kContextIdContextIdComponentPointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleContextIdContextIdComponent FromRust(void* aValue) {
    return FfiValueObjectHandleContextIdContextIdComponent(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_context_id_fn_free_contextidcomponent)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleContextIdContextIdComponent() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kRelevancyRelevancyStorePointerType {
  "relevancy::RelevancyStore"_ns,
  uniffi_relevancy_fn_clone_relevancystore,
  uniffi_relevancy_fn_free_relevancystore,
};

class FfiValueObjectHandleRelevancyRelevancyStore {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleRelevancyRelevancyStore() = default;
  explicit FfiValueObjectHandleRelevancyRelevancyStore(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleRelevancyRelevancyStore(const FfiValueObjectHandleRelevancyRelevancyStore&) = delete;
  FfiValueObjectHandleRelevancyRelevancyStore& operator=(const FfiValueObjectHandleRelevancyRelevancyStore&) = delete;

    FfiValueObjectHandleRelevancyRelevancyStore& operator=(FfiValueObjectHandleRelevancyRelevancyStore&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kRelevancyRelevancyStorePointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kRelevancyRelevancyStorePointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleRelevancyRelevancyStore FromRust(void* aValue) {
    return FfiValueObjectHandleRelevancyRelevancyStore(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_relevancy_fn_free_relevancystore)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleRelevancyRelevancyStore() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kRemoteSettingsRemoteSettingsPointerType {
  "remote_settings::RemoteSettings"_ns,
  uniffi_remote_settings_fn_clone_remotesettings,
  uniffi_remote_settings_fn_free_remotesettings,
};

class FfiValueObjectHandleRemoteSettingsRemoteSettings {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleRemoteSettingsRemoteSettings() = default;
  explicit FfiValueObjectHandleRemoteSettingsRemoteSettings(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleRemoteSettingsRemoteSettings(const FfiValueObjectHandleRemoteSettingsRemoteSettings&) = delete;
  FfiValueObjectHandleRemoteSettingsRemoteSettings& operator=(const FfiValueObjectHandleRemoteSettingsRemoteSettings&) = delete;

    FfiValueObjectHandleRemoteSettingsRemoteSettings& operator=(FfiValueObjectHandleRemoteSettingsRemoteSettings&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kRemoteSettingsRemoteSettingsPointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kRemoteSettingsRemoteSettingsPointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleRemoteSettingsRemoteSettings FromRust(void* aValue) {
    return FfiValueObjectHandleRemoteSettingsRemoteSettings(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_remote_settings_fn_free_remotesettings)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleRemoteSettingsRemoteSettings() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kRemoteSettingsRemoteSettingsClientPointerType {
  "remote_settings::RemoteSettingsClient"_ns,
  uniffi_remote_settings_fn_clone_remotesettingsclient,
  uniffi_remote_settings_fn_free_remotesettingsclient,
};

class FfiValueObjectHandleRemoteSettingsRemoteSettingsClient {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleRemoteSettingsRemoteSettingsClient() = default;
  explicit FfiValueObjectHandleRemoteSettingsRemoteSettingsClient(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleRemoteSettingsRemoteSettingsClient(const FfiValueObjectHandleRemoteSettingsRemoteSettingsClient&) = delete;
  FfiValueObjectHandleRemoteSettingsRemoteSettingsClient& operator=(const FfiValueObjectHandleRemoteSettingsRemoteSettingsClient&) = delete;

    FfiValueObjectHandleRemoteSettingsRemoteSettingsClient& operator=(FfiValueObjectHandleRemoteSettingsRemoteSettingsClient&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kRemoteSettingsRemoteSettingsClientPointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kRemoteSettingsRemoteSettingsClientPointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleRemoteSettingsRemoteSettingsClient FromRust(void* aValue) {
    return FfiValueObjectHandleRemoteSettingsRemoteSettingsClient(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_remote_settings_fn_free_remotesettingsclient)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleRemoteSettingsRemoteSettingsClient() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kRemoteSettingsRemoteSettingsServicePointerType {
  "remote_settings::RemoteSettingsService"_ns,
  uniffi_remote_settings_fn_clone_remotesettingsservice,
  uniffi_remote_settings_fn_free_remotesettingsservice,
};

class FfiValueObjectHandleRemoteSettingsRemoteSettingsService {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService() = default;
  explicit FfiValueObjectHandleRemoteSettingsRemoteSettingsService(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService(const FfiValueObjectHandleRemoteSettingsRemoteSettingsService&) = delete;
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService& operator=(const FfiValueObjectHandleRemoteSettingsRemoteSettingsService&) = delete;

    FfiValueObjectHandleRemoteSettingsRemoteSettingsService& operator=(FfiValueObjectHandleRemoteSettingsRemoteSettingsService&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kRemoteSettingsRemoteSettingsServicePointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kRemoteSettingsRemoteSettingsServicePointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleRemoteSettingsRemoteSettingsService FromRust(void* aValue) {
    return FfiValueObjectHandleRemoteSettingsRemoteSettingsService(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_remote_settings_fn_free_remotesettingsservice)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleRemoteSettingsRemoteSettingsService() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kSearchSearchEngineSelectorPointerType {
  "search::SearchEngineSelector"_ns,
  uniffi_search_fn_clone_searchengineselector,
  uniffi_search_fn_free_searchengineselector,
};

class FfiValueObjectHandleSearchSearchEngineSelector {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleSearchSearchEngineSelector() = default;
  explicit FfiValueObjectHandleSearchSearchEngineSelector(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleSearchSearchEngineSelector(const FfiValueObjectHandleSearchSearchEngineSelector&) = delete;
  FfiValueObjectHandleSearchSearchEngineSelector& operator=(const FfiValueObjectHandleSearchSearchEngineSelector&) = delete;

    FfiValueObjectHandleSearchSearchEngineSelector& operator=(FfiValueObjectHandleSearchSearchEngineSelector&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kSearchSearchEngineSelectorPointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kSearchSearchEngineSelectorPointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleSearchSearchEngineSelector FromRust(void* aValue) {
    return FfiValueObjectHandleSearchSearchEngineSelector(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_search_fn_free_searchengineselector)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleSearchSearchEngineSelector() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kSuggestSuggestStorePointerType {
  "suggest::SuggestStore"_ns,
  uniffi_suggest_fn_clone_suggeststore,
  uniffi_suggest_fn_free_suggeststore,
};

class FfiValueObjectHandleSuggestSuggestStore {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleSuggestSuggestStore() = default;
  explicit FfiValueObjectHandleSuggestSuggestStore(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleSuggestSuggestStore(const FfiValueObjectHandleSuggestSuggestStore&) = delete;
  FfiValueObjectHandleSuggestSuggestStore& operator=(const FfiValueObjectHandleSuggestSuggestStore&) = delete;

    FfiValueObjectHandleSuggestSuggestStore& operator=(FfiValueObjectHandleSuggestSuggestStore&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kSuggestSuggestStorePointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kSuggestSuggestStorePointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleSuggestSuggestStore FromRust(void* aValue) {
    return FfiValueObjectHandleSuggestSuggestStore(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_suggest_fn_free_suggeststore)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleSuggestSuggestStore() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kSuggestSuggestStoreBuilderPointerType {
  "suggest::SuggestStoreBuilder"_ns,
  uniffi_suggest_fn_clone_suggeststorebuilder,
  uniffi_suggest_fn_free_suggeststorebuilder,
};

class FfiValueObjectHandleSuggestSuggestStoreBuilder {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleSuggestSuggestStoreBuilder() = default;
  explicit FfiValueObjectHandleSuggestSuggestStoreBuilder(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleSuggestSuggestStoreBuilder(const FfiValueObjectHandleSuggestSuggestStoreBuilder&) = delete;
  FfiValueObjectHandleSuggestSuggestStoreBuilder& operator=(const FfiValueObjectHandleSuggestSuggestStoreBuilder&) = delete;

    FfiValueObjectHandleSuggestSuggestStoreBuilder& operator=(FfiValueObjectHandleSuggestSuggestStoreBuilder&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kSuggestSuggestStoreBuilderPointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kSuggestSuggestStoreBuilderPointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleSuggestSuggestStoreBuilder FromRust(void* aValue) {
    return FfiValueObjectHandleSuggestSuggestStoreBuilder(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_suggest_fn_free_suggeststorebuilder)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleSuggestSuggestStoreBuilder() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kTabsRemoteCommandStorePointerType {
  "tabs::RemoteCommandStore"_ns,
  uniffi_tabs_fn_clone_remotecommandstore,
  uniffi_tabs_fn_free_remotecommandstore,
};

class FfiValueObjectHandleTabsRemoteCommandStore {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleTabsRemoteCommandStore() = default;
  explicit FfiValueObjectHandleTabsRemoteCommandStore(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleTabsRemoteCommandStore(const FfiValueObjectHandleTabsRemoteCommandStore&) = delete;
  FfiValueObjectHandleTabsRemoteCommandStore& operator=(const FfiValueObjectHandleTabsRemoteCommandStore&) = delete;

    FfiValueObjectHandleTabsRemoteCommandStore& operator=(FfiValueObjectHandleTabsRemoteCommandStore&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kTabsRemoteCommandStorePointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kTabsRemoteCommandStorePointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleTabsRemoteCommandStore FromRust(void* aValue) {
    return FfiValueObjectHandleTabsRemoteCommandStore(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_tabs_fn_free_remotecommandstore)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleTabsRemoteCommandStore() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kTabsTabsBridgedEnginePointerType {
  "tabs::TabsBridgedEngine"_ns,
  uniffi_tabs_fn_clone_tabsbridgedengine,
  uniffi_tabs_fn_free_tabsbridgedengine,
};

class FfiValueObjectHandleTabsTabsBridgedEngine {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleTabsTabsBridgedEngine() = default;
  explicit FfiValueObjectHandleTabsTabsBridgedEngine(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleTabsTabsBridgedEngine(const FfiValueObjectHandleTabsTabsBridgedEngine&) = delete;
  FfiValueObjectHandleTabsTabsBridgedEngine& operator=(const FfiValueObjectHandleTabsTabsBridgedEngine&) = delete;

    FfiValueObjectHandleTabsTabsBridgedEngine& operator=(FfiValueObjectHandleTabsTabsBridgedEngine&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kTabsTabsBridgedEnginePointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kTabsTabsBridgedEnginePointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleTabsTabsBridgedEngine FromRust(void* aValue) {
    return FfiValueObjectHandleTabsTabsBridgedEngine(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_tabs_fn_free_tabsbridgedengine)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleTabsTabsBridgedEngine() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kTabsTabsStorePointerType {
  "tabs::TabsStore"_ns,
  uniffi_tabs_fn_clone_tabsstore,
  uniffi_tabs_fn_free_tabsstore,
};

class FfiValueObjectHandleTabsTabsStore {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleTabsTabsStore() = default;
  explicit FfiValueObjectHandleTabsTabsStore(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleTabsTabsStore(const FfiValueObjectHandleTabsTabsStore&) = delete;
  FfiValueObjectHandleTabsTabsStore& operator=(const FfiValueObjectHandleTabsTabsStore&) = delete;

    FfiValueObjectHandleTabsTabsStore& operator=(FfiValueObjectHandleTabsTabsStore&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kTabsTabsStorePointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kTabsTabsStorePointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleTabsTabsStore FromRust(void* aValue) {
    return FfiValueObjectHandleTabsTabsStore(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_tabs_fn_free_tabsstore)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleTabsTabsStore() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kWebextstorageWebExtStorageBridgedEnginePointerType {
  "webextstorage::WebExtStorageBridgedEngine"_ns,
  uniffi_webext_storage_fn_clone_webextstoragebridgedengine,
  uniffi_webext_storage_fn_free_webextstoragebridgedengine,
};

class FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine() = default;
  explicit FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine(const FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine&) = delete;
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine& operator=(const FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine&) = delete;

    FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine& operator=(FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kWebextstorageWebExtStorageBridgedEnginePointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kWebextstorageWebExtStorageBridgedEnginePointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine FromRust(void* aValue) {
    return FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_webext_storage_fn_free_webextstoragebridgedengine)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kWebextstorageWebExtStorageStorePointerType {
  "webextstorage::WebExtStorageStore"_ns,
  uniffi_webext_storage_fn_clone_webextstoragestore,
  uniffi_webext_storage_fn_free_webextstoragestore,
};

class FfiValueObjectHandleWebextstorageWebExtStorageStore {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleWebextstorageWebExtStorageStore() = default;
  explicit FfiValueObjectHandleWebextstorageWebExtStorageStore(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleWebextstorageWebExtStorageStore(const FfiValueObjectHandleWebextstorageWebExtStorageStore&) = delete;
  FfiValueObjectHandleWebextstorageWebExtStorageStore& operator=(const FfiValueObjectHandleWebextstorageWebExtStorageStore&) = delete;

    FfiValueObjectHandleWebextstorageWebExtStorageStore& operator=(FfiValueObjectHandleWebextstorageWebExtStorageStore&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kWebextstorageWebExtStorageStorePointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kWebextstorageWebExtStorageStorePointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleWebextstorageWebExtStorageStore FromRust(void* aValue) {
    return FfiValueObjectHandleWebextstorageWebExtStorageStore(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_webext_storage_fn_free_webextstoragestore)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleWebextstorageWebExtStorageStore() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};

#ifdef MOZ_UNIFFI_FIXTURES
const static mozilla::uniffi::UniFFIPointerType kUniffiBindingsTestsTestInterfacePointerType {
  "uniffi_bindings_tests::TestInterface"_ns,
  uniffi_uniffi_bindings_tests_fn_clone_testinterface,
  uniffi_uniffi_bindings_tests_fn_free_testinterface,
};

class FfiValueObjectHandleUniffiBindingsTestsTestInterface {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleUniffiBindingsTestsTestInterface() = default;
  explicit FfiValueObjectHandleUniffiBindingsTestsTestInterface(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleUniffiBindingsTestsTestInterface(const FfiValueObjectHandleUniffiBindingsTestsTestInterface&) = delete;
  FfiValueObjectHandleUniffiBindingsTestsTestInterface& operator=(const FfiValueObjectHandleUniffiBindingsTestsTestInterface&) = delete;

    FfiValueObjectHandleUniffiBindingsTestsTestInterface& operator=(FfiValueObjectHandleUniffiBindingsTestsTestInterface&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kUniffiBindingsTestsTestInterfacePointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kUniffiBindingsTestsTestInterfacePointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleUniffiBindingsTestsTestInterface FromRust(void* aValue) {
    return FfiValueObjectHandleUniffiBindingsTestsTestInterface(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_uniffi_bindings_tests_fn_free_testinterface)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleUniffiBindingsTestsTestInterface() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kUniffiBindingsTestsAsyncInterfacePointerType {
  "uniffi_bindings_tests::AsyncInterface"_ns,
  uniffi_uniffi_bindings_tests_fn_clone_asyncinterface,
  uniffi_uniffi_bindings_tests_fn_free_asyncinterface,
};

class FfiValueObjectHandleUniffiBindingsTestsAsyncInterface {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleUniffiBindingsTestsAsyncInterface() = default;
  explicit FfiValueObjectHandleUniffiBindingsTestsAsyncInterface(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleUniffiBindingsTestsAsyncInterface(const FfiValueObjectHandleUniffiBindingsTestsAsyncInterface&) = delete;
  FfiValueObjectHandleUniffiBindingsTestsAsyncInterface& operator=(const FfiValueObjectHandleUniffiBindingsTestsAsyncInterface&) = delete;

    FfiValueObjectHandleUniffiBindingsTestsAsyncInterface& operator=(FfiValueObjectHandleUniffiBindingsTestsAsyncInterface&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kUniffiBindingsTestsAsyncInterfacePointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kUniffiBindingsTestsAsyncInterfacePointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleUniffiBindingsTestsAsyncInterface FromRust(void* aValue) {
    return FfiValueObjectHandleUniffiBindingsTestsAsyncInterface(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_uniffi_bindings_tests_fn_free_asyncinterface)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleUniffiBindingsTestsAsyncInterface() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
const static mozilla::uniffi::UniFFIPointerType kUniffiBindingsTestsComplexMethodsPointerType {
  "uniffi_bindings_tests::ComplexMethods"_ns,
  uniffi_uniffi_bindings_tests_fn_clone_complexmethods,
  uniffi_uniffi_bindings_tests_fn_free_complexmethods,
};

class FfiValueObjectHandleUniffiBindingsTestsComplexMethods {
 private:
  void* mValue = nullptr;

 public:
  FfiValueObjectHandleUniffiBindingsTestsComplexMethods() = default;
  explicit FfiValueObjectHandleUniffiBindingsTestsComplexMethods(void* aValue) : mValue(aValue) {}

  // Delete copy constructor and assignment as this type is non-copyable.
  FfiValueObjectHandleUniffiBindingsTestsComplexMethods(const FfiValueObjectHandleUniffiBindingsTestsComplexMethods&) = delete;
  FfiValueObjectHandleUniffiBindingsTestsComplexMethods& operator=(const FfiValueObjectHandleUniffiBindingsTestsComplexMethods&) = delete;

    FfiValueObjectHandleUniffiBindingsTestsComplexMethods& operator=(FfiValueObjectHandleUniffiBindingsTestsComplexMethods&& aOther) {
    FreeHandle();
    mValue = aOther.mValue;
    aOther.mValue = nullptr;
    return *this;
  }

  void Lower(const dom::OwningUniFFIScaffoldingValue& aValue,
             ErrorResult& aError) {
    if (!aValue.IsUniFFIPointer()) {
      aError.ThrowTypeError("Expected UniFFI pointer argument"_ns);
      return;
    }
    dom::UniFFIPointer& value = aValue.GetAsUniFFIPointer();
    if (!value.IsSamePtrType(&kUniffiBindingsTestsComplexMethodsPointerType)) {
      aError.ThrowTypeError("Incorrect UniFFI pointer type"_ns);
      return;
    }
    FreeHandle();
    mValue = value.ClonePtr();
  }

  void Lift(JSContext* aContext, dom::OwningUniFFIScaffoldingValue* aDest,
            ErrorResult& aError) {
    aDest->SetAsUniFFIPointer() =
        dom::UniFFIPointer::Create(mValue, &kUniffiBindingsTestsComplexMethodsPointerType);
    mValue = nullptr;
  }

  void* IntoRust() {
    auto temp = mValue;
    mValue = nullptr;
    return temp;
  }

  static FfiValueObjectHandleUniffiBindingsTestsComplexMethods FromRust(void* aValue) {
    return FfiValueObjectHandleUniffiBindingsTestsComplexMethods(aValue);
  }

  void FreeHandle() {
    if (mValue) {
      RustCallStatus callStatus{};
      (uniffi_uniffi_bindings_tests_fn_free_complexmethods)(mValue, &callStatus);
      // No need to check `RustCallStatus`, it's only part of the API to match
      // other FFI calls.  The free function can never fail.
    }
  }

  ~FfiValueObjectHandleUniffiBindingsTestsComplexMethods() {
    // If the pointer is non-null, this means Lift/IntoRust was never called
    // because there was some failure along the way. Free the pointer to avoid a
    // leak
    FreeHandle();
  }
};
#endif /* MOZ_UNIFFI_FIXTURES */

Maybe<already_AddRefed<UniFFIPointer>> ReadPointer(const GlobalObject& aGlobal, uint64_t aId, const ArrayBuffer& aArrayBuff, long aPosition, ErrorResult& aError) {
  const UniFFIPointerType* type;
  switch (aId) {

    case 1: {
      type = &kContextIdContextIdComponentPointerType;
      break;
    }
    case 2: {
      type = &kRelevancyRelevancyStorePointerType;
      break;
    }
    case 3: {
      type = &kRemoteSettingsRemoteSettingsPointerType;
      break;
    }
    case 4: {
      type = &kRemoteSettingsRemoteSettingsClientPointerType;
      break;
    }
    case 5: {
      type = &kRemoteSettingsRemoteSettingsServicePointerType;
      break;
    }
    case 6: {
      type = &kSearchSearchEngineSelectorPointerType;
      break;
    }
    case 7: {
      type = &kSuggestSuggestStorePointerType;
      break;
    }
    case 8: {
      type = &kSuggestSuggestStoreBuilderPointerType;
      break;
    }
    case 9: {
      type = &kTabsRemoteCommandStorePointerType;
      break;
    }
    case 10: {
      type = &kTabsTabsBridgedEnginePointerType;
      break;
    }
    case 11: {
      type = &kTabsTabsStorePointerType;
      break;
    }
    case 12: {
      type = &kWebextstorageWebExtStorageBridgedEnginePointerType;
      break;
    }
    case 13: {
      type = &kWebextstorageWebExtStorageStorePointerType;
      break;
    }

#ifdef MOZ_UNIFFI_FIXTURES
    case 14: {
      type = &kUniffiBindingsTestsTestInterfacePointerType;
      break;
    }
    case 15: {
      type = &kUniffiBindingsTestsAsyncInterfacePointerType;
      break;
    }
    case 16: {
      type = &kUniffiBindingsTestsComplexMethodsPointerType;
      break;
    }
#endif /* MOZ_UNIFFI_FIXTURES */
    default:
      return Nothing();
  }
  return Some(UniFFIPointer::Read(aArrayBuff, aPosition, type, aError));
}

bool WritePointer(const GlobalObject& aGlobal, uint64_t aId, const UniFFIPointer& aPtr, const ArrayBuffer& aArrayBuff, long aPosition, ErrorResult& aError) {
  const UniFFIPointerType* type;
  switch (aId) {

    case 1: {
      type = &kContextIdContextIdComponentPointerType;
      break;
    }
    case 2: {
      type = &kRelevancyRelevancyStorePointerType;
      break;
    }
    case 3: {
      type = &kRemoteSettingsRemoteSettingsPointerType;
      break;
    }
    case 4: {
      type = &kRemoteSettingsRemoteSettingsClientPointerType;
      break;
    }
    case 5: {
      type = &kRemoteSettingsRemoteSettingsServicePointerType;
      break;
    }
    case 6: {
      type = &kSearchSearchEngineSelectorPointerType;
      break;
    }
    case 7: {
      type = &kSuggestSuggestStorePointerType;
      break;
    }
    case 8: {
      type = &kSuggestSuggestStoreBuilderPointerType;
      break;
    }
    case 9: {
      type = &kTabsRemoteCommandStorePointerType;
      break;
    }
    case 10: {
      type = &kTabsTabsBridgedEnginePointerType;
      break;
    }
    case 11: {
      type = &kTabsTabsStorePointerType;
      break;
    }
    case 12: {
      type = &kWebextstorageWebExtStorageBridgedEnginePointerType;
      break;
    }
    case 13: {
      type = &kWebextstorageWebExtStorageStorePointerType;
      break;
    }

#ifdef MOZ_UNIFFI_FIXTURES
    case 14: {
      type = &kUniffiBindingsTestsTestInterfacePointerType;
      break;
    }
    case 15: {
      type = &kUniffiBindingsTestsAsyncInterfacePointerType;
      break;
    }
    case 16: {
      type = &kUniffiBindingsTestsComplexMethodsPointerType;
      break;
    }
#endif /* MOZ_UNIFFI_FIXTURES */
    default:
      return false;
  }
  aPtr.Write(aArrayBuff, aPosition, type, aError);
  return true;
}
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

// Define scaffolding call classes for each combination of return/argument types

class ScaffoldingCallHandlerUniffiContextIdFnConstructorContextidcomponentNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mInitContextId{};
  FfiValueInt<int64_t> mCreationTimestampS{};
  FfiValueInt<int8_t> mRunningInTestAutomation{};
  FfiValueInt<uint64_t> mCallback{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleContextIdContextIdComponent mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mInitContextId.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mCreationTimestampS.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mRunningInTestAutomation.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
    mCallback.Lower(aArgs[3], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleContextIdContextIdComponent::FromRust(
      uniffi_context_id_fn_constructor_contextidcomponent_new(
        mInitContextId.IntoRust(),
        mCreationTimestampS.IntoRust(),
        mRunningInTestAutomation.IntoRust(),
        mCallback.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiContextIdFnMethodContextidcomponentForceRotation : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleContextIdContextIdComponent mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_context_id_fn_method_contextidcomponent_force_rotation(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiContextIdFnMethodContextidcomponentRequest : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleContextIdContextIdComponent mUniffiPtr{};
  FfiValueInt<uint8_t> mRotationDaysInS{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mRotationDaysInS.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_context_id_fn_method_contextidcomponent_request(
        mUniffiPtr.IntoRust(),
        mRotationDaysInS.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiContextIdFnMethodContextidcomponentUnsetCallback : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleContextIdContextIdComponent mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_context_id_fn_method_contextidcomponent_unset_callback(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiErrorSupportFnFuncSetApplicationErrorReporter : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint64_t> mErrorReporter{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mErrorReporter.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_error_support_fn_func_set_application_error_reporter(
      mErrorReporter.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiErrorSupportFnFuncUnsetApplicationErrorReporter : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_error_support_fn_func_unset_application_error_reporter(
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnFuncScore : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mInterestVector{};
  FfiValueRustBuffer mContentCategories{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueFloat<double> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mInterestVector.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mContentCategories.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueFloat<double>::FromRust(
      uniffi_relevancy_fn_func_score(
        mInterestVector.IntoRust(),
        mContentCategories.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnConstructorRelevancystoreNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mDbPath{};
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService mRemoteSettings{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleRelevancyRelevancyStore mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mDbPath.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mRemoteSettings.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleRelevancyRelevancyStore::FromRust(
      uniffi_relevancy_fn_constructor_relevancystore_new(
        mDbPath.IntoRust(),
        mRemoteSettings.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreBanditInit : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRelevancyRelevancyStore mUniffiPtr{};
  FfiValueRustBuffer mBandit{};
  FfiValueRustBuffer mArms{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mBandit.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mArms.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_relevancy_fn_method_relevancystore_bandit_init(
      mUniffiPtr.IntoRust(),
      mBandit.IntoRust(),
      mArms.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreBanditSelect : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRelevancyRelevancyStore mUniffiPtr{};
  FfiValueRustBuffer mBandit{};
  FfiValueRustBuffer mArms{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mBandit.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mArms.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_relevancy_fn_method_relevancystore_bandit_select(
        mUniffiPtr.IntoRust(),
        mBandit.IntoRust(),
        mArms.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreBanditUpdate : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRelevancyRelevancyStore mUniffiPtr{};
  FfiValueRustBuffer mBandit{};
  FfiValueRustBuffer mArm{};
  FfiValueInt<int8_t> mSelected{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mBandit.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mArm.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
    mSelected.Lower(aArgs[3], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_relevancy_fn_method_relevancystore_bandit_update(
      mUniffiPtr.IntoRust(),
      mBandit.IntoRust(),
      mArm.IntoRust(),
      mSelected.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreClose : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRelevancyRelevancyStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_relevancy_fn_method_relevancystore_close(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreEnsureInterestDataPopulated : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRelevancyRelevancyStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_relevancy_fn_method_relevancystore_ensure_interest_data_populated(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreGetBanditData : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRelevancyRelevancyStore mUniffiPtr{};
  FfiValueRustBuffer mBandit{};
  FfiValueRustBuffer mArm{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mBandit.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mArm.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_relevancy_fn_method_relevancystore_get_bandit_data(
        mUniffiPtr.IntoRust(),
        mBandit.IntoRust(),
        mArm.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreIngest : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRelevancyRelevancyStore mUniffiPtr{};
  FfiValueRustBuffer mTopUrlsByFrecency{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mTopUrlsByFrecency.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_relevancy_fn_method_relevancystore_ingest(
        mUniffiPtr.IntoRust(),
        mTopUrlsByFrecency.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreInterrupt : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRelevancyRelevancyStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_relevancy_fn_method_relevancystore_interrupt(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreUserInterestVector : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRelevancyRelevancyStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_relevancy_fn_method_relevancystore_user_interest_vector(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnConstructorRemotesettingsNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mRemoteSettingsConfig{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettings mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mRemoteSettingsConfig.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleRemoteSettingsRemoteSettings::FromRust(
      uniffi_remote_settings_fn_constructor_remotesettings_new(
        mRemoteSettingsConfig.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsDownloadAttachmentToPath : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettings mUniffiPtr{};
  FfiValueRustBuffer mAttachmentId{};
  FfiValueRustBuffer mPath{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mAttachmentId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mPath.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_remote_settings_fn_method_remotesettings_download_attachment_to_path(
      mUniffiPtr.IntoRust(),
      mAttachmentId.IntoRust(),
      mPath.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsGetRecords : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettings mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_remote_settings_fn_method_remotesettings_get_records(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsGetRecordsSince : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettings mUniffiPtr{};
  FfiValueInt<uint64_t> mTimestamp{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mTimestamp.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_remote_settings_fn_method_remotesettings_get_records_since(
        mUniffiPtr.IntoRust(),
        mTimestamp.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientCollectionName : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsClient mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_remote_settings_fn_method_remotesettingsclient_collection_name(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientGetAttachment : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsClient mUniffiPtr{};
  FfiValueRustBuffer mRecord{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mRecord.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_remote_settings_fn_method_remotesettingsclient_get_attachment(
        mUniffiPtr.IntoRust(),
        mRecord.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientGetRecords : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsClient mUniffiPtr{};
  FfiValueInt<int8_t> mSyncIfEmpty{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mSyncIfEmpty.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_remote_settings_fn_method_remotesettingsclient_get_records(
        mUniffiPtr.IntoRust(),
        mSyncIfEmpty.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientGetRecordsMap : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsClient mUniffiPtr{};
  FfiValueInt<int8_t> mSyncIfEmpty{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mSyncIfEmpty.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_remote_settings_fn_method_remotesettingsclient_get_records_map(
        mUniffiPtr.IntoRust(),
        mSyncIfEmpty.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientShutdown : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsClient mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_remote_settings_fn_method_remotesettingsclient_shutdown(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientSync : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsClient mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_remote_settings_fn_method_remotesettingsclient_sync(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnConstructorRemotesettingsserviceNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mStorageDir{};
  FfiValueRustBuffer mConfig{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mStorageDir.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mConfig.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleRemoteSettingsRemoteSettingsService::FromRust(
      uniffi_remote_settings_fn_constructor_remotesettingsservice_new(
        mStorageDir.IntoRust(),
        mConfig.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsserviceMakeClient : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService mUniffiPtr{};
  FfiValueRustBuffer mCollectionName{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsClient mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mCollectionName.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleRemoteSettingsRemoteSettingsClient::FromRust(
      uniffi_remote_settings_fn_method_remotesettingsservice_make_client(
        mUniffiPtr.IntoRust(),
        mCollectionName.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsserviceSync : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_remote_settings_fn_method_remotesettingsservice_sync(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsserviceUpdateConfig : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService mUniffiPtr{};
  FfiValueRustBuffer mConfig{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mConfig.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_remote_settings_fn_method_remotesettingsservice_update_config(
      mUniffiPtr.IntoRust(),
      mConfig.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiSearchFnConstructorSearchengineselectorNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleSearchSearchEngineSelector mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleSearchSearchEngineSelector::FromRust(
      uniffi_search_fn_constructor_searchengineselector_new(
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSearchFnMethodSearchengineselectorClearSearchConfig : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSearchSearchEngineSelector mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_search_fn_method_searchengineselector_clear_search_config(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiSearchFnMethodSearchengineselectorFilterEngineConfiguration : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSearchSearchEngineSelector mUniffiPtr{};
  FfiValueRustBuffer mUserEnvironment{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mUserEnvironment.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_search_fn_method_searchengineselector_filter_engine_configuration(
        mUniffiPtr.IntoRust(),
        mUserEnvironment.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSearchFnMethodSearchengineselectorSetConfigOverrides : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSearchSearchEngineSelector mUniffiPtr{};
  FfiValueRustBuffer mOverrides{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mOverrides.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_search_fn_method_searchengineselector_set_config_overrides(
      mUniffiPtr.IntoRust(),
      mOverrides.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiSearchFnMethodSearchengineselectorSetSearchConfig : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSearchSearchEngineSelector mUniffiPtr{};
  FfiValueRustBuffer mConfiguration{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mConfiguration.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_search_fn_method_searchengineselector_set_search_config(
      mUniffiPtr.IntoRust(),
      mConfiguration.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiSearchFnMethodSearchengineselectorUseRemoteSettingsServer : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSearchSearchEngineSelector mUniffiPtr{};
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService mService{};
  FfiValueInt<int8_t> mApplyEngineOverrides{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mService.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mApplyEngineOverrides.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_search_fn_method_searchengineselector_use_remote_settings_server(
      mUniffiPtr.IntoRust(),
      mService.IntoRust(),
      mApplyEngineOverrides.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnFuncRawSuggestionUrlMatches : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mRawUrl{};
  FfiValueRustBuffer mCookedUrl{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mRawUrl.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mCookedUrl.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_suggest_fn_func_raw_suggestion_url_matches(
        mRawUrl.IntoRust(),
        mCookedUrl.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnConstructorSuggeststoreNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mPath{};
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService mRemoteSettingsService{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPath.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mRemoteSettingsService.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleSuggestSuggestStore::FromRust(
      uniffi_suggest_fn_constructor_suggeststore_new(
        mPath.IntoRust(),
        mRemoteSettingsService.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreAnyDismissedSuggestions : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_suggest_fn_method_suggeststore_any_dismissed_suggestions(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreClear : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_suggest_fn_method_suggeststore_clear(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreClearDismissedSuggestions : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_suggest_fn_method_suggeststore_clear_dismissed_suggestions(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreDismissByKey : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};
  FfiValueRustBuffer mKey{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mKey.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_suggest_fn_method_suggeststore_dismiss_by_key(
      mUniffiPtr.IntoRust(),
      mKey.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreDismissBySuggestion : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};
  FfiValueRustBuffer mSuggestion{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mSuggestion.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_suggest_fn_method_suggeststore_dismiss_by_suggestion(
      mUniffiPtr.IntoRust(),
      mSuggestion.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreDismissSuggestion : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};
  FfiValueRustBuffer mSuggestionUrl{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mSuggestionUrl.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_suggest_fn_method_suggeststore_dismiss_suggestion(
      mUniffiPtr.IntoRust(),
      mSuggestionUrl.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreFetchGeonameAlternates : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};
  FfiValueRustBuffer mGeoname{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mGeoname.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_suggest_fn_method_suggeststore_fetch_geoname_alternates(
        mUniffiPtr.IntoRust(),
        mGeoname.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreFetchGeonames : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};
  FfiValueRustBuffer mQuery{};
  FfiValueInt<int8_t> mMatchNamePrefix{};
  FfiValueRustBuffer mFilter{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mQuery.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mMatchNamePrefix.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
    mFilter.Lower(aArgs[3], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_suggest_fn_method_suggeststore_fetch_geonames(
        mUniffiPtr.IntoRust(),
        mQuery.IntoRust(),
        mMatchNamePrefix.IntoRust(),
        mFilter.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreFetchGlobalConfig : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_suggest_fn_method_suggeststore_fetch_global_config(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreFetchProviderConfig : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};
  FfiValueRustBuffer mProvider{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mProvider.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_suggest_fn_method_suggeststore_fetch_provider_config(
        mUniffiPtr.IntoRust(),
        mProvider.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreIngest : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};
  FfiValueRustBuffer mConstraints{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mConstraints.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_suggest_fn_method_suggeststore_ingest(
        mUniffiPtr.IntoRust(),
        mConstraints.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreInterrupt : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};
  FfiValueRustBuffer mKind{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mKind.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_suggest_fn_method_suggeststore_interrupt(
      mUniffiPtr.IntoRust(),
      mKind.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreIsDismissedByKey : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};
  FfiValueRustBuffer mKey{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mKey.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_suggest_fn_method_suggeststore_is_dismissed_by_key(
        mUniffiPtr.IntoRust(),
        mKey.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreIsDismissedBySuggestion : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};
  FfiValueRustBuffer mSuggestion{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mSuggestion.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_suggest_fn_method_suggeststore_is_dismissed_by_suggestion(
        mUniffiPtr.IntoRust(),
        mSuggestion.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreQuery : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};
  FfiValueRustBuffer mQuery{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mQuery.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_suggest_fn_method_suggeststore_query(
        mUniffiPtr.IntoRust(),
        mQuery.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreQueryWithMetrics : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiPtr{};
  FfiValueRustBuffer mQuery{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mQuery.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_suggest_fn_method_suggeststore_query_with_metrics(
        mUniffiPtr.IntoRust(),
        mQuery.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnConstructorSuggeststorebuilderNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleSuggestSuggestStoreBuilder::FromRust(
      uniffi_suggest_fn_constructor_suggeststorebuilder_new(
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderBuild : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleSuggestSuggestStore mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleSuggestSuggestStore::FromRust(
      uniffi_suggest_fn_method_suggeststorebuilder_build(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderCachePath : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiPtr{};
  FfiValueRustBuffer mPath{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mPath.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleSuggestSuggestStoreBuilder::FromRust(
      uniffi_suggest_fn_method_suggeststorebuilder_cache_path(
        mUniffiPtr.IntoRust(),
        mPath.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderDataPath : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiPtr{};
  FfiValueRustBuffer mPath{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mPath.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleSuggestSuggestStoreBuilder::FromRust(
      uniffi_suggest_fn_method_suggeststorebuilder_data_path(
        mUniffiPtr.IntoRust(),
        mPath.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderLoadExtension : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiPtr{};
  FfiValueRustBuffer mLibrary{};
  FfiValueRustBuffer mEntryPoint{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mLibrary.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mEntryPoint.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleSuggestSuggestStoreBuilder::FromRust(
      uniffi_suggest_fn_method_suggeststorebuilder_load_extension(
        mUniffiPtr.IntoRust(),
        mLibrary.IntoRust(),
        mEntryPoint.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderRemoteSettingsBucketName : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiPtr{};
  FfiValueRustBuffer mBucketName{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mBucketName.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleSuggestSuggestStoreBuilder::FromRust(
      uniffi_suggest_fn_method_suggeststorebuilder_remote_settings_bucket_name(
        mUniffiPtr.IntoRust(),
        mBucketName.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderRemoteSettingsServer : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiPtr{};
  FfiValueRustBuffer mServer{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mServer.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleSuggestSuggestStoreBuilder::FromRust(
      uniffi_suggest_fn_method_suggeststorebuilder_remote_settings_server(
        mUniffiPtr.IntoRust(),
        mServer.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderRemoteSettingsService : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiPtr{};
  FfiValueObjectHandleRemoteSettingsRemoteSettingsService mRsService{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleSuggestSuggestStoreBuilder mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mRsService.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleSuggestSuggestStoreBuilder::FromRust(
      uniffi_suggest_fn_method_suggeststorebuilder_remote_settings_service(
        mUniffiPtr.IntoRust(),
        mRsService.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodRemotecommandstoreAddRemoteCommand : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsRemoteCommandStore mUniffiPtr{};
  FfiValueRustBuffer mDeviceId{};
  FfiValueRustBuffer mCommand{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mDeviceId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mCommand.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_tabs_fn_method_remotecommandstore_add_remote_command(
        mUniffiPtr.IntoRust(),
        mDeviceId.IntoRust(),
        mCommand.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodRemotecommandstoreAddRemoteCommandAt : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsRemoteCommandStore mUniffiPtr{};
  FfiValueRustBuffer mDeviceId{};
  FfiValueRustBuffer mCommand{};
  FfiValueInt<int64_t> mWhen{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mDeviceId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mCommand.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
    mWhen.Lower(aArgs[3], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_tabs_fn_method_remotecommandstore_add_remote_command_at(
        mUniffiPtr.IntoRust(),
        mDeviceId.IntoRust(),
        mCommand.IntoRust(),
        mWhen.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodRemotecommandstoreGetUnsentCommands : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsRemoteCommandStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_tabs_fn_method_remotecommandstore_get_unsent_commands(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodRemotecommandstoreRemoveRemoteCommand : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsRemoteCommandStore mUniffiPtr{};
  FfiValueRustBuffer mDeviceId{};
  FfiValueRustBuffer mCommand{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mDeviceId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mCommand.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_tabs_fn_method_remotecommandstore_remove_remote_command(
        mUniffiPtr.IntoRust(),
        mDeviceId.IntoRust(),
        mCommand.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodRemotecommandstoreSetPendingCommandSent : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsRemoteCommandStore mUniffiPtr{};
  FfiValueRustBuffer mCommand{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mCommand.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_tabs_fn_method_remotecommandstore_set_pending_command_sent(
        mUniffiPtr.IntoRust(),
        mCommand.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineApply : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_tabs_fn_method_tabsbridgedengine_apply(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineEnsureCurrentSyncId : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mUniffiPtr{};
  FfiValueRustBuffer mNewSyncId{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mNewSyncId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_tabs_fn_method_tabsbridgedengine_ensure_current_sync_id(
        mUniffiPtr.IntoRust(),
        mNewSyncId.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineLastSync : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int64_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int64_t>::FromRust(
      uniffi_tabs_fn_method_tabsbridgedengine_last_sync(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedenginePrepareForSync : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mUniffiPtr{};
  FfiValueRustBuffer mClientData{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mClientData.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsbridgedengine_prepare_for_sync(
      mUniffiPtr.IntoRust(),
      mClientData.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineReset : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsbridgedengine_reset(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineResetSyncId : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_tabs_fn_method_tabsbridgedengine_reset_sync_id(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineSetLastSync : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mUniffiPtr{};
  FfiValueInt<int64_t> mLastSync{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mLastSync.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsbridgedengine_set_last_sync(
      mUniffiPtr.IntoRust(),
      mLastSync.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineSetUploaded : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mUniffiPtr{};
  FfiValueInt<int64_t> mNewTimestamp{};
  FfiValueRustBuffer mUploadedIds{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mNewTimestamp.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mUploadedIds.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsbridgedengine_set_uploaded(
      mUniffiPtr.IntoRust(),
      mNewTimestamp.IntoRust(),
      mUploadedIds.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineStoreIncoming : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mUniffiPtr{};
  FfiValueRustBuffer mIncomingEnvelopesAsJson{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mIncomingEnvelopesAsJson.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsbridgedengine_store_incoming(
      mUniffiPtr.IntoRust(),
      mIncomingEnvelopesAsJson.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineSyncFinished : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsbridgedengine_sync_finished(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineSyncId : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_tabs_fn_method_tabsbridgedengine_sync_id(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineSyncStarted : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsbridgedengine_sync_started(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineWipe : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsbridgedengine_wipe(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiTabsFnConstructorTabsstoreNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mPath{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleTabsTabsStore mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPath.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleTabsTabsStore::FromRust(
      uniffi_tabs_fn_constructor_tabsstore_new(
        mPath.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreBridgedEngine : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleTabsTabsBridgedEngine mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleTabsTabsBridgedEngine::FromRust(
      uniffi_tabs_fn_method_tabsstore_bridged_engine(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreCloseConnection : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsstore_close_connection(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreGetAll : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_tabs_fn_method_tabsstore_get_all(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreNewRemoteCommandStore : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleTabsRemoteCommandStore mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleTabsRemoteCommandStore::FromRust(
      uniffi_tabs_fn_method_tabsstore_new_remote_command_store(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreRegisterWithSyncManager : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsstore_register_with_sync_manager(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreSetLocalTabs : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleTabsTabsStore mUniffiPtr{};
  FfiValueRustBuffer mRemoteTabs{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mRemoteTabs.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_tabs_fn_method_tabsstore_set_local_tabs(
      mUniffiPtr.IntoRust(),
      mRemoteTabs.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineApply : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_webext_storage_fn_method_webextstoragebridgedengine_apply(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineEnsureCurrentSyncId : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mUniffiPtr{};
  FfiValueRustBuffer mNewSyncId{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mNewSyncId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_webext_storage_fn_method_webextstoragebridgedengine_ensure_current_sync_id(
        mUniffiPtr.IntoRust(),
        mNewSyncId.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineLastSync : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int64_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int64_t>::FromRust(
      uniffi_webext_storage_fn_method_webextstoragebridgedengine_last_sync(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedenginePrepareForSync : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mUniffiPtr{};
  FfiValueRustBuffer mClientData{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mClientData.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_webext_storage_fn_method_webextstoragebridgedengine_prepare_for_sync(
      mUniffiPtr.IntoRust(),
      mClientData.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineReset : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_webext_storage_fn_method_webextstoragebridgedengine_reset(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineResetSyncId : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_webext_storage_fn_method_webextstoragebridgedengine_reset_sync_id(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineSetLastSync : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mUniffiPtr{};
  FfiValueInt<int64_t> mLastSync{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mLastSync.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_webext_storage_fn_method_webextstoragebridgedengine_set_last_sync(
      mUniffiPtr.IntoRust(),
      mLastSync.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineSetUploaded : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mUniffiPtr{};
  FfiValueInt<int64_t> mServerModifiedMillis{};
  FfiValueRustBuffer mGuids{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mServerModifiedMillis.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mGuids.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_webext_storage_fn_method_webextstoragebridgedengine_set_uploaded(
      mUniffiPtr.IntoRust(),
      mServerModifiedMillis.IntoRust(),
      mGuids.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineStoreIncoming : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mUniffiPtr{};
  FfiValueRustBuffer mIncoming{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mIncoming.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_webext_storage_fn_method_webextstoragebridgedengine_store_incoming(
      mUniffiPtr.IntoRust(),
      mIncoming.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineSyncFinished : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_webext_storage_fn_method_webextstoragebridgedengine_sync_finished(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineSyncId : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_webext_storage_fn_method_webextstoragebridgedengine_sync_id(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineSyncStarted : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_webext_storage_fn_method_webextstoragebridgedengine_sync_started(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineWipe : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_webext_storage_fn_method_webextstoragebridgedengine_wipe(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnConstructorWebextstoragestoreNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mPath{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageStore mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mPath.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleWebextstorageWebExtStorageStore::FromRust(
      uniffi_webext_storage_fn_constructor_webextstoragestore_new(
        mPath.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreBridgedEngine : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleWebextstorageWebExtStorageBridgedEngine::FromRust(
      uniffi_webext_storage_fn_method_webextstoragestore_bridged_engine(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreClear : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageStore mUniffiPtr{};
  FfiValueRustBuffer mExtId{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mExtId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_webext_storage_fn_method_webextstoragestore_clear(
        mUniffiPtr.IntoRust(),
        mExtId.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreClose : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_webext_storage_fn_method_webextstoragestore_close(
      mUniffiPtr.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreGet : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageStore mUniffiPtr{};
  FfiValueRustBuffer mExtId{};
  FfiValueRustBuffer mKeys{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mExtId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mKeys.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_webext_storage_fn_method_webextstoragestore_get(
        mUniffiPtr.IntoRust(),
        mExtId.IntoRust(),
        mKeys.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreGetBytesInUse : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageStore mUniffiPtr{};
  FfiValueRustBuffer mExtId{};
  FfiValueRustBuffer mKeys{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint64_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mExtId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mKeys.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint64_t>::FromRust(
      uniffi_webext_storage_fn_method_webextstoragestore_get_bytes_in_use(
        mUniffiPtr.IntoRust(),
        mExtId.IntoRust(),
        mKeys.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreGetSyncedChanges : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageStore mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_webext_storage_fn_method_webextstoragestore_get_synced_changes(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreRemove : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageStore mUniffiPtr{};
  FfiValueRustBuffer mExtId{};
  FfiValueRustBuffer mKeys{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mExtId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mKeys.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_webext_storage_fn_method_webextstoragestore_remove(
        mUniffiPtr.IntoRust(),
        mExtId.IntoRust(),
        mKeys.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreSet : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleWebextstorageWebExtStorageStore mUniffiPtr{};
  FfiValueRustBuffer mExtId{};
  FfiValueRustBuffer mVal{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mExtId.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mVal.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_webext_storage_fn_method_webextstoragestore_set(
        mUniffiPtr.IntoRust(),
        mExtId.IntoRust(),
        mVal.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};

#ifdef MOZ_UNIFFI_FIXTURES
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripF32 : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripF32() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_f32,
        ffi_uniffi_bindings_tests_rust_future_free_f32
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueFloat<float> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueFloat<float> mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_f32(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueFloat<float>::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_f32(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripF64 : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripF64() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_f64,
        ffi_uniffi_bindings_tests_rust_future_free_f64
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueFloat<double> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueFloat<double> mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_f64(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueFloat<double>::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_f64(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripI16 : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripI16() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_i16,
        ffi_uniffi_bindings_tests_rust_future_free_i16
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueInt<int16_t> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueInt<int16_t> mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_i16(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int16_t>::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_i16(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripI32 : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripI32() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_i32,
        ffi_uniffi_bindings_tests_rust_future_free_i32
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueInt<int32_t> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueInt<int32_t> mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_i32(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int32_t>::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_i32(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripI64 : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripI64() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_i64,
        ffi_uniffi_bindings_tests_rust_future_free_i64
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueInt<int64_t> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueInt<int64_t> mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_i64(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int64_t>::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_i64(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripI8 : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripI8() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_i8,
        ffi_uniffi_bindings_tests_rust_future_free_i8
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueInt<int8_t> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueInt<int8_t> mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_i8(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_i8(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripMap : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripMap() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_rust_buffer,
        ffi_uniffi_bindings_tests_rust_future_free_rust_buffer
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueRustBuffer mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueRustBuffer mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_map(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_rust_buffer(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripObj : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripObj() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_pointer,
        ffi_uniffi_bindings_tests_rust_future_free_pointer
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueObjectHandleUniffiBindingsTestsAsyncInterface mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueObjectHandleUniffiBindingsTestsAsyncInterface mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_obj(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleUniffiBindingsTestsAsyncInterface::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_pointer(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripString : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripString() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_rust_buffer,
        ffi_uniffi_bindings_tests_rust_future_free_rust_buffer
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueRustBuffer mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueRustBuffer mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_string(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_rust_buffer(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripU16 : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripU16() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_u16,
        ffi_uniffi_bindings_tests_rust_future_free_u16
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueInt<uint16_t> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueInt<uint16_t> mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_u16(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint16_t>::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_u16(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripU32 : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripU32() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_u32,
        ffi_uniffi_bindings_tests_rust_future_free_u32
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueInt<uint32_t> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueInt<uint32_t> mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_u32(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint32_t>::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_u32(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripU64 : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripU64() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_u64,
        ffi_uniffi_bindings_tests_rust_future_free_u64
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueInt<uint64_t> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueInt<uint64_t> mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_u64(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint64_t>::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_u64(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripU8 : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripU8() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_u8,
        ffi_uniffi_bindings_tests_rust_future_free_u8
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueInt<uint8_t> mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueInt<uint8_t> mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_u8(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint8_t>::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_u8(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripVec : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripVec() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_rust_buffer,
        ffi_uniffi_bindings_tests_rust_future_free_rust_buffer
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueRustBuffer mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueRustBuffer mV{};
    mV.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_func_async_roundtrip_vec(
      mV.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_rust_buffer(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncCloneInterface : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestInterface mInt{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestInterface mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mInt.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleUniffiBindingsTestsTestInterface::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_clone_interface(
        mInt.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncFuncWithDefault : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mArg{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mArg.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_func_with_default(
        mArg.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncFuncWithError : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint32_t> mInput{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mInput.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_uniffi_bindings_tests_fn_func_func_with_error(
      mInput.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncFuncWithFlatError : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint32_t> mInput{};

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mInput.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_uniffi_bindings_tests_fn_func_func_with_flat_error(
      mInput.IntoRust(),
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncFuncWithMultiWordArg : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mTheArgument{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mTheArgument.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_func_with_multi_word_arg(
        mTheArgument.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestCallbackInterfaceMethod : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint64_t> mCbi{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint32_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mCbi.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint32_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_invoke_test_callback_interface_method(
        mCbi.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripBool : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<int8_t> mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_bool(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripComplexCompound : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_complex_compound(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripComplexEnum : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mEn{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mEn.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_complex_enum(
        mEn.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripComplexRec : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mRec{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mRec.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_complex_rec(
        mRec.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripCustomType : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint64_t> mHandle{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint64_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mHandle.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint64_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_custom_type(
        mHandle.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripEnumNoData : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mEn{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mEn.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_enum_no_data(
        mEn.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripEnumWithData : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mEn{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mEn.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_enum_with_data(
        mEn.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripF32 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueFloat<float> mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueFloat<float> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueFloat<float>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_f32(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripF64 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueFloat<double> mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueFloat<double> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueFloat<double>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_f64(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripHashMap : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_hash_map(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripI16 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<int16_t> mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int16_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int16_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_i16(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripI32 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<int32_t> mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int32_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int32_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_i32(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripI64 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<int64_t> mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int64_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int64_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_i64(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripI8 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<int8_t> mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<int8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<int8_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_i8(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripOption : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_option(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripSimpleRec : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mRec{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mRec.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_simple_rec(
        mRec.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripString : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_string(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripU16 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint16_t> mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint16_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint16_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_u16(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripU32 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint32_t> mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint32_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint32_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_u32(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripU64 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint64_t> mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint64_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint64_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_u64(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripU8 : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint8_t> mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint8_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint8_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_u8(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripVec : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mA{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_roundtrip_vec(
        mA.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncSumWithManyTypes : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint8_t> mA{};
  FfiValueInt<int8_t> mB{};
  FfiValueInt<uint16_t> mC{};
  FfiValueInt<int16_t> mD{};
  FfiValueInt<uint32_t> mE{};
  FfiValueInt<int32_t> mF{};
  FfiValueInt<uint64_t> mG{};
  FfiValueInt<int64_t> mH{};
  FfiValueFloat<float> mI{};
  FfiValueFloat<double> mJ{};
  FfiValueInt<int8_t> mNegate{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueFloat<double> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mA.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mB.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
    mC.Lower(aArgs[2], aError);
    if (aError.Failed()) {
      return;
    }
    mD.Lower(aArgs[3], aError);
    if (aError.Failed()) {
      return;
    }
    mE.Lower(aArgs[4], aError);
    if (aError.Failed()) {
      return;
    }
    mF.Lower(aArgs[5], aError);
    if (aError.Failed()) {
      return;
    }
    mG.Lower(aArgs[6], aError);
    if (aError.Failed()) {
      return;
    }
    mH.Lower(aArgs[7], aError);
    if (aError.Failed()) {
      return;
    }
    mI.Lower(aArgs[8], aError);
    if (aError.Failed()) {
      return;
    }
    mJ.Lower(aArgs[9], aError);
    if (aError.Failed()) {
      return;
    }
    mNegate.Lower(aArgs[10], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueFloat<double>::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_sum_with_many_types(
        mA.IntoRust(),
        mB.IntoRust(),
        mC.IntoRust(),
        mD.IntoRust(),
        mE.IntoRust(),
        mF.IntoRust(),
        mG.IntoRust(),
        mH.IntoRust(),
        mI.IntoRust(),
        mJ.IntoRust(),
        mNegate.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncSwapTestInterfaces : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mInterfaces{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mInterfaces.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_func_swap_test_interfaces(
        mInterfaces.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncTestFunc : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields

  // MakeRustCall stores the result of the call in these fields

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    uniffi_uniffi_bindings_tests_fn_func_test_func(
      aOutStatus
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnConstructorTestinterfaceNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint32_t> mValue{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestInterface mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mValue.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleUniffiBindingsTestsTestInterface::FromRust(
      uniffi_uniffi_bindings_tests_fn_constructor_testinterface_new(
        mValue.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodTestinterfaceGetValue : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestInterface mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint32_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint32_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_method_testinterface_get_value(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodTestinterfaceRefCount : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestInterface mUniffiPtr{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint32_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint32_t>::FromRust(
      uniffi_uniffi_bindings_tests_fn_method_testinterface_ref_count(
        mUniffiPtr.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnConstructorAsyncinterfaceNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mName{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleUniffiBindingsTestsAsyncInterface mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mName.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleUniffiBindingsTestsAsyncInterface::FromRust(
      uniffi_uniffi_bindings_tests_fn_constructor_asyncinterface_new(
        mName.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodAsyncinterfaceName : public UniffiAsyncCallHandler {
public:
  ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodAsyncinterfaceName() : UniffiAsyncCallHandler(
        ffi_uniffi_bindings_tests_rust_future_poll_rust_buffer,
        ffi_uniffi_bindings_tests_rust_future_free_rust_buffer
    ) { }

private:
  // Complete stores the result of the call in mUniffiReturnValue
  FfiValueRustBuffer mUniffiReturnValue{};

protected:
  // Convert a sequence of JS arguments and call the scaffolding function.
  // Always called on the main thread since async Rust calls don't block, they
  // return a future.
  void LowerArgsAndMakeRustCall(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    FfiValueObjectHandleUniffiBindingsTestsAsyncInterface mUniffiPtr{};
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }

    mFutureHandle = uniffi_uniffi_bindings_tests_fn_method_asyncinterface_name(
      mUniffiPtr.IntoRust()
    );
  }

  void CallCompleteFn(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      ffi_uniffi_bindings_tests_rust_future_complete_rust_buffer(mFutureHandle, aOutStatus));
  }

public:
  void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnConstructorComplexmethodsNew : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleUniffiBindingsTestsComplexMethods mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleUniffiBindingsTestsComplexMethods::FromRust(
      uniffi_uniffi_bindings_tests_fn_constructor_complexmethods_new(
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodComplexmethodsMethodWithDefault : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleUniffiBindingsTestsComplexMethods mUniffiPtr{};
  FfiValueRustBuffer mArg{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mArg.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_method_complexmethods_method_with_default(
        mUniffiPtr.IntoRust(),
        mArg.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodComplexmethodsMethodWithMultiWordArg : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleUniffiBindingsTestsComplexMethods mUniffiPtr{};
  FfiValueRustBuffer mTheArgument{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mUniffiPtr.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
    mTheArgument.Lower(aArgs[1], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_fn_method_complexmethods_method_with_multi_word_arg(
        mUniffiPtr.IntoRust(),
        mTheArgument.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsExternalTypesFnFuncRoundtripExtCustomType : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueInt<uint64_t> mCustom{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueInt<uint64_t> mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mCustom.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueInt<uint64_t>::FromRust(
      uniffi_uniffi_bindings_tests_external_types_fn_func_roundtrip_ext_custom_type(
        mCustom.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsExternalTypesFnFuncRoundtripExtEnum : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mEn{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mEn.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_external_types_fn_func_roundtrip_ext_enum(
        mEn.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsExternalTypesFnFuncRoundtripExtInterface : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestInterface mInt{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueObjectHandleUniffiBindingsTestsTestInterface mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mInt.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueObjectHandleUniffiBindingsTestsTestInterface::FromRust(
      uniffi_uniffi_bindings_tests_external_types_fn_func_roundtrip_ext_interface(
        mInt.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
class ScaffoldingCallHandlerUniffiUniffiBindingsTestsExternalTypesFnFuncRoundtripExtRecord : public UniffiSyncCallHandler {
private:
  // LowerRustArgs stores the resulting arguments in these fields
  FfiValueRustBuffer mRec{};

  // MakeRustCall stores the result of the call in these fields
  FfiValueRustBuffer mUniffiReturnValue{};

public:
  void LowerRustArgs(const dom::Sequence<dom::OwningUniFFIScaffoldingValue>& aArgs, ErrorResult& aError) override {
    mRec.Lower(aArgs[0], aError);
    if (aError.Failed()) {
      return;
    }
  }

  void MakeRustCall(RustCallStatus* aOutStatus) override {
    mUniffiReturnValue = FfiValueRustBuffer::FromRust(
      uniffi_uniffi_bindings_tests_external_types_fn_func_roundtrip_ext_record(
        mRec.IntoRust(),
        aOutStatus
      )
    );
  }

  virtual void LiftSuccessfulCallResult(JSContext* aCx, dom::Optional<dom::OwningUniFFIScaffoldingValue>& aDest, ErrorResult& aError) override {
    mUniffiReturnValue.Lift(
      aCx,
      &aDest.Construct(),
      aError
    );
  }
};
#endif /* MOZ_UNIFFI_FIXTURES */

UniquePtr<UniffiSyncCallHandler> GetSyncCallHandler(uint64_t aId) {
  switch (aId) {

    case 1: {
      return MakeUnique<ScaffoldingCallHandlerUniffiContextIdFnConstructorContextidcomponentNew>();
    }
    case 2: {
      return MakeUnique<ScaffoldingCallHandlerUniffiContextIdFnMethodContextidcomponentForceRotation>();
    }
    case 3: {
      return MakeUnique<ScaffoldingCallHandlerUniffiContextIdFnMethodContextidcomponentRequest>();
    }
    case 4: {
      return MakeUnique<ScaffoldingCallHandlerUniffiContextIdFnMethodContextidcomponentUnsetCallback>();
    }
    case 5: {
      return MakeUnique<ScaffoldingCallHandlerUniffiErrorSupportFnFuncSetApplicationErrorReporter>();
    }
    case 6: {
      return MakeUnique<ScaffoldingCallHandlerUniffiErrorSupportFnFuncUnsetApplicationErrorReporter>();
    }
    case 7: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnFuncScore>();
    }
    case 8: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnConstructorRelevancystoreNew>();
    }
    case 9: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreBanditInit>();
    }
    case 10: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreBanditSelect>();
    }
    case 11: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreBanditUpdate>();
    }
    case 12: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreClose>();
    }
    case 13: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreEnsureInterestDataPopulated>();
    }
    case 14: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreGetBanditData>();
    }
    case 15: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreIngest>();
    }
    case 16: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreInterrupt>();
    }
    case 17: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRelevancyFnMethodRelevancystoreUserInterestVector>();
    }
    case 18: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnConstructorRemotesettingsNew>();
    }
    case 19: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsDownloadAttachmentToPath>();
    }
    case 20: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsGetRecords>();
    }
    case 21: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsGetRecordsSince>();
    }
    case 22: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientCollectionName>();
    }
    case 23: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientGetAttachment>();
    }
    case 24: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientGetRecords>();
    }
    case 25: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientGetRecordsMap>();
    }
    case 26: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientShutdown>();
    }
    case 27: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsclientSync>();
    }
    case 28: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnConstructorRemotesettingsserviceNew>();
    }
    case 29: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsserviceMakeClient>();
    }
    case 30: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsserviceSync>();
    }
    case 31: {
      return MakeUnique<ScaffoldingCallHandlerUniffiRemoteSettingsFnMethodRemotesettingsserviceUpdateConfig>();
    }
    case 32: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSearchFnConstructorSearchengineselectorNew>();
    }
    case 33: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSearchFnMethodSearchengineselectorClearSearchConfig>();
    }
    case 34: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSearchFnMethodSearchengineselectorFilterEngineConfiguration>();
    }
    case 35: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSearchFnMethodSearchengineselectorSetConfigOverrides>();
    }
    case 36: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSearchFnMethodSearchengineselectorSetSearchConfig>();
    }
    case 37: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSearchFnMethodSearchengineselectorUseRemoteSettingsServer>();
    }
    case 38: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnFuncRawSuggestionUrlMatches>();
    }
    case 39: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnConstructorSuggeststoreNew>();
    }
    case 40: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreAnyDismissedSuggestions>();
    }
    case 41: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreClear>();
    }
    case 42: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreClearDismissedSuggestions>();
    }
    case 43: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreDismissByKey>();
    }
    case 44: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreDismissBySuggestion>();
    }
    case 45: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreDismissSuggestion>();
    }
    case 46: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreFetchGeonameAlternates>();
    }
    case 47: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreFetchGeonames>();
    }
    case 48: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreFetchGlobalConfig>();
    }
    case 49: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreFetchProviderConfig>();
    }
    case 50: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreIngest>();
    }
    case 51: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreInterrupt>();
    }
    case 52: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreIsDismissedByKey>();
    }
    case 53: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreIsDismissedBySuggestion>();
    }
    case 54: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreQuery>();
    }
    case 55: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststoreQueryWithMetrics>();
    }
    case 56: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnConstructorSuggeststorebuilderNew>();
    }
    case 57: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderBuild>();
    }
    case 58: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderCachePath>();
    }
    case 59: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderDataPath>();
    }
    case 60: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderLoadExtension>();
    }
    case 61: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderRemoteSettingsBucketName>();
    }
    case 62: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderRemoteSettingsServer>();
    }
    case 63: {
      return MakeUnique<ScaffoldingCallHandlerUniffiSuggestFnMethodSuggeststorebuilderRemoteSettingsService>();
    }
    case 64: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodRemotecommandstoreAddRemoteCommand>();
    }
    case 65: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodRemotecommandstoreAddRemoteCommandAt>();
    }
    case 66: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodRemotecommandstoreGetUnsentCommands>();
    }
    case 67: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodRemotecommandstoreRemoveRemoteCommand>();
    }
    case 68: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodRemotecommandstoreSetPendingCommandSent>();
    }
    case 69: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineApply>();
    }
    case 70: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineEnsureCurrentSyncId>();
    }
    case 71: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineLastSync>();
    }
    case 72: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedenginePrepareForSync>();
    }
    case 73: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineReset>();
    }
    case 74: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineResetSyncId>();
    }
    case 75: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineSetLastSync>();
    }
    case 76: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineSetUploaded>();
    }
    case 77: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineStoreIncoming>();
    }
    case 78: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineSyncFinished>();
    }
    case 79: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineSyncId>();
    }
    case 80: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineSyncStarted>();
    }
    case 81: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsbridgedengineWipe>();
    }
    case 82: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnConstructorTabsstoreNew>();
    }
    case 83: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreBridgedEngine>();
    }
    case 84: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreCloseConnection>();
    }
    case 85: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreGetAll>();
    }
    case 86: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreNewRemoteCommandStore>();
    }
    case 87: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreRegisterWithSyncManager>();
    }
    case 88: {
      return MakeUnique<ScaffoldingCallHandlerUniffiTabsFnMethodTabsstoreSetLocalTabs>();
    }
    case 89: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineApply>();
    }
    case 90: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineEnsureCurrentSyncId>();
    }
    case 91: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineLastSync>();
    }
    case 92: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedenginePrepareForSync>();
    }
    case 93: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineReset>();
    }
    case 94: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineResetSyncId>();
    }
    case 95: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineSetLastSync>();
    }
    case 96: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineSetUploaded>();
    }
    case 97: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineStoreIncoming>();
    }
    case 98: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineSyncFinished>();
    }
    case 99: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineSyncId>();
    }
    case 100: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineSyncStarted>();
    }
    case 101: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragebridgedengineWipe>();
    }
    case 102: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnConstructorWebextstoragestoreNew>();
    }
    case 103: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreBridgedEngine>();
    }
    case 104: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreClear>();
    }
    case 105: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreClose>();
    }
    case 106: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreGet>();
    }
    case 107: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreGetBytesInUse>();
    }
    case 108: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreGetSyncedChanges>();
    }
    case 109: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreRemove>();
    }
    case 110: {
      return MakeUnique<ScaffoldingCallHandlerUniffiWebextStorageFnMethodWebextstoragestoreSet>();
    }

#ifdef MOZ_UNIFFI_FIXTURES
    case 125: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncCloneInterface>();
    }
    case 126: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncFuncWithDefault>();
    }
    case 127: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncFuncWithError>();
    }
    case 128: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncFuncWithFlatError>();
    }
    case 129: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncFuncWithMultiWordArg>();
    }
    case 130: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncInvokeTestCallbackInterfaceMethod>();
    }
    case 131: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripBool>();
    }
    case 132: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripComplexCompound>();
    }
    case 133: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripComplexEnum>();
    }
    case 134: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripComplexRec>();
    }
    case 135: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripCustomType>();
    }
    case 136: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripEnumNoData>();
    }
    case 137: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripEnumWithData>();
    }
    case 138: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripF32>();
    }
    case 139: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripF64>();
    }
    case 140: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripHashMap>();
    }
    case 141: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripI16>();
    }
    case 142: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripI32>();
    }
    case 143: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripI64>();
    }
    case 144: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripI8>();
    }
    case 145: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripOption>();
    }
    case 146: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripSimpleRec>();
    }
    case 147: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripString>();
    }
    case 148: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripU16>();
    }
    case 149: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripU32>();
    }
    case 150: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripU64>();
    }
    case 151: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripU8>();
    }
    case 152: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncRoundtripVec>();
    }
    case 153: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncSumWithManyTypes>();
    }
    case 154: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncSwapTestInterfaces>();
    }
    case 155: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncTestFunc>();
    }
    case 156: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnConstructorTestinterfaceNew>();
    }
    case 157: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodTestinterfaceGetValue>();
    }
    case 158: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodTestinterfaceRefCount>();
    }
    case 159: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnConstructorAsyncinterfaceNew>();
    }
    case 161: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnConstructorComplexmethodsNew>();
    }
    case 162: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodComplexmethodsMethodWithDefault>();
    }
    case 163: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodComplexmethodsMethodWithMultiWordArg>();
    }
    case 164: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsExternalTypesFnFuncRoundtripExtCustomType>();
    }
    case 165: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsExternalTypesFnFuncRoundtripExtEnum>();
    }
    case 166: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsExternalTypesFnFuncRoundtripExtInterface>();
    }
    case 167: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsExternalTypesFnFuncRoundtripExtRecord>();
    }
#endif /* MOZ_UNIFFI_FIXTURES */

    default:
      return nullptr;
  }
}

UniquePtr<UniffiAsyncCallHandler> GetAsyncCallHandler(uint64_t aId) {
  switch (aId) {


#ifdef MOZ_UNIFFI_FIXTURES
    case 111: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripF32>();
    }
    case 112: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripF64>();
    }
    case 113: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripI16>();
    }
    case 114: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripI32>();
    }
    case 115: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripI64>();
    }
    case 116: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripI8>();
    }
    case 117: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripMap>();
    }
    case 118: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripObj>();
    }
    case 119: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripString>();
    }
    case 120: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripU16>();
    }
    case 121: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripU32>();
    }
    case 122: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripU64>();
    }
    case 123: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripU8>();
    }
    case 124: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnFuncAsyncRoundtripVec>();
    }
    case 160: {
      return MakeUnique<ScaffoldingCallHandlerUniffiUniffiBindingsTestsFnMethodAsyncinterfaceName>();
    }
#endif /* MOZ_UNIFFI_FIXTURES */

    default:
      return nullptr;
  }
}
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */

// Callback interface method handlers, vtables, etc.

static StaticRefPtr<dom::UniFFICallbackHandler> gUniffiCallbackHandlerContextIdCallback;

class CallbackInterfaceMethodContextIdContextIdCallbackPersist : public UniffiCallbackMethodHandlerBase {
private:
  // Rust arguments
  FfiValueRustBuffer mContextId{};
  FfiValueInt<int64_t> mCreationDate{};

public:
  CallbackInterfaceMethodContextIdContextIdCallbackPersist(uint64_t aUniffiHandle, RustBuffer aContextId, int64_t aCreationDate)
    : UniffiCallbackMethodHandlerBase("ContextIdCallback", aUniffiHandle), mContextId(FfiValueRustBuffer::FromRust(aContextId)), mCreationDate(FfiValueInt<int64_t>::FromRust(aCreationDate)) {
  }

  MOZ_CAN_RUN_SCRIPT
  void MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;

    // Setup
    if (!uniffiArgs.AppendElements(2, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return;
    }

    // Convert each argument
    mContextId.Lift(
      aCx,
      &uniffiArgs[0],
      aError);
    if (aError.Failed()) {
        return;
    }
    mCreationDate.Lift(
      aCx,
      &uniffiArgs[1],
      aError);
    if (aError.Failed()) {
        return;
    }

    // Stores the return value.  For now, we currently don't do anything with it, since we only support
    // fire-and-forget callbacks.
    NullableRootedUnion<dom::OwningUniFFIScaffoldingValue> returnValue(aCx);
    // Make the call
    aJsHandler->Call(mUniffiHandle.IntoRust(), 0, uniffiArgs, returnValue, aError);
  }
};

extern "C" void callback_interface_context_id_context_id_callback_persist(
    uint64_t aUniffiHandle,
    RustBuffer aContextId,
    int64_t aCreationDate,
    void* aUniffiOutReturn,
    RustCallStatus* uniffiOutStatus
) {
  UniquePtr<UniffiCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodContextIdContextIdCallbackPersist>(aUniffiHandle, aContextId, aCreationDate);
  // Note: currently we only support queueing fire-and-forget async callbacks

  // For fire-and-forget callbacks, we don't know if the method succeeds or not
  // since it's called later. uniffiCallStatus is initialized to a successful
  // state by the Rust code, so there's no need to modify it.
  UniffiCallbackMethodHandlerBase::FireAndForget(std::move(handler), &gUniffiCallbackHandlerContextIdCallback);
}

class CallbackInterfaceMethodContextIdContextIdCallbackRotated : public UniffiCallbackMethodHandlerBase {
private:
  // Rust arguments
  FfiValueRustBuffer mOldContextId{};

public:
  CallbackInterfaceMethodContextIdContextIdCallbackRotated(uint64_t aUniffiHandle, RustBuffer aOldContextId)
    : UniffiCallbackMethodHandlerBase("ContextIdCallback", aUniffiHandle), mOldContextId(FfiValueRustBuffer::FromRust(aOldContextId)) {
  }

  MOZ_CAN_RUN_SCRIPT
  void MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;

    // Setup
    if (!uniffiArgs.AppendElements(1, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return;
    }

    // Convert each argument
    mOldContextId.Lift(
      aCx,
      &uniffiArgs[0],
      aError);
    if (aError.Failed()) {
        return;
    }

    // Stores the return value.  For now, we currently don't do anything with it, since we only support
    // fire-and-forget callbacks.
    NullableRootedUnion<dom::OwningUniFFIScaffoldingValue> returnValue(aCx);
    // Make the call
    aJsHandler->Call(mUniffiHandle.IntoRust(), 1, uniffiArgs, returnValue, aError);
  }
};

extern "C" void callback_interface_context_id_context_id_callback_rotated(
    uint64_t aUniffiHandle,
    RustBuffer aOldContextId,
    void* aUniffiOutReturn,
    RustCallStatus* uniffiOutStatus
) {
  UniquePtr<UniffiCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodContextIdContextIdCallbackRotated>(aUniffiHandle, aOldContextId);
  // Note: currently we only support queueing fire-and-forget async callbacks

  // For fire-and-forget callbacks, we don't know if the method succeeds or not
  // since it's called later. uniffiCallStatus is initialized to a successful
  // state by the Rust code, so there's no need to modify it.
  UniffiCallbackMethodHandlerBase::FireAndForget(std::move(handler), &gUniffiCallbackHandlerContextIdCallback);
}

extern "C" void callback_free_context_id_context_id_callback(uint64_t uniffiHandle) {
  // Callback object handles are keys in a map stored in the JS handler. To
  // handle the free call, make a call into JS which will remove the key.
  // Fire-and-forget is perfect for this.
  UniffiCallbackMethodHandlerBase::FireAndForget(MakeUnique<UniffiCallbackFreeHandler>("ContextIdCallback", uniffiHandle), &gUniffiCallbackHandlerContextIdCallback);
}

static VTableCallbackInterfaceContextIdCallback kUniffiVtableContextIdCallback {
  callback_interface_context_id_context_id_callback_persist,
  callback_interface_context_id_context_id_callback_rotated,
  callback_free_context_id_context_id_callback
};
static StaticRefPtr<dom::UniFFICallbackHandler> gUniffiCallbackHandlerApplicationErrorReporter;

class CallbackInterfaceMethodErrorsupportApplicationErrorReporterReportError : public UniffiCallbackMethodHandlerBase {
private:
  // Rust arguments
  FfiValueRustBuffer mTypeName{};
  FfiValueRustBuffer mMessage{};

public:
  CallbackInterfaceMethodErrorsupportApplicationErrorReporterReportError(uint64_t aUniffiHandle, RustBuffer aTypeName, RustBuffer aMessage)
    : UniffiCallbackMethodHandlerBase("ApplicationErrorReporter", aUniffiHandle), mTypeName(FfiValueRustBuffer::FromRust(aTypeName)), mMessage(FfiValueRustBuffer::FromRust(aMessage)) {
  }

  MOZ_CAN_RUN_SCRIPT
  void MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;

    // Setup
    if (!uniffiArgs.AppendElements(2, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return;
    }

    // Convert each argument
    mTypeName.Lift(
      aCx,
      &uniffiArgs[0],
      aError);
    if (aError.Failed()) {
        return;
    }
    mMessage.Lift(
      aCx,
      &uniffiArgs[1],
      aError);
    if (aError.Failed()) {
        return;
    }

    // Stores the return value.  For now, we currently don't do anything with it, since we only support
    // fire-and-forget callbacks.
    NullableRootedUnion<dom::OwningUniFFIScaffoldingValue> returnValue(aCx);
    // Make the call
    aJsHandler->Call(mUniffiHandle.IntoRust(), 0, uniffiArgs, returnValue, aError);
  }
};

extern "C" void callback_interface_errorsupport_application_error_reporter_report_error(
    uint64_t aUniffiHandle,
    RustBuffer aTypeName,
    RustBuffer aMessage,
    void* aUniffiOutReturn,
    RustCallStatus* uniffiOutStatus
) {
  UniquePtr<UniffiCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodErrorsupportApplicationErrorReporterReportError>(aUniffiHandle, aTypeName, aMessage);
  // Note: currently we only support queueing fire-and-forget async callbacks

  // For fire-and-forget callbacks, we don't know if the method succeeds or not
  // since it's called later. uniffiCallStatus is initialized to a successful
  // state by the Rust code, so there's no need to modify it.
  UniffiCallbackMethodHandlerBase::FireAndForget(std::move(handler), &gUniffiCallbackHandlerApplicationErrorReporter);
}

class CallbackInterfaceMethodErrorsupportApplicationErrorReporterReportBreadcrumb : public UniffiCallbackMethodHandlerBase {
private:
  // Rust arguments
  FfiValueRustBuffer mMessage{};
  FfiValueRustBuffer mModule{};
  FfiValueInt<uint32_t> mLine{};
  FfiValueInt<uint32_t> mColumn{};

public:
  CallbackInterfaceMethodErrorsupportApplicationErrorReporterReportBreadcrumb(uint64_t aUniffiHandle, RustBuffer aMessage, RustBuffer aModule, uint32_t aLine, uint32_t aColumn)
    : UniffiCallbackMethodHandlerBase("ApplicationErrorReporter", aUniffiHandle), mMessage(FfiValueRustBuffer::FromRust(aMessage)), mModule(FfiValueRustBuffer::FromRust(aModule)), mLine(FfiValueInt<uint32_t>::FromRust(aLine)), mColumn(FfiValueInt<uint32_t>::FromRust(aColumn)) {
  }

  MOZ_CAN_RUN_SCRIPT
  void MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;

    // Setup
    if (!uniffiArgs.AppendElements(4, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return;
    }

    // Convert each argument
    mMessage.Lift(
      aCx,
      &uniffiArgs[0],
      aError);
    if (aError.Failed()) {
        return;
    }
    mModule.Lift(
      aCx,
      &uniffiArgs[1],
      aError);
    if (aError.Failed()) {
        return;
    }
    mLine.Lift(
      aCx,
      &uniffiArgs[2],
      aError);
    if (aError.Failed()) {
        return;
    }
    mColumn.Lift(
      aCx,
      &uniffiArgs[3],
      aError);
    if (aError.Failed()) {
        return;
    }

    // Stores the return value.  For now, we currently don't do anything with it, since we only support
    // fire-and-forget callbacks.
    NullableRootedUnion<dom::OwningUniFFIScaffoldingValue> returnValue(aCx);
    // Make the call
    aJsHandler->Call(mUniffiHandle.IntoRust(), 1, uniffiArgs, returnValue, aError);
  }
};

extern "C" void callback_interface_errorsupport_application_error_reporter_report_breadcrumb(
    uint64_t aUniffiHandle,
    RustBuffer aMessage,
    RustBuffer aModule,
    uint32_t aLine,
    uint32_t aColumn,
    void* aUniffiOutReturn,
    RustCallStatus* uniffiOutStatus
) {
  UniquePtr<UniffiCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodErrorsupportApplicationErrorReporterReportBreadcrumb>(aUniffiHandle, aMessage, aModule, aLine, aColumn);
  // Note: currently we only support queueing fire-and-forget async callbacks

  // For fire-and-forget callbacks, we don't know if the method succeeds or not
  // since it's called later. uniffiCallStatus is initialized to a successful
  // state by the Rust code, so there's no need to modify it.
  UniffiCallbackMethodHandlerBase::FireAndForget(std::move(handler), &gUniffiCallbackHandlerApplicationErrorReporter);
}

extern "C" void callback_free_errorsupport_application_error_reporter(uint64_t uniffiHandle) {
  // Callback object handles are keys in a map stored in the JS handler. To
  // handle the free call, make a call into JS which will remove the key.
  // Fire-and-forget is perfect for this.
  UniffiCallbackMethodHandlerBase::FireAndForget(MakeUnique<UniffiCallbackFreeHandler>("ApplicationErrorReporter", uniffiHandle), &gUniffiCallbackHandlerApplicationErrorReporter);
}

static VTableCallbackInterfaceApplicationErrorReporter kUniffiVtableApplicationErrorReporter {
  callback_interface_errorsupport_application_error_reporter_report_error,
  callback_interface_errorsupport_application_error_reporter_report_breadcrumb,
  callback_free_errorsupport_application_error_reporter
};

#ifdef MOZ_UNIFFI_FIXTURES
static StaticRefPtr<dom::UniFFICallbackHandler> gUniffiCallbackHandlerTestCallbackInterface;

class CallbackInterfaceMethodUniffiBindingsTestsTestCallbackInterfaceGetValue : public UniffiCallbackMethodHandlerBase {
private:
  // Rust arguments

public:
  CallbackInterfaceMethodUniffiBindingsTestsTestCallbackInterfaceGetValue(uint64_t aUniffiHandle)
    : UniffiCallbackMethodHandlerBase("TestCallbackInterface", aUniffiHandle) {
  }

  MOZ_CAN_RUN_SCRIPT
  void MakeCall(JSContext* aCx, dom::UniFFICallbackHandler* aJsHandler, ErrorResult& aError) override {
    nsTArray<dom::OwningUniFFIScaffoldingValue> uniffiArgs;

    // Setup
    if (!uniffiArgs.AppendElements(0, mozilla::fallible)) {
      aError.Throw(NS_ERROR_OUT_OF_MEMORY);
      return;
    }

    // Convert each argument

    // Stores the return value.  For now, we currently don't do anything with it, since we only support
    // fire-and-forget callbacks.
    NullableRootedUnion<dom::OwningUniFFIScaffoldingValue> returnValue(aCx);
    // Make the call
    aJsHandler->Call(mUniffiHandle.IntoRust(), 0, uniffiArgs, returnValue, aError);
  }
};

extern "C" void callback_interface_uniffi_bindings_tests_test_callback_interface_get_value(
    uint64_t aUniffiHandle,
    uint32_t* aUniffiOutReturn,
    RustCallStatus* uniffiOutStatus
) {
  UniquePtr<UniffiCallbackMethodHandlerBase> handler = MakeUnique<CallbackInterfaceMethodUniffiBindingsTestsTestCallbackInterfaceGetValue>(aUniffiHandle);
  // Note: currently we only support queueing fire-and-forget async callbacks

  // For fire-and-forget callbacks, we don't know if the method succeeds or not
  // since it's called later. uniffiCallStatus is initialized to a successful
  // state by the Rust code, so there's no need to modify it.
  UniffiCallbackMethodHandlerBase::FireAndForget(std::move(handler), &gUniffiCallbackHandlerTestCallbackInterface);
}

extern "C" void callback_free_uniffi_bindings_tests_test_callback_interface(uint64_t uniffiHandle) {
  // Callback object handles are keys in a map stored in the JS handler. To
  // handle the free call, make a call into JS which will remove the key.
  // Fire-and-forget is perfect for this.
  UniffiCallbackMethodHandlerBase::FireAndForget(MakeUnique<UniffiCallbackFreeHandler>("TestCallbackInterface", uniffiHandle), &gUniffiCallbackHandlerTestCallbackInterface);
}

static VTableCallbackInterfaceTestCallbackInterface kUniffiVtableTestCallbackInterface {
  callback_interface_uniffi_bindings_tests_test_callback_interface_get_value,
  callback_free_uniffi_bindings_tests_test_callback_interface
};
#endif /* MOZ_UNIFFI_FIXTURES */

void RegisterCallbackHandler(uint64_t aInterfaceId, UniFFICallbackHandler& aCallbackHandler, ErrorResult& aError) {
  switch (aInterfaceId) {
    
    case 1: {
      if (gUniffiCallbackHandlerContextIdCallback) {
        aError.ThrowUnknownError("[UniFFI] Callback handler already registered for ContextIdCallback"_ns);
        return;
      }

      gUniffiCallbackHandlerContextIdCallback = &aCallbackHandler;
      uniffi_context_id_fn_init_callback_vtable_contextidcallback(&kUniffiVtableContextIdCallback);
      break;
    }
    case 2: {
      if (gUniffiCallbackHandlerApplicationErrorReporter) {
        aError.ThrowUnknownError("[UniFFI] Callback handler already registered for ApplicationErrorReporter"_ns);
        return;
      }

      gUniffiCallbackHandlerApplicationErrorReporter = &aCallbackHandler;
      uniffi_error_support_fn_init_callback_vtable_applicationerrorreporter(&kUniffiVtableApplicationErrorReporter);
      break;
    }
    
    #ifdef MOZ_UNIFFI_FIXTURES
    case 3: {
      if (gUniffiCallbackHandlerTestCallbackInterface) {
        aError.ThrowUnknownError("[UniFFI] Callback handler already registered for TestCallbackInterface"_ns);
        return;
      }

      gUniffiCallbackHandlerTestCallbackInterface = &aCallbackHandler;
      uniffi_uniffi_bindings_tests_fn_init_callback_vtable_testcallbackinterface(&kUniffiVtableTestCallbackInterface);
      break;
    }
    #endif /* MOZ_UNIFFI_FIXTURES */

    default:
      aError.ThrowUnknownError(nsPrintfCString("RegisterCallbackHandler: Unknown callback interface id (%" PRIu64 ")", aInterfaceId));
      return;
  }
}

void DeregisterCallbackHandler(uint64_t aInterfaceId, ErrorResult& aError) {
  switch (aInterfaceId) {
    
    case 1: {
      if (!gUniffiCallbackHandlerContextIdCallback) {
        aError.ThrowUnknownError("[UniFFI] Callback handler not registered for ContextIdCallback"_ns);
        return;
      }

      gUniffiCallbackHandlerContextIdCallback = nullptr;
      break;
    }
    case 2: {
      if (!gUniffiCallbackHandlerApplicationErrorReporter) {
        aError.ThrowUnknownError("[UniFFI] Callback handler not registered for ApplicationErrorReporter"_ns);
        return;
      }

      gUniffiCallbackHandlerApplicationErrorReporter = nullptr;
      break;
    }
    
    #ifdef MOZ_UNIFFI_FIXTURES
    case 3: {
      if (!gUniffiCallbackHandlerTestCallbackInterface) {
        aError.ThrowUnknownError("[UniFFI] Callback handler not registered for TestCallbackInterface"_ns);
        return;
      }

      gUniffiCallbackHandlerTestCallbackInterface = nullptr;
      break;
    }
    #endif /* MOZ_UNIFFI_FIXTURES */

    default:
      aError.ThrowUnknownError(nsPrintfCString("DeregisterCallbackHandler: Unknown callback interface id (%" PRIu64 ")", aInterfaceId));
      return;
  }
}

}  // namespace mozilla::uniffi
