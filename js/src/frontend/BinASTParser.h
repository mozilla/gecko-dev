// This file was autogenerated by binjs_generate_spidermonkey,
// please DO NOT EDIT BY HAND.
/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 * vim: set ts=8 sts=2 et sw=2 tw=80:
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

// To generate this file, see the documentation in
// js/src/frontend/binsource/README.md.

#ifndef frontend_BinASTParser_h
#define frontend_BinASTParser_h

#include "mozilla/Maybe.h"

#include "frontend/BCEParserHandle.h"
#include "frontend/BinASTParserPerTokenizer.h"
#include "frontend/BinToken.h"
#include "frontend/BinTokenReaderMultipart.h"
#include "frontend/BinTokenReaderTester.h"
#include "frontend/FullParseHandler.h"
#include "frontend/ParseContext.h"
#include "frontend/ParseNode.h"
#include "frontend/SharedContext.h"

#include "js/CompileOptions.h"
#include "js/GCHashTable.h"
#include "js/GCVector.h"
#include "js/Result.h"

namespace js {
namespace frontend {

template <typename Tok>
class BinASTParser : public BinASTParserPerTokenizer<Tok> {
 public:
  using Base = BinASTParserPerTokenizer<Tok>;

  using Tokenizer = Tok;

  using BinFields = typename Tokenizer::BinFields;
  using AutoList = typename Tokenizer::AutoList;
  using AutoTaggedTuple = typename Tokenizer::AutoTaggedTuple;
  using AutoTuple = typename Tokenizer::AutoTuple;
  using Chars = typename Tokenizer::Chars;

 public:
  // Auto-generated types.
  using AssertedDeclaredKind = binast::AssertedDeclaredKind;
  using BinaryOperator = binast::BinaryOperator;
  using CompoundAssignmentOperator = binast::CompoundAssignmentOperator;
  using UnaryOperator = binast::UnaryOperator;
  using UpdateOperator = binast::UpdateOperator;
  using VariableDeclarationKind = binast::VariableDeclarationKind;

 public:
  // BinASTParserPerTokenizer types.
  using AssertedScopeKind = typename Base::AssertedScopeKind;

 public:
  BinASTParser(JSContext* cx, LifoAlloc& alloc, UsedNameTracker& usedNames,
               const JS::ReadOnlyCompileOptions& options,
               HandleScriptSourceObject sourceObject,
               Handle<LazyScript*> lazyScript = nullptr)
      : BinASTParserPerTokenizer<Tok>(cx, alloc, usedNames, options,
                                      sourceObject, lazyScript) {}
  ~BinASTParser() {}

 protected:
  // BinASTParserBase fields.
  using Base::cx_;

  using Base::alloc_;
  using Base::usedNames_;

  using Base::factory_;
  using Base::parseContext_;
  using Base::sourceObject_;

 protected:
  // BinASTParserPerTokenizer types.
  using AutoVariableDeclarationKind =
      typename Base::AutoVariableDeclarationKind;

 protected:
  // BinASTParserPerTokenizer fields.
  using Base::tokenizer_;
  using Base::variableDeclarationKind_;

 protected:
  // BinASTParserPerTokenizer methods.
  using Base::raiseEmpty;
  using Base::raiseError;
  using Base::raiseInvalidClosedVar;
  using Base::raiseInvalidKind;
  using Base::raiseInvalidVariant;
  using Base::raiseMissingDirectEvalInAssertedScope;
  using Base::raiseMissingField;
  using Base::raiseMissingVariableInAssertedScope;
  using Base::raiseOOM;

  using Base::addScopeName;
  using Base::buildFunction;
  using Base::buildFunctionBox;
  using Base::captureFunctionName;
  using Base::makeEmptyFunctionNode;

  using Base::checkBinding;
  using Base::checkPositionalParameterIndices;
  using Base::getBoundScope;
  using Base::getDeclaredScope;

  using Base::checkClosedVars;
  using Base::checkFunctionLength;

  using Base::prependDirectivesToBody;

  using Base::forceStrictIfNecessary;

 public:
  // ----- Sums of interfaces (by lexicographical order)
  // `ParseNode*` may never be nullptr
  JS::Result<Ok> parseAssertedMaybePositionalParameterName(
      AssertedScopeKind scopeKind,
      MutableHandle<GCVector<JSAtom*>> positionalParams);
  JS::Result<ParseNode*> parseAssignmentTarget();
  JS::Result<ParseNode*> parseBinding();
  JS::Result<ParseNode*> parseExpression();
  JS::Result<ParseNode*> parseExpressionOrSuper();
  JS::Result<ParseNode*> parseForInOfBindingOrAssignmentTarget();
  JS::Result<ParseNode*> parseObjectProperty();
  JS::Result<ParseNode*> parseParameter();
  JS::Result<ParseNode*> parseProgram();
  JS::Result<ParseNode*> parsePropertyName();
  JS::Result<ParseNode*> parseSimpleAssignmentTarget();
  JS::Result<ParseNode*> parseSpreadElementOrExpression();
  JS::Result<ParseNode*> parseStatement();
  JS::Result<Ok> parseSumAssertedMaybePositionalParameterName(
      const size_t start, const BinKind kind, const BinFields& fields,
      AssertedScopeKind scopeKind,
      MutableHandle<GCVector<JSAtom*>> positionalParams);
  JS::Result<ParseNode*> parseSumAssignmentTarget(const size_t start,
                                                  const BinKind kind,
                                                  const BinFields& fields);
  JS::Result<ParseNode*> parseSumBinding(const size_t start, const BinKind kind,
                                         const BinFields& fields);
  JS::Result<ParseNode*> parseSumExpression(const size_t start,
                                            const BinKind kind,
                                            const BinFields& fields);
  JS::Result<ParseNode*> parseSumExpressionOrSuper(const size_t start,
                                                   const BinKind kind,
                                                   const BinFields& fields);
  JS::Result<ParseNode*> parseSumForInOfBindingOrAssignmentTarget(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseSumObjectProperty(const size_t start,
                                                const BinKind kind,
                                                const BinFields& fields);
  JS::Result<ParseNode*> parseSumParameter(const size_t start,
                                           const BinKind kind,
                                           const BinFields& fields);
  JS::Result<ParseNode*> parseSumProgram(const size_t start, const BinKind kind,
                                         const BinFields& fields);
  JS::Result<ParseNode*> parseSumPropertyName(const size_t start,
                                              const BinKind kind,
                                              const BinFields& fields);
  JS::Result<ParseNode*> parseSumSimpleAssignmentTarget(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseSumSpreadElementOrExpression(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseSumStatement(const size_t start,
                                           const BinKind kind,
                                           const BinFields& fields);
  JS::Result<ParseNode*> parseSumVariableDeclarationOrExpression(
      const size_t start, const BinKind kind, const BinFields& fields);

  // ----- Interfaces (by lexicographical order)
  // `ParseNode*` may never be nullptr
  JS::Result<Ok> parseAssertedBlockScope();
  JS::Result<Ok> parseAssertedBoundName(AssertedScopeKind scopeKind);
  JS::Result<Ok> parseAssertedBoundNamesScope();
  JS::Result<Ok> parseAssertedDeclaredName(AssertedScopeKind scopeKind);
  JS::Result<Ok> parseAssertedParameterScope(
      MutableHandle<GCVector<JSAtom*>> positionalParams);
  JS::Result<Ok> parseAssertedScriptGlobalScope();
  JS::Result<Ok> parseAssertedVarScope();
  JS::Result<ParseNode*> parseBindingIdentifier();
  JS::Result<ParseNode*> parseBlock();
  JS::Result<LexicalScopeNode*> parseCatchClause();
  JS::Result<ParseNode*> parseDirective();
  JS::Result<ListNode*> parseFormalParameters();
  JS::Result<Ok> parseFunctionExpressionContents(uint32_t funLength,
                                                 ListNode** paramsOut,
                                                 ListNode** bodyOut);
  JS::Result<Ok> parseFunctionOrMethodContents(uint32_t funLength,
                                               ListNode** paramsOut,
                                               ListNode** bodyOut);
  JS::Result<Ok> parseGetterContents(uint32_t funLength, ListNode** paramsOut,
                                     ListNode** bodyOut);
  JS::Result<ParseNode*> parseIdentifierExpression();
  JS::Result<Ok> parseSetterContents(uint32_t funLength, ListNode** paramsOut,
                                     ListNode** bodyOut);
  JS::Result<CaseClause*> parseSwitchCase();
  JS::Result<ParseNode*> parseSwitchDefault();
  JS::Result<ParseNode*> parseVariableDeclarator();
  JS::Result<ParseNode*> parseInterfaceArrayAssignmentTarget(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceArrayBinding(const size_t start,
                                                    const BinKind kind,
                                                    const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceArrayExpression(const size_t start,
                                                       const BinKind kind,
                                                       const BinFields& fields);
  JS::Result<Ok> parseInterfaceAssertedBlockScope(const size_t start,
                                                  const BinKind kind,
                                                  const BinFields& fields);
  JS::Result<Ok> parseInterfaceAssertedBoundName(const size_t start,
                                                 const BinKind kind,
                                                 const BinFields& fields,
                                                 AssertedScopeKind scopeKind);
  JS::Result<Ok> parseInterfaceAssertedBoundNamesScope(const size_t start,
                                                       const BinKind kind,
                                                       const BinFields& fields);
  JS::Result<Ok> parseInterfaceAssertedDeclaredName(
      const size_t start, const BinKind kind, const BinFields& fields,
      AssertedScopeKind scopeKind);
  JS::Result<Ok> parseInterfaceAssertedParameterScope(
      const size_t start, const BinKind kind, const BinFields& fields,
      MutableHandle<GCVector<JSAtom*>> positionalParams);
  JS::Result<Ok> parseInterfaceAssertedPositionalParameterName(
      const size_t start, const BinKind kind, const BinFields& fields,
      AssertedScopeKind scopeKind,
      MutableHandle<GCVector<JSAtom*>> positionalParams);
  JS::Result<Ok> parseInterfaceAssertedScriptGlobalScope(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<Ok> parseInterfaceAssertedVarScope(const size_t start,
                                                const BinKind kind,
                                                const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceAssignmentExpression(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceAssignmentTargetIdentifier(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceAwaitExpression(const size_t start,
                                                       const BinKind kind,
                                                       const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceBinaryExpression(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceBindingIdentifier(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceBindingWithInitializer(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceBlock(const size_t start,
                                             const BinKind kind,
                                             const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceBreakStatement(const size_t start,
                                                      const BinKind kind,
                                                      const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceCallExpression(const size_t start,
                                                      const BinKind kind,
                                                      const BinFields& fields);
  JS::Result<LexicalScopeNode*> parseInterfaceCatchClause(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceClassDeclaration(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceClassExpression(const size_t start,
                                                       const BinKind kind,
                                                       const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceCompoundAssignmentExpression(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceComputedMemberAssignmentTarget(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceComputedMemberExpression(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceComputedPropertyName(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceConditionalExpression(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceContinueStatement(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceDataProperty(const size_t start,
                                                    const BinKind kind,
                                                    const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceDebuggerStatement(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceDirective(const size_t start,
                                                 const BinKind kind,
                                                 const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceDoWhileStatement(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceEagerArrowExpressionWithExpression(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceEagerArrowExpressionWithFunctionBody(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceEagerFunctionDeclaration(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceEagerFunctionExpression(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceEagerGetter(const size_t start,
                                                   const BinKind kind,
                                                   const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceEagerMethod(const size_t start,
                                                   const BinKind kind,
                                                   const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceEagerSetter(const size_t start,
                                                   const BinKind kind,
                                                   const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceEmptyStatement(const size_t start,
                                                      const BinKind kind,
                                                      const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceExpressionStatement(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceForInOfBinding(const size_t start,
                                                      const BinKind kind,
                                                      const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceForInStatement(const size_t start,
                                                      const BinKind kind,
                                                      const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceForOfStatement(const size_t start,
                                                      const BinKind kind,
                                                      const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceForStatement(const size_t start,
                                                    const BinKind kind,
                                                    const BinFields& fields);
  JS::Result<ListNode*> parseInterfaceFormalParameters(const size_t start,
                                                       const BinKind kind,
                                                       const BinFields& fields);
  JS::Result<Ok> parseInterfaceFunctionExpressionContents(
      const size_t start, const BinKind kind, const BinFields& fields,
      uint32_t funLength, ListNode** paramsOut, ListNode** bodyOut);
  JS::Result<Ok> parseInterfaceFunctionOrMethodContents(
      const size_t start, const BinKind kind, const BinFields& fields,
      uint32_t funLength, ListNode** paramsOut, ListNode** bodyOut);
  JS::Result<Ok> parseInterfaceGetterContents(
      const size_t start, const BinKind kind, const BinFields& fields,
      uint32_t funLength, ListNode** paramsOut, ListNode** bodyOut);
  JS::Result<ParseNode*> parseInterfaceIdentifierExpression(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceIfStatement(const size_t start,
                                                   const BinKind kind,
                                                   const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceLabelledStatement(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceLazyArrowExpressionWithExpression(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceLazyArrowExpressionWithFunctionBody(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceLazyFunctionDeclaration(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceLazyFunctionExpression(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceLazyGetter(const size_t start,
                                                  const BinKind kind,
                                                  const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceLazyMethod(const size_t start,
                                                  const BinKind kind,
                                                  const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceLazySetter(const size_t start,
                                                  const BinKind kind,
                                                  const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceLiteralBooleanExpression(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceLiteralInfinityExpression(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceLiteralNullExpression(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceLiteralNumericExpression(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceLiteralPropertyName(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceLiteralRegExpExpression(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceLiteralStringExpression(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceModule(const size_t start,
                                              const BinKind kind,
                                              const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceNewExpression(const size_t start,
                                                     const BinKind kind,
                                                     const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceNewTargetExpression(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceObjectAssignmentTarget(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceObjectBinding(const size_t start,
                                                     const BinKind kind,
                                                     const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceObjectExpression(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceReturnStatement(const size_t start,
                                                       const BinKind kind,
                                                       const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceScript(const size_t start,
                                              const BinKind kind,
                                              const BinFields& fields);
  JS::Result<Ok> parseInterfaceSetterContents(
      const size_t start, const BinKind kind, const BinFields& fields,
      uint32_t funLength, ListNode** paramsOut, ListNode** bodyOut);
  JS::Result<ParseNode*> parseInterfaceShorthandProperty(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceSpreadElement(const size_t start,
                                                     const BinKind kind,
                                                     const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceStaticMemberAssignmentTarget(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceStaticMemberExpression(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceSuper(const size_t start,
                                             const BinKind kind,
                                             const BinFields& fields);
  JS::Result<CaseClause*> parseInterfaceSwitchCase(const size_t start,
                                                   const BinKind kind,
                                                   const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceSwitchDefault(const size_t start,
                                                     const BinKind kind,
                                                     const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceSwitchStatement(const size_t start,
                                                       const BinKind kind,
                                                       const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceSwitchStatementWithDefault(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceTemplateExpression(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceThisExpression(const size_t start,
                                                      const BinKind kind,
                                                      const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceThrowStatement(const size_t start,
                                                      const BinKind kind,
                                                      const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceTryCatchStatement(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceTryFinallyStatement(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceUnaryExpression(const size_t start,
                                                       const BinKind kind,
                                                       const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceUpdateExpression(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceVariableDeclaration(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceVariableDeclarator(
      const size_t start, const BinKind kind, const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceWhileStatement(const size_t start,
                                                      const BinKind kind,
                                                      const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceWithStatement(const size_t start,
                                                     const BinKind kind,
                                                     const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceYieldExpression(const size_t start,
                                                       const BinKind kind,
                                                       const BinFields& fields);
  JS::Result<ParseNode*> parseInterfaceYieldStarExpression(
      const size_t start, const BinKind kind, const BinFields& fields);

  // ----- String enums (by lexicographical order)
  JS::Result<typename BinASTParser<Tok>::AssertedDeclaredKind>
  parseAssertedDeclaredKind();
  JS::Result<typename BinASTParser<Tok>::BinaryOperator> parseBinaryOperator();
  JS::Result<typename BinASTParser<Tok>::CompoundAssignmentOperator>
  parseCompoundAssignmentOperator();
  JS::Result<typename BinASTParser<Tok>::UnaryOperator> parseUnaryOperator();
  JS::Result<typename BinASTParser<Tok>::UpdateOperator> parseUpdateOperator();
  JS::Result<typename BinASTParser<Tok>::VariableDeclarationKind>
  parseVariableDeclarationKind();

  // ----- Lists (by lexicographical order)
  JS::Result<ParseNode*> parseArguments();
  JS::Result<ListNode*> parseFunctionBody();
  JS::Result<Ok> parseListOfAssertedBoundName(AssertedScopeKind scopeKind);
  JS::Result<Ok> parseListOfAssertedDeclaredName(AssertedScopeKind scopeKind);
  JS::Result<Ok> parseListOfAssertedMaybePositionalParameterName(
      AssertedScopeKind scopeKind,
      MutableHandle<GCVector<JSAtom*>> positionalParams);
  JS::Result<ListNode*> parseListOfDirective();
  JS::Result<ListNode*> parseListOfObjectProperty();
  JS::Result<ListNode*> parseListOfOptionalSpreadElementOrExpression();
  JS::Result<ListNode*> parseListOfParameter();
  JS::Result<ListNode*> parseListOfStatement();
  JS::Result<ListNode*> parseListOfSwitchCase();
  JS::Result<ListNode*> parseListOfVariableDeclarator();

  // ----- Default values (by lexicographical order)
  JS::Result<ParseNode*> parseOptionalBinding();
  JS::Result<ParseNode*> parseOptionalBindingIdentifier();
  JS::Result<LexicalScopeNode*> parseOptionalCatchClause();
  JS::Result<ParseNode*> parseOptionalExpression();
  JS::Result<ParseNode*> parseOptionalSpreadElementOrExpression();
  JS::Result<ParseNode*> parseOptionalStatement();
  JS::Result<ParseNode*> parseOptionalVariableDeclarationOrExpression();
};

extern template class BinASTParser<BinTokenReaderMultipart>;
extern template class BinASTParser<BinTokenReaderTester>;

}  // namespace frontend
}  // namespace js

#endif  // frontend_BinASTParser_h
