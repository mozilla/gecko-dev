<!DOCTYPE html>
<html>
<head>
  <title>Text Fragment Chrome-only API Test</title>
  <meta charset="UTF-8">
  <script src="/tests/SimpleTest/SimpleTest.js"></script>
  <link rel="stylesheet" type="text/css" href="/tests/SimpleTest/test.css" />
</head>
<body>
  <div id="abc">abc def ghi</div>
  <p id="block">p<span id="inlinespan">sp<span id="nestedinlinespan">a</span>n</span>p</p><span id="afterblockboundary">afterblockboundary</span>
  <div id="image"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAQAAAAnOwc2AAAAEUlEQVR42mNk+M+AARiHsiAAcCIKAYwFoQ8AAAAASUVORK5CYII="></div>
  <script>
    SimpleTest.waitForExplicitFinish();
    function rAF() {
      return new Promise(resolve => {
        requestAnimationFrame(resolve);
      });
    }
    /**
     * Helper function which is used by assertions below.
     * Returns true if the two ranges have the exact same start and end points.
     */
    function rangeBoundariesAreEqual(range1, range2) {
      const startContainerIsEqual = range1.startContainer.textContent === range2.startContainer.textContent;
      const endContainerIsEqual = range1.endContainer.textContent === range2.endContainer.textContent;

      const startOffsetIsEqual = range1.startOffset == range2.startOffset;
      const endOffsetIsEqual = range1.endOffset == range2.endOffset;
      return (
        startContainerIsEqual
        && endContainerIsEqual
        && startOffsetIsEqual
        && endOffsetIsEqual
      );
    }

    /**
     * Test for the `rangeBoundariesAreEqual()` helper function.
     */
    function testRangeBoundariesAreEqual() {
      const range1 = document.createRange();
      range1.setStart(abc.firstChild, 0);
      range1.setEnd(abc.firstChild, 3);
      const range2 = document.createRange();
      range2.setStart(abc.firstChild, 0);
      range2.setEnd(abc.firstChild, 3);

      ok(
        rangeBoundariesAreEqual(range1, range2),
        "Ranges should have the same boundary points when containers are text nodes"
      );

      const range3 = document.createRange();
      range3.selectNode(abc);
      const range4 = document.createRange();
      range4.selectNode(abc);
      ok(
        rangeBoundariesAreEqual(range3, range4),
        "Ranges should have the same boundary points when containers are nodes"
      );
    }

    async function basicTests() {
      for(let testCase of [
        {
          name: "Text directive is first string in the document",
          startContainer: abc.firstChild,
          startOffset: 0,
          endContainer: abc.firstChild,
          endOffset: 3,
          content: "abc",
          textDirective: "text=abc"
        },
        {
          name: "Text directive is the second word in the document",
          startContainer: abc.firstChild,
          startOffset: 4,
          endContainer: abc.firstChild,
          endOffset: 7,
          content: "def",
          textDirective: "text=def"
        },
        {
          name: "Text directive spans two words",
          startContainer: abc.firstChild,
          startOffset: 0,
          endContainer: abc.firstChild,
          endOffset: 7,
          content: "abc def",
          textDirective: "text=abc%20def"
        },
        {
          name: "Text directive crosses block boundary",
          startContainer: block.firstChild,
          startOffset: 0,
          endContainer: afterblockboundary.firstChild,
          endOffset: 18,
          content: "pspanpafterblockboundary",
          textDirective: "text=pspanp,afterblockboundary",
        },

      ]) {
        const range = document.createRange();
        range.setStart(testCase.startContainer, testCase.startOffset);
        range.setEnd(testCase.endContainer, testCase.endOffset);
        is(
          range.toString(), testCase.content,
          `${testCase.name}: Precondition - Range has expected value`
        );

        const textDirective = await SpecialPowers.wrap(document).fragmentDirective.createTextDirective(range);
        is(
          textDirective, testCase.textDirective,
          `${testCase.name}: text directive has expected value '${testCase.textDirective}'`
        );
        // load the page with the given text directive
        location.hash = `#:~:${textDirective}`;
        await rAF();

        // access the range from the loaded text directive and compare the boundary points
        ranges = SpecialPowers.wrap(document).fragmentDirective.getTextDirectiveRanges();
        is(
          ranges.length, 1,
          `${testCase.name}: There is one text fragment range on the document`
        );

        is(
          range.toString(), ranges[0].toString(),
          `${testCase.name}: Ranges have the same content '${ranges[0].toString()}'`
        );
        ok(
          rangeBoundariesAreEqual(range, ranges[0]),
          `${testCase.name}: Ranges have the same boundary points`
        );

        // finally, remove all text directives to clean up for the next test.
        SpecialPowers.wrap(document).fragmentDirective.removeAllTextDirectives();
      }
    }

    /**
     * Calling the API with an empty / collapsed range should
     * return an empty string, not an error.
     */
    async function testEmptyRange() {
      const range = document.createRange();
      let textDirective = await SpecialPowers.wrap(document).fragmentDirective.createTextDirective(range);
      is(
        textDirective, null,
        "Empty input range: Produces empty text directive"
      );
      range.selectNode(abc);
      range.collapse(true);
      textDirective = await SpecialPowers.wrap(document).fragmentDirective.createTextDirective(range);
      is(
        textDirective, null,
        "Collapsed input range: Produces empty text directive"
      );
      range.selectNode(image);
      textDirective = await SpecialPowers.wrap(document).fragmentDirective.createTextDirective(range);
      is(
        textDirective, null,
        "Input range contains image only: Produces empty text directive"
      );

    }

    async function testExpandRangeToWordBoundaries() {
      for (testCase of [
        {
          name: "Expanding single-word range to word boundaries (input is inside word)",
          startContainer: abc.firstChild,
          startOffset: 5,
          endContainer: abc.firstChild,
          endOffset: 6,
          outputStartContainer: abc.firstChild,
          outputStartOffset: 4,
          outputEndContainer: abc.firstChild,
          outputEndOffset: 7,
          content: "e",
          outputContent: "def",
          textDirective: "text=def"
        },
        {
          name: "Expanding single-word range to word boundaries (input is start of word)",
          startContainer: abc.firstChild,
          startOffset: 4,
          endContainer: abc.firstChild,
          endOffset: 5,
          outputStartContainer: abc.firstChild,
          outputStartOffset: 4,
          outputEndContainer: abc.firstChild,
          outputEndOffset: 7,
          content: "d",
          outputContent: "def",
          textDirective: "text=def"
        },
        {
          name: "Expanding single-word range to word boundaries (input is end of word)",
          startContainer: abc.firstChild,
          startOffset: 6,
          endContainer: abc.firstChild,
          endOffset: 7,
          outputStartContainer: abc.firstChild,
          outputStartOffset: 4,
          outputEndContainer: abc.firstChild,
          outputEndOffset: 7,
          content: "f",
          outputContent: "def",
          textDirective: "text=def"
        },
        {
          name: "Expanding multi-word range to word boundaries",
          startContainer: abc.firstChild,
          startOffset: 5,
          endContainer: abc.firstChild,
          endOffset: 9,
          outputStartContainer: abc.firstChild,
          outputStartOffset: 4,
          outputEndContainer: abc.firstChild,
          outputEndOffset: 11,
          content: "ef g",
          outputContent: "def ghi",
          textDirective: "text=def%20ghi"
        },
        {
          name: "Expanding inline-boundary word range to word boundaries",
          startContainer: nestedinlinespan.firstChild,
          startOffset: 0,
          endContainer: nestedinlinespan.firstChild,
          endOffset: 1,
          outputStartContainer: block.firstChild,
          outputStartOffset: 0,
          outputEndContainer: block.lastChild,
          outputEndOffset: 1,
          content: "a",
          outputContent: "pspanp",
          textDirective: "text=pspanp"
        },
      ]) {

        const range = document.createRange();
        range.setStart(testCase.startContainer, testCase.startOffset);
        range.setEnd(testCase.endContainer, testCase.endOffset);
        is(
          range.toString(), testCase.content,
          `${testCase.name}: Precondition - Range has expected value`
        );

        const textDirective = await SpecialPowers.wrap(document).fragmentDirective.createTextDirective(range);
        is(
          textDirective, testCase.textDirective,
          `${testCase.name}: text directive has expected value '${textDirective}'`
        );
        // load the page with the given text directive
        location.hash = `#:~:${textDirective}`;
        await rAF();

        // access the range from the loaded text directive and compare the boundary points
        ranges = SpecialPowers.wrap(document).fragmentDirective.getTextDirectiveRanges();
        const expectedRange = document.createRange();
        expectedRange.setStart(testCase.outputStartContainer, testCase.outputStartOffset);
        expectedRange.setEnd(testCase.outputEndContainer, testCase.outputEndOffset);
        is(
          expectedRange.toString(), ranges[0].toString(),
          `${testCase.name}: Ranges have the same content '${ranges[0].toString()}'`
        );
        ok(
          rangeBoundariesAreEqual(expectedRange, ranges[0]),
          `${testCase.name}: Ranges have the same boundary points`
        );

        // finally, remove all text directives to clean up for the next test.
        SpecialPowers.wrap(document).fragmentDirective.removeAllTextDirectives();
        location.hash = "";
      }
    }

    async function runTests() {
      try {
        await SpecialPowers.pushPrefEnv({"set": [
        ["dom.text_fragments.enabled", true],
        ["dom.text_fragments.create_text_fragment.enabled", true],
      ]});
        testRangeBoundariesAreEqual();
        await basicTests();
        await testEmptyRange();
        await testExpandRangeToWordBoundaries();

    }
    finally {
      SimpleTest.finish();
    }
  }

  document.body.onload = runTests;
  </script>
</body>
</html>
