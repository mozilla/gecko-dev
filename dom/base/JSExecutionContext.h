/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
/* vim: set ts=8 sts=2 et sw=2 tw=80: */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#ifndef DOM_BASE_JSEXECUTIONCONTEXT_H_
#define DOM_BASE_JSEXECUTIONCONTEXT_H_

#include "js/GCVector.h"
#include "js/TypeDecls.h"
#include "js/Value.h"
#include "js/experimental/JSStencil.h"
#include "jsapi.h"
#include "mozilla/Assertions.h"
#include "mozilla/Attributes.h"
#include "mozilla/ErrorResult.h"
#include "mozilla/ProfilerLabels.h"
#include "mozilla/Vector.h"
#include "nsStringFwd.h"
#include "nscore.h"

class nsIScriptContext;
class nsIScriptElement;
class nsIScriptGlobalObject;
class nsXBLPrototypeBinding;

namespace mozilla {
union Utf8Unit;

namespace dom {

class ScriptLoadContext;

nsresult EvaluationExceptionToNSResult(ErrorResult& aRv);

class MOZ_STACK_CLASS JSExecutionContext final {
  // Debug Metadata: Values managed for the benefit of the debugger when
  // inspecting code.
  //
  // For more details see CompilationAndEvaluation.h, and the comments on
  // UpdateDebugMetadata
  JS::Rooted<JS::Value> mDebuggerPrivateValue;
  JS::Rooted<JSScript*> mDebuggerIntroductionScript;

  RefPtr<JS::Stencil> mStencil;

  // Used to skip upcoming phases in case of a failure.  In such case the
  // result is carried by mRv.
  bool mSkip;

  bool mKeepStencil = false;

 private:
  // Compile a script contained in a SourceText.
  template <typename Unit>
  void InternalCompile(JSContext* aCx, JS::CompileOptions& aCompileOptions,
                       JS::SourceText<Unit>& aSrcBuf,
                       JS::MutableHandle<JSScript*> aScript,
                       bool aEncodeBytecode, ErrorResult& aRv);

 public:
  // Enter compartment in which the code would be executed.  The JSContext
  // must come from an AutoEntryScript.
  //
  // The JS engine can associate metadata for the debugger with scripts at
  // compile time. The optional last arguments here cover that metadata.
  JSExecutionContext(
      JSContext* aCx, JS::Handle<JSObject*> aGlobal,
      JS::CompileOptions& aCompileOptions, ErrorResult& aRv,
      JS::Handle<JS::Value> aDebuggerPrivateValue = JS::UndefinedHandleValue,
      JS::Handle<JSScript*> aDebuggerIntroductionScript = nullptr);

  JSExecutionContext(const JSExecutionContext&) = delete;
  JSExecutionContext(JSExecutionContext&&) = delete;

  ~JSExecutionContext() {
    // This flag is reset when the returned value is extracted.
    // MOZ_ASSERT_IF(!mSkip, !mWantsReturnValue);

    // If encoding was started we expect the script to have been
    // used when ending the encoding.
    // MOZ_ASSERT_IF(mEncodeBytecode && mScript && mRv == NS_OK, mScriptUsed);
  }

  void SetKeepStencil() { mKeepStencil = true; }
  already_AddRefed<JS::Stencil> StealStencil() { return mStencil.forget(); }

  // After getting a notification that an off-thread compile/decode finished,
  // this function will take the result of the off-thread operation and move it
  // to the main thread.
  void JoinOffThread(JSContext* aCx, JS::CompileOptions& aCompileOptions,
                     ScriptLoadContext* aContext,
                     JS::MutableHandle<JSScript*> aScript, ErrorResult& aRv,
                     bool aEncodeBytecode = false);

  // Compile a script contained in a SourceText.
  void Compile(JSContext* aCx, JS::CompileOptions& aCompileOptions,
               JS::SourceText<char16_t>& aSrcBuf,
               JS::MutableHandle<JSScript*> aScript, ErrorResult& aRv,
               bool aEncodeBytecode = false);
  void Compile(JSContext* aCx, JS::CompileOptions& aCompileOptions,
               JS::SourceText<mozilla::Utf8Unit>& aSrcBuf,
               JS::MutableHandle<JSScript*> aScript, ErrorResult& aRv,
               bool aEncodeBytecode = false);

  // Compile a script contained in a string.
  void Compile(JSContext* aCx, JS::CompileOptions& aCompileOptions,
               const nsAString& aScript,
               JS::MutableHandle<JSScript*> aScriptOut, ErrorResult& aRv,
               bool aEncodeBytecode = false);

  // Decode a script contained in a buffer.
  void Decode(JSContext* aCx, JS::CompileOptions& aCompileOptions,
              const JS::TranscodeRange& aBytecodeBuf,
              JS::MutableHandle<JSScript*> aScript, ErrorResult& aRv);

  // Instantiate (on main-thread) a JS::Stencil generated by off-thread or
  // main-thread parsing or decoding.
  void InstantiateStencil(JSContext* aCx, JS::CompileOptions& aCompileOptions,
                          RefPtr<JS::Stencil>&& aStencil,
                          JS::MutableHandle<JSScript*> aScript,
                          bool& incrementalEncodingAlreadyStarted,
                          ErrorResult& aRv, bool aEncodeBytecode = false,
                          JS::InstantiationStorage* aStorage = nullptr);

  // Execute the compiled script and ignore the return value.
  void ExecScript(JSContext* aCx, JS::Handle<JSScript*> aScript,
                  ErrorResult& aRv);

  // Execute the compiled script a get the return value.
  //
  // Copy the returned value into the mutable handle argument. In case of a
  // evaluation failure either during the execution or the conversion of the
  // result to a string, the mutable handle argument remains unchanged.
  //
  // The value returned in the mutable handle argument is part of the
  // compartment given as argument to the JSExecutionContext constructor. If the
  // caller is in a different compartment, then the out-param value should be
  // wrapped by calling |JS_WrapValue|.
  //
  // The returned value will be converted to a string if the
  // |aCoerceToString| is flag set.
  void ExecScript(JSContext* aCx, JS::Handle<JSScript*> aScript,
                  JS::MutableHandle<JS::Value> aRetValue, ErrorResult& aRv,
                  bool aCoerceToString = false);
};
}  // namespace dom
}  // namespace mozilla

#endif /* DOM_BASE_JSEXECUTIONCONTEXT_H_ */
