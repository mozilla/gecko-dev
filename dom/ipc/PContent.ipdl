/* -*- Mode: C++; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 8 -*- */
/* vim: set sw=4 ts=8 et tw=80 ft=cpp : */
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

include protocol PBackground;
include protocol PBrowser;
include protocol PClientOpenWindowOp;
include protocol PCompositorManager;
include protocol PContentPermissionRequest;
include protocol PCycleCollectWithLogs;
include protocol PPSMContentDownloader;
include protocol PExternalHelperApp;
include protocol PHandlerService;
include protocol PFileDescriptorSet;
include protocol PHal;
include protocol PHeapSnapshotTempFileHelper;
include protocol PProcessHangMonitor;
include protocol PImageBridge;
include protocol PIPCBlobInputStream;
include protocol PLoginReputation;
include protocol PMedia;
include protocol PNecko;
include protocol PStreamFilter;
include protocol PGMPContent;
include protocol PGMPService;
include protocol PPluginModule;
include protocol PGMP;
include protocol PPrinting;
include protocol PChildToParentStream;
include protocol PParentToChildStream;
include protocol POfflineCacheUpdate;
include protocol PSpeechSynthesis;
include protocol PTestShell;
include protocol PJavaScript;
include protocol PRemoteSpellcheckEngine;
include protocol PWebBrowserPersistDocument;
include protocol PWebrtcGlobal;
include protocol PWindowGlobal;
include protocol PPresentation;
include protocol PURLClassifier;
include protocol PURLClassifierLocal;
include protocol PVRManager;
include protocol PRemoteDecoderManager;
include protocol PProfiler;
include protocol PScriptCache;
include protocol PSessionStorageObserver;
include protocol PBenchmarkStorage;
include DOMTypes;
include JavaScriptTypes;
include IPCBlob;
include IPCStream;
include PTabContext;
include URIParams;
include PluginTypes;
include ProtocolTypes;
include PBackgroundSharedTypes;
include PContentPermission;
include ServiceWorkerConfiguration;
include GraphicsMessages;
include MemoryReportTypes;
include ClientIPCTypes;
include HangTypes;
include PrefsTypes;
include NeckoChannelParams;

#if defined(MOZ_SANDBOX) && defined(MOZ_DEBUG) && defined(ENABLE_TESTS)
include protocol PSandboxTesting;
#endif

using refcounted class nsIDOMGeoPosition from "nsGeoPositionIPCSerialiser.h";
using refcounted class nsIAlertNotification from "mozilla/AlertNotificationIPCSerializer.h";

using struct ChromePackage from "mozilla/chrome/RegistryMessageUtils.h";
using struct SubstitutionMapping from "mozilla/chrome/RegistryMessageUtils.h";
using struct OverrideMapping from "mozilla/chrome/RegistryMessageUtils.h";
using base::ProcessId from "base/process.h";
using struct IPC::Permission from "mozilla/net/NeckoMessageUtils.h";
using class IPC::Principal from "mozilla/dom/PermissionMessageUtils.h";
using mozilla::a11y::IHandlerControlHolder from "mozilla/a11y/IPCTypes.h";
using mozilla::dom::NativeThreadId from "mozilla/dom/TabMessageUtils.h";
using mozilla::hal::ProcessPriority from "mozilla/HalTypes.h";
using mozilla::gfx::IntSize from "mozilla/gfx/2D.h";
using mozilla::dom::TabId from "mozilla/dom/ipc/IdType.h";
using mozilla::dom::ContentParentId from "mozilla/dom/ipc/IdType.h";
using mozilla::LayoutDeviceIntPoint from "Units.h";
using struct LookAndFeelInt from "mozilla/widget/WidgetMessageUtils.h";
using class mozilla::dom::MessagePort from "mozilla/dom/MessagePort.h";
using class mozilla::dom::ipc::StructuredCloneData from "mozilla/dom/ipc/StructuredCloneData.h";
using mozilla::DataStorageType from "ipc/DataStorageIPCUtils.h";
using mozilla::OriginAttributes from "mozilla/ipc/BackgroundUtils.h";
using struct mozilla::layers::TextureFactoryIdentifier from "mozilla/layers/CompositorTypes.h";
using mozilla::layers::CompositorOptions from "mozilla/layers/CompositorOptions.h";
using mozilla::layers::LayersId from "mozilla/layers/LayersTypes.h";
using mozilla::Telemetry::HistogramAccumulation from "mozilla/TelemetryComms.h";
using mozilla::Telemetry::KeyedHistogramAccumulation from "mozilla/TelemetryComms.h";
using mozilla::Telemetry::ScalarAction from "mozilla/TelemetryComms.h";
using mozilla::Telemetry::KeyedScalarAction from "mozilla/TelemetryComms.h";
using mozilla::Telemetry::DynamicScalarDefinition from "mozilla/TelemetryComms.h";
using mozilla::Telemetry::ChildEventData from "mozilla/TelemetryComms.h";
using mozilla::Telemetry::DiscardedData from "mozilla/TelemetryComms.h";
using mozilla::CrossProcessMutexHandle from "mozilla/ipc/CrossProcessMutex.h";
using refcounted class mozilla::dom::BrowsingContext from "mozilla/dom/BrowsingContext.h";
using mozilla::dom::BrowsingContextTransaction from "mozilla/dom/BrowsingContext.h";
using mozilla::dom::BrowsingContextInitializer from "mozilla/dom/BrowsingContext.h";
using base::SharedMemoryHandle from "base/shared_memory.h";
using mozilla::ipc::SharedMemoryBasic::Handle from "mozilla/ipc/SharedMemoryBasic.h";
using mozilla::fontlist::Pointer from "SharedFontList.h";
using gfxSparseBitSet from "gfxFontUtils.h";
using mozilla::dom::MediaControlActions from "ipc/MediaControlIPC.h";

union ChromeRegistryItem
{
    ChromePackage;
    OverrideMapping;
    SubstitutionMapping;
};

namespace mozilla {
namespace dom {

// Used on Android/B2G to pass the list of fonts on the device
// to the child process
struct FontListEntry {
    nsCString familyName;
    nsCString faceName;
    nsCString filepath;
    uint32_t  weightRange;
    uint32_t  stretchRange;
    uint32_t  styleRange;
    uint8_t   index;
};

// Used on Mac OS X to pass the list of font families (not faces)
// from chrome to content processes.
// The entryType field distinguishes several types of font family
// record; see gfxMacPlatformFontList.h for values and meaning.
struct FontFamilyListEntry {
    nsCString familyName;
    uint8_t   entryType;
};

// Used on Linux to pass list of font patterns from chrome to content.
struct FontPatternListEntry {
    nsCString pattern;
    bool      appFontFamily;
};

// Wrap the Font*ListEntry records in a union so the SetXPCOMProcessAttributes
// message can pass an array of either type.
union SystemFontListEntry {
    FontFamilyListEntry;
    FontPatternListEntry;
};

struct DataStorageItem {
  nsCString key;
  nsCString value;
  DataStorageType type;
};

struct DataStorageEntry {
  DataStorageItem[] items;
  nsString filename;
};

struct ClipboardCapabilities {
  bool supportsSelectionClipboard;
  bool supportsFindClipboard;
};

union FileDescOrError {
    FileDescriptor;
    nsresult;
};

struct DomainPolicyClone
{
    bool        active;
    URIParams[] blocklist;
    URIParams[] allowlist;
    URIParams[] superBlocklist;
    URIParams[] superAllowlist;
};

struct AndroidSystemInfo
{
    nsString device;
    nsString manufacturer;
    nsString release_version;
    nsString hardware;
    uint32_t sdk_version;
    bool     isTablet;
};

struct GetFilesResponseSuccess
{
  IPCBlob[] blobs;
};

struct GetFilesResponseFailure
{
  nsresult errorCode;
};

union GetFilesResponseResult
{
  GetFilesResponseSuccess;
  GetFilesResponseFailure;
};

struct BlobURLRegistrationData
{
  nsCString url;
  IPCBlob blob;
  Principal principal;
  bool revoked;
};

struct JSWindowActorEventDecl
{
  nsString name;
  bool capture;
  bool systemGroup;
  bool allowUntrusted;
  bool? passive;
};

struct JSWindowActorInfo
{
  nsString name;
  bool allFrames;
  nsCString? url;

  JSWindowActorEventDecl[] events;
  nsCString[] observers;
  nsString[] matches;
  nsString[] remoteTypes;
};

struct GMPAPITags
{
    nsCString api;
    nsCString[] tags;
};

struct GMPCapabilityData
{
    nsCString name;
    nsCString version;
    GMPAPITags[] capabilities;
};

struct GfxInfoFeatureStatus
{
    int32_t feature;
    int32_t status;
    nsCString failureId;
};

struct XPCOMInitData
{
    bool isOffline;
    bool isConnected;
    int32_t captivePortalState;
    bool isLangRTL;
    bool haveBidiKeyboards;
    nsString[] dictionaries;
    ClipboardCapabilities clipboardCaps;
    DomainPolicyClone domainPolicy;
    URIParams? userContentSheetURL;
    GfxVarUpdate[] gfxNonDefaultVarUpdates;
    ContentDeviceData contentDeviceData;
    GfxInfoFeatureStatus[] gfxFeatureStatus;
    DataStorageEntry[] dataStorage;
    nsCString[] appLocales;
    nsCString[] requestedLocales;
    DynamicScalarDefinition[] dynamicScalarDefs;
};

struct StringBundleDescriptor
{
    nsCString bundleURL;
    FileDescriptor mapFile;
    uint32_t mapSize;
};

struct IPCURLClassifierFeature
{
    nsCString featureName;
    nsCString[] tables;
    nsCString skipHostList;
};

// Transport structure for Notifications API notifications
// (https://developer.mozilla.org/en-US/docs/Web/API/notification) instances
// used exclusively by the NotificationEvent PContent method.
struct NotificationEventData
{
    nsCString originSuffix;
    nsCString scope;
    nsString ID;
    nsString title;
    nsString dir;
    nsString lang;
    nsString body;
    nsString tag;
    nsString icon;
    nsString data;
    nsString behavior;
};

struct PostMessageData
{
    BrowsingContext source;
    nsString origin;
    nsString targetOrigin;
    nsIURI targetOriginURI;
    nsIPrincipal callerPrincipal;
    nsIPrincipal subjectPrincipal;
    nsIURI callerDocumentURI;
    bool isFromPrivateWindow;
};

/**
 * The PContent protocol is a top-level protocol between the UI process
 * and a content process. There is exactly one PContentParent/PContentChild pair
 * for each content process.
 */
nested(upto inside_cpow) sync protocol PContent
{
    manages PBrowser;
    manages PClientOpenWindowOp;
    manages PContentPermissionRequest;
    manages PCycleCollectWithLogs;
    manages PPSMContentDownloader;
    manages PExternalHelperApp;
    manages PFileDescriptorSet;
    manages PHal;
    manages PHandlerService;
    manages PHeapSnapshotTempFileHelper;
    manages PIPCBlobInputStream;
    manages PMedia;
    manages PNecko;
    manages POfflineCacheUpdate;
    manages PPrinting;
    manages PChildToParentStream;
    manages PParentToChildStream;
    manages PSpeechSynthesis;
    manages PTestShell;
    manages PJavaScript;
    manages PRemoteSpellcheckEngine;
    manages PWebBrowserPersistDocument;
    manages PWebrtcGlobal;
    manages PPresentation;
    manages PURLClassifier;
    manages PURLClassifierLocal;
    manages PScriptCache;
    manages PLoginReputation;
    manages PSessionStorageObserver;
    manages PBenchmarkStorage;

    // Depending on exactly how the new browser is being created, it might be
    // created from either the child or parent process!
    //
    // The child creates the PBrowser as part of
    // BrowserChild::BrowserFrameProvideWindow (which happens when the child's
    // content calls window.open()), and the parent creates the PBrowser as part
    // of ContentParent::CreateBrowser.
    //
    // When the parent constructs a PBrowser, the child trusts the attributes it
    // receives from the parent.  In that case, the context should be
    // FrameIPCTabContext.
    //
    // When the child constructs a PBrowser, the parent doesn't trust the
    // attributes it receives from the child.  In this case, context must have
    // type PopupIPCTabContext.  The parent checks that if the opener is a
    // browser element, the context is also for a browser element.
    //
    // If |sameTabGroupAs| is non-zero, the new tab should go in the same
    // TabGroup as |sameTabGroupAs|. This parameter should always be zero
    // for PBrowser messages sent from the child to the parent.
    //
    // Separate messages are used for the parent and child side constructors due
    // to the differences in data and actor setup required.
    //
    // Keep the last 3 attributes in sync with GetProcessAttributes!
parent:
    async ConstructPopupBrowser(ManagedEndpoint<PBrowserParent> browserEp,
                                ManagedEndpoint<PWindowGlobalParent> windowEp,
                                TabId tabId, IPCTabContext context,
                                WindowGlobalInit windowInit,
                                uint32_t chromeFlags);

child:
    async ConstructBrowser(ManagedEndpoint<PBrowserChild> browserEp,
                           ManagedEndpoint<PWindowGlobalChild> windowEp,
                           TabId tabId, TabId sameTabGroupAs,
                           IPCTabContext context,
                           WindowGlobalInit windowInit,
                           uint32_t chromeFlags, ContentParentId cpId,
                           bool isForBrowser, bool isTopLevel);

both:
    async PFileDescriptorSet(FileDescriptor fd);

    // For parent->child, aBrowser must be non-null; aOuterWindowID can
    // be 0 to indicate the browser's current root document, or nonzero
    // to persist a subdocument.  For child->parent, arguments are
    // ignored and should be null/zero.
    async PWebBrowserPersistDocument(nullable PBrowser aBrowser,
                                     uint64_t aOuterWindowID);

child:
    async InitGMPService(Endpoint<PGMPServiceChild> service);
    async InitProcessHangMonitor(Endpoint<PProcessHangMonitorChild> hangMonitor);
    async InitProfiler(Endpoint<PProfilerChild> aEndpoint);

    // Give the content process its endpoints to the compositor.
    async InitRendering(
      Endpoint<PCompositorManagerChild> compositor,
      Endpoint<PImageBridgeChild> imageBridge,
      Endpoint<PVRManagerChild> vr,
      Endpoint<PRemoteDecoderManagerChild> video,
      uint32_t[] namespaces);

    // Re-create the rendering stack using the given endpoints. This is sent
    // after the compositor process has crashed. The new endpoints may be to a
    // newly launched GPU process, or the compositor thread of the UI process.
    async ReinitRendering(
      Endpoint<PCompositorManagerChild> compositor,
      Endpoint<PImageBridgeChild> bridge,
      Endpoint<PVRManagerChild> vr,
      Endpoint<PRemoteDecoderManagerChild> video,
      uint32_t[] namespaces);

    async AudioDefaultDeviceChange();

    async NetworkLinkTypeChange(uint32_t type);

    // Re-create the rendering stack for a device reset.
    async ReinitRenderingForDeviceReset();

    /**
     * Enable system-level sandboxing features, if available.  Can
     * usually only be performed zero or one times.  The child may
     * abnormally exit if this fails; the details are OS-specific.
     */
    async SetProcessSandbox(FileDescriptor? aBroker);

    async RequestMemoryReport(uint32_t generation,
                              bool anonymize,
                              bool minimizeMemoryUsage,
                              FileDescriptor? DMDFile);
    async RequestPerformanceMetrics(nsID aID);

    /**
     * Communication between the PuppetBidiKeyboard and the actual
     * BidiKeyboard hosted by the parent
     */
    async BidiKeyboardNotify(bool isLangRTL, bool haveBidiKeyboards);

    /**
     * Dump this process's GC and CC logs to the provided files.
     *
     * For documentation on the other args, see dumpGCAndCCLogsToFile in
     * nsIMemoryInfoDumper.idl
     */
    async PCycleCollectWithLogs(bool dumpAllTraces,
                                FileDescriptor gcLog,
                                FileDescriptor ccLog);

    async PTestShell();

    async PScriptCache(FileDescOrError cacheFile, bool wantCacheData);

    async RegisterChrome(ChromePackage[] packages, SubstitutionMapping[] substitutions,
                         OverrideMapping[] overrides, nsCString locale, bool reset);
    async RegisterChromeItem(ChromeRegistryItem item);

    async ClearImageCache(bool privateLoader, bool chrome);

    async SetOffline(bool offline);
    async SetConnectivity(bool connectivity);
    async SetCaptivePortalState(int32_t aState);

    async NotifyVisited(URIParams[] uri);

    async PreferenceUpdate(Pref pref);
    async VarUpdate(GfxVarUpdate var);

    async UpdatePerfStatsCollectionMask(uint64_t aMask);
    async CollectPerfStatsJSON() returns (nsCString aStats);

    async DataStoragePut(nsString aFilename, DataStorageItem aItem);
    async DataStorageRemove(nsString aFilename, nsCString aKey, DataStorageType aType);
    async DataStorageClear(nsString aFilename);

    async NotifyAlertsObserver(nsCString topic, nsString data);

    async GeolocationUpdate(nsIDOMGeoPosition aPosition);

    async GeolocationError(uint16_t errorCode);

    async UpdateDictionaryList(nsString[] dictionaries);

    async UpdateFontList(SystemFontListEntry[] fontList);

    /**
     * The shared font list has been reinitialized by the parent;
     * child processes must discard and recreate their mappings to it.
     */
    async RebuildFontList();

    /**
     * The shared font list has been modified, potentially adding matches
     * for src:local() names that were previously not known, so content
     * may need to be reflowed.
     */
    async FontListChanged();

    async UpdateAppLocales(nsCString[] appLocales);
    async UpdateRequestedLocales(nsCString[] requestedLocales);

    async RegisterStringBundles(StringBundleDescriptor[] stringBundles);

    async UpdateSharedData(FileDescriptor mapFile, uint32_t aSize,
                           IPCBlob[] blobs,
                           nsCString[] changedKeys);

    // nsIPermissionManager messages
    async AddPermission(Permission permission);
    async RemoveAllPermissions();

    async FlushMemory(nsString reason);

    async GarbageCollect();
    async CycleCollect();
    async UnlinkGhosts();

    /**
     * Start accessibility engine in content process.
     * @param aTid is the thread ID of the chrome process main thread. Only used
     *             on Windows; pass 0 on other platforms.
     * @param aMsaaID is an a11y-specific unique id for the content process
     *                that is generated by the chrome process. Only used on
     *                Windows; pass 0 on other platforms.
     */
    async ActivateA11y(uint32_t aMainChromeTid, uint32_t aMsaaID);

    /**
     * Shutdown accessibility engine in content process (if not in use).
     */
    async ShutdownA11y();

    async AppInfo(nsCString version, nsCString buildID, nsCString name, nsCString UAName,
                  nsCString ID, nsCString vendor, nsCString sourceURL);

    /**
     * Send the remote type associated with the content process.
     */
    async RemoteType(nsString aRemoteType);

    /**
     * Send ServiceWorkerRegistrationData to child process.
     */
    async InitServiceWorkers(ServiceWorkerConfiguration aConfig);

    /**
     * Send BlobURLRegistrationData to child process.
     */
    async InitBlobURLs(BlobURLRegistrationData[] registrations);

    /**
     * Send JSWindowActorInfos to child process.
     */
    async InitJSWindowActorInfos(JSWindowActorInfo[] aInfos);

    /**
     * Unregister a previously registered JSWindowActor in the child process.
     */
    async UnregisterJSWindowActor(nsString name);

    async SetXPCOMProcessAttributes(XPCOMInitData xpcomInit,
                                    StructuredCloneData initialData,
                                    LookAndFeelInt[] lookAndFeelIntCache,
                                    /* used on MacOSX and Linux only: */
                                    SystemFontListEntry[] systemFontList,
                                    SharedMemoryHandle? sharedUASheetHandle,
                                    uintptr_t sharedUASheetAddress);

    // Notify child that last-pb-context-exited notification was observed
    async LastPrivateDocShellDestroyed();

    async NotifyProcessPriorityChanged(ProcessPriority priority);
    async MinimizeMemoryUsage();

    /**
     * Used to manage nsIStyleSheetService across processes.
     */
    async LoadAndRegisterSheet(URIParams uri, uint32_t type);
    async UnregisterSheet(URIParams uri, uint32_t type);

    /**
     * Notify idle observers in the child
     */
    async NotifyIdleObserver(uint64_t observerId, nsCString topic, nsString str);

    async InvokeDragSession(IPCDataTransfer[] transfers, uint32_t action);

    async EndDragSession(bool aDoneDrag, bool aUserCancelled,
                         LayoutDeviceIntPoint aDragEndPoint,
                         uint32_t aKeyModifiers);

    async DomainSetChanged(uint32_t aSetType, uint32_t aChangeType, URIParams? aDomain);

    /**
     * Notify the child to shutdown. The child will in turn call FinishShutdown
     * and let the parent close the channel.
     */
    async Shutdown();

    async LoadProcessScript(nsString url);

    /**
     * Requests a full native update of a native plugin child window. This is
     * a Windows specific call.
     */
    async UpdateWindow(uintptr_t aChildId);

    /**
     * Notify the child that presentation receiver has been launched with the
     * correspondent iframe.
     */
    async NotifyPresentationReceiverLaunched(PBrowser aIframe, nsString aSessionId);

    /**
     * Notify the child that the info about a presentation receiver needs to be
     * cleaned up.
     */
    async NotifyPresentationReceiverCleanUp(nsString aSessionId);

    /**
     * Notify the child that cache is emptied.
     */
    async NotifyEmptyHTTPCache();

    /**
     * Send a `push` event without data to a service worker in the child.
     */
    async Push(nsCString scope, Principal principal, nsString messageId);

    /**
     * Send a `push` event with data to a service worker in the child.
     */
    async PushWithData(nsCString scope, Principal principal,
                       nsString messageId, uint8_t[] data);

    /**
     * Send a `pushsubscriptionchange` event to a service worker in the child.
     */
    async PushSubscriptionChange(nsCString scope, Principal principal);

    /**
     * Windows specific: associate this content process with the browsers
     * audio session.
     */
    async SetAudioSessionData(nsID aID,
                              nsString aDisplayName,
                              nsString aIconPath);

    async GetFilesResponse(nsID aID, GetFilesResponseResult aResult);

    async BlobURLRegistration(nsCString aURI, IPCBlob aBlob,
                              Principal aPrincipal);

    async BlobURLUnregistration(nsCString aURI);

    async GMPsChanged(GMPCapabilityData[] capabilities);


    /**
     * Sending an activate message moves focus to the child.
     */
    async Activate(PBrowser aTab);

    async Deactivate(PBrowser aTab);

    async PParentToChildStream();

    async ProvideAnonymousTemporaryFile(uint64_t aID, FileDescOrError aFD);

    async SetPermissionsWithKey(nsCString aPermissionKey, Permission[] aPermissions);

    async RefreshScreens(ScreenDetails[] aScreens);

    async PIPCBlobInputStream(nsID aID, uint64_t aSize);

    /**
     * This call takes the set of plugins loaded in the chrome process, and
     * sends them to the content process. However, in many cases this set will
     * not have changed since the last SetPluginList message. To keep track of
     * this, the chrome process increments an epoch number every time the set of
     * plugins changes. The chrome process sends up the last epoch it observed.
     * If the epoch last seen by the content process is the same, the content
     * process ignores the update. Otherwise the content process updates its
     * list and reloads its plugins.
     **/
    async SetPluginList(uint32_t pluginEpoch, PluginTag[] plugins, FakePluginTag[] fakePlugins);

    async ShareCodeCoverageMutex(CrossProcessMutexHandle handle);
    async FlushCodeCoverageCounters() returns (bool unused);

    async GetMemoryUniqueSetSize() returns (int64_t uss);

    /*
     * IPC message to enable the input event queue on the main thread of the
     * content process.
     */
    async SetInputEventQueueEnabled();

    /*
     * IPC message to flush the input event queue on the main thread of the
     * content process.
     *
     * When the ContentParent stops sending the input event with input priority,
     * there may be some pending events in the input event queue and normal
     * event queue. Here is a possible scenario.
     * R: Runnables.
     * D: Enable the input priority event.
     * E: Disable the input priority evnet.
     *
     *                     D       E
     * Normal Queue: R1      R2      R3
     * Input Queue:     II      I2      I3
     *
     * To avoid the newly added normal events (e.g. R2, which may be an input
     * event) preempt the pending input events (e.g. I1), or the newly added
     * input events (e.g. I3) preempt the pending normal events (e.g. R2), we
     * have to flush all pending events before enabling and disabling the input
     * priority event.
     *
     * To flush the normal event queue and the input event queue, we use three
     * IPC messages as the followings.
     * FI: Flush the input queue.
     * SI: Suspend the input queue.
     * RI: Resume the input queue.
     *
     * Normal Queue: R1    FI    RI R2   FI    RI R3
     * Input Queue:     II    SI      I2    SI       I3
     *
     * When the flush input request is processed before the other two requests,
     * we consume all input events until the suspend request. After handling the
     * suspend request, we stop consuming the input events until the resume
     * request to make sure we consume all pending normal events.
     *
     * If we process the suspend request before the other two requests, we
     * ignore the flush request and consume all pending normal events until the
     * resume request.
     */
    async FlushInputEventQueue();

    /*
     * IPC message to resume consuming the pending events in the input event
     * queue.
     */
    async ResumeInputEventQueue();

    /*
     * IPC message to suspend consuming the pending events in the input event
     * queue.
     */
    prio(input) async SuspendInputEventQueue();

    /*
     * IPC message to propagate dynamic scalar definitions, added after the
     * content process is spawned, from the parent to the child.
     * Dynamic scalar definitions added at the process startup are handled
     * using the |TelemetryIPC::AddDynamicScalarDefinitions| functions.
     */
    async AddDynamicScalars(DynamicScalarDefinition[] definitions);

    /*
     * Message to construct a PClientOpenWindowOp actor.  This is used to
     * open windows cross-process and receive notification when the operation
     * has completed.
     */
    async PClientOpenWindowOp(ClientOpenWindowArgs aArgs);

    /* Save the execution up to the current point in a recording process. */
    async SaveRecording(FileDescriptor file);

    // This message is sent to content processes, and triggers the creation of a
    // new HttpChannelChild that will be connected to the parent channel
    // represented by registrarId.
    // This is on PContent not PNecko, as PNecko may not be initialized yet.
    // The returned loadInfo needs to be set on the channel - since the channel
    // moved to a new process it now has different properties.

    async CrossProcessRedirect(uint32_t aRegistrarId,
                               nsIURI aURI,
                               ReplacementChannelConfigInit config,
                               LoadInfoArgs? aLoadInfo,
                               uint64_t aChannelId,
                               nsIURI aOriginalURI,
                               uint64_t aIdentifier,
                               uint32_t aRedirectMode)
        returns (nsresult rv, LoadInfoArgs? arg);

    /**
    * This method is used to notifty content process to start delayed autoplay
    * media via browsing context.
    */
    async StartDelayedAutoplayMediaComponents(BrowsingContext aContext);

    /**
     * This method is used to apply the media action to outer window in the
     * content process, such as play, pause, stop ..e.t.c.
     */
    async UpdateMediaAction(BrowsingContext aContext, MediaControlActions aAction);

    // Begin subscribing to a new BrowsingContextGroup, sending down the current
    // value for every individual BrowsingContext.
    async RegisterBrowsingContextGroup(BrowsingContextInitializer[] aInits);

#if defined(MOZ_SANDBOX) && defined(MOZ_DEBUG) && defined(ENABLE_TESTS)
    // Initialize top-level actor for testing content process sandbox.
    async InitSandboxTesting(Endpoint<PSandboxTestingChild> aEndpoint);
#endif

parent:
    async InitBackground(Endpoint<PBackgroundParent> aEndpoint);

    sync OpenRecordReplayChannel(uint32_t channelId)
        returns (FileDescriptor connection);
    async CreateReplayingProcess(uint32_t channelId);
    async GenerateReplayCrashReport(uint32_t channelId);

    async CreateGMPService();

    async InitStreamFilter(uint64_t channelId, nsString addonId)
        returns (Endpoint<PStreamFilterChild> aEndpoint);

    /**
     * This call connects the content process to a plugin process. This call
     * returns an endpoint for a new PluginModuleParent. The corresponding
     * PluginModuleChild will be started up in the plugin process.
     */
    sync LoadPlugin(uint32_t aPluginId)
        returns (nsresult aResult, uint32_t aRunID, Endpoint<PPluginModuleParent> aEndpoint);

    /**
     * This call is used by asynchronous plugin instantiation to notify the
     * content parent that it is now safe to initiate the plugin bridge for
     * the specified plugin id. The endpoint for the content process part of the
     * bridge is returned.
     */
    sync ConnectPluginBridge(uint32_t aPluginId)
        returns (nsresult rv, Endpoint<PPluginModuleParent> aEndpoint);

    // See Bug 1518344 - Investigate using async for PContent::LaunchRDDProcess
    sync LaunchRDDProcess()
        returns (nsresult rv, Endpoint<PRemoteDecoderManagerChild> aEndpoint);

    async PJavaScript();

    async PRemoteSpellcheckEngine();

    async InitCrashReporter(Shmem shmem, NativeThreadId tid);

    sync IsSecureURI(uint32_t aType, URIParams aURI, uint32_t aFlags,
                     OriginAttributes aOriginAttributes)
        returns (bool isSecureURI);

    async AccumulateMixedContentHSTS(URIParams aURI, bool aActive,
                                     OriginAttributes aOriginAttributes);

    nested(inside_cpow) async PHal();

    async PHeapSnapshotTempFileHelper();

    async PNecko();

    async PPrinting();

    async PChildToParentStream();

    async PSpeechSynthesis();

    async PMedia();

    async PWebrtcGlobal();

    async PPresentation();

    async CreateAudioIPCConnection() returns (FileDescOrError fd);

    sync PURLClassifier(Principal principal)
        returns (bool success);

    async PURLClassifierLocal(URIParams uri, IPCURLClassifierFeature[] features);

    async PLoginReputation(URIParams formURI);

    async PSessionStorageObserver();

    async PBenchmarkStorage();

    // Services remoting

    async StartVisitedQuery(URIParams uri);
    async SetURITitle(URIParams uri, nsString title);

    async LoadURIExternal(URIParams uri, PBrowser windowContext);
    async ExtProtocolChannelConnectParent(uint32_t registrarId);

    // PrefService message
    sync GetGfxVars() returns (GfxVarUpdate[] vars);

    sync ReadFontList() returns (FontListEntry[] retValue);

    sync SyncMessage(nsString aMessage, ClonedMessageData aData,
                     CpowEntry[] aCpows, Principal aPrincipal)
      returns (StructuredCloneData[] retval);

    nested(inside_sync) sync RpcMessage(nsString aMessage, ClonedMessageData aData,
                                        CpowEntry[] aCpows, Principal aPrincipal)
      returns (StructuredCloneData[] retval);

    async ShowAlert(nsIAlertNotification alert);

    async CloseAlert(nsString name, Principal principal);

    async DisableNotifications(Principal principal);

    async OpenNotificationSettings(Principal principal);

    // Request that the ServiceWorkerManager in the parent process create a
    // notification "click" or "close" event and dispatch it on the relevant
    // ServiceWorker. This needs to happen because when a notification is
    // created it is tied to a specific content process and when the user clicks
    // on the notification, it will be that content process that is notified.
    // However, even if the ServiceWorker lives in that process (it may no
    // longer be in that process, or may have never lived there), the right/only
    // way to talk through the ServiceWorker is through the parent.
    //
    // This happens on PContent because the ServiceWorkerManager lives on the
    // main thread and bouncing this off of PBackground would be silly and
    // complex. In the long run, the notification implementation will be
    // overhauled to directly process the notification click/close and directly
    // translate that to a ServiceWorker event.
    async NotificationEvent(nsString type, NotificationEventData data);

    async PPSMContentDownloader(uint32_t aCertType);

    async PExternalHelperApp(URIParams? uri,
                             LoadInfoArgs? loadInfoArgs,
                             nsCString aMimeContentType,
                             nsCString aContentDisposition,
                             uint32_t aContentDispositionHint,
                             nsString aContentDispositionFilename,
                             bool aForceSave,
                             int64_t aContentLength,
                             bool aWasFileChannel,
                             URIParams? aReferrer,
                             nullable PBrowser aBrowser);

    async PHandlerService();

    async AddGeolocationListener(Principal principal, bool highAccuracy);
    async RemoveGeolocationListener();
    async SetGeolocationHigherAccuracy(bool enable);

    async ConsoleMessage(nsString message);
    async ScriptErrorWithStack(nsString message, nsString sourceName, nsString sourceLine,
                               uint32_t lineNumber, uint32_t colNumber, uint32_t flags,
                               nsCString category, bool privateWindow,
                               bool fromChromeContext, ClonedMessageData stack);

    // Places the items within dataTransfer on the clipboard.
    async SetClipboard(IPCDataTransfer aDataTransfer,
                       bool aIsPrivateData,
                       Principal aRequestingPrincipal,
                       uint32_t aContentPolicyType,
                       int32_t aWhichClipboard);

    // Given a list of supported types, returns the clipboard data for the
    // first type that matches.
    sync GetClipboard(nsCString[] aTypes, int32_t aWhichClipboard)
        returns (IPCDataTransfer dataTransfer);

    // Returns a list of formats supported by the clipboard
    sync GetExternalClipboardFormats(int32_t aWhichClipboard, bool aPlainTextOnly) returns (nsCString[] aTypes);

    // Clears the clipboard.
    async EmptyClipboard(int32_t aWhichClipboard);

    // Returns true if data of one of the specified types is on the clipboard.
    sync ClipboardHasType(nsCString[] aTypes, int32_t aWhichClipboard)
        returns (bool hasType);

    // 'Play', 'Beep' and 'PlayEventSound' are the only nsISound methods used in
    // the content process.
    async PlaySound(URIParams aURL) compress;
    async Beep() compress;
    async PlayEventSound(uint32_t aEventId) compress;

    sync GetIconForExtension(nsCString aFileExt, uint32_t aIconSize)
        returns (uint8_t[] bits);

    sync GetShowPasswordSetting()
        returns (bool showPassword);

    // Notify the parent of the presence or absence of private docshells
    async PrivateDocShellsExist(bool aExist);

    // Tell the parent that the child has gone idle for the first time.
    async FirstIdle();

    async DeviceReset();

    sync KeywordToURI(nsCString keyword, bool isPrivateContext)
        returns (nsString providerName, nsIInputStream postData, URIParams? uri);

    sync NotifyKeywordSearchLoading(nsString providerName, nsString keyword);

    async CopyFavicon(URIParams oldURI, URIParams newURI, Principal aLoadingPrincipal, bool isPrivate);

    /**
     * Notifies the parent about a recording device is starting or shutdown.
     * @param recordingStatus starting or shutdown
     * @param pageURL URL that request that changing the recording status
     * @param isAudio recording start with microphone
     * @param isVideo recording start with camera
     */
    async RecordingDeviceEvents(nsString recordingStatus,
                                nsString pageURL,
                                bool isAudio,
                                bool isVideo);

    // Graphics errors
    async GraphicsError(nsCString aError);

    // Driver crash guards. aGuardType must be a member of CrashGuardType.
    sync BeginDriverCrashGuard(uint32_t aGuardType) returns (bool crashDetected);
    sync EndDriverCrashGuard(uint32_t aGuardType);

    async AddIdleObserver(uint64_t observerId, uint32_t idleTimeInS);
    async RemoveIdleObserver(uint64_t observerId, uint32_t idleTimeInS);

    /**
     * This message is only used on X11 platforms.
     *
     * Send a dup of the plugin process's X socket to the parent
     * process.  In theory, this scheme keeps the plugin's X resources
     * around until after both the plugin process shuts down *and* the
     * parent process closes the dup fd.  This is used to prevent the
     * parent process from crashing on X errors if, e.g., the plugin
     * crashes *just before* a repaint and the parent process tries to
     * use the newly-invalid surface.
     */
    async BackUpXResources(FileDescriptor aXSocketFd);

    async RequestAnonymousTemporaryFile(uint64_t aID);

    /**
     * Starts an offline application cache update.
     * @param manifestURI
     *   URI of the manifest to fetch, the application cache group ID
     * @param documentURI
     *   URI of the document that referred the manifest
     * @param loadingPrincipal
     *   Principal of the document that referred the manifest
     * @param stickDocument
     *   True if the update was initiated by a document load that referred
     *   a manifest.
     *   False if the update was initiated by applicationCache.update() call.
     *
     *   Tells the update to carry the documentURI to a potential separate
     *   update of implicit (master) items.
     *
     *   Why this argument? If the document was not found in an offline cache
     *   before load and refers a manifest and this manifest itself has not
     *   been changed since the last fetch, we will not do the application
     *   cache group update. But we must cache the document (identified by the
     *   documentURI). This argument will ensure that a previously uncached
     *   document will get cached and that we don't re-cache a document that
     *   has already been cached (stickDocument=false).
     * @param tabId
     *   To identify which tab owns the app.
     */
    async POfflineCacheUpdate(URIParams manifestURI, URIParams documentURI,
                              PrincipalInfo loadingPrincipal, bool stickDocument,
                              CookieSettingsArgs cookieSettings);

    /**
     * Sets "offline-app" permission for the principal.  Called when we hit
     * a web app with the manifest attribute in <html>
     */
    async SetOfflinePermission(Principal principal);

    /**
     * Notifies the parent to continue shutting down after the child performs
     * its shutdown tasks.
     */
    async FinishShutdown();

    async UpdateDropEffect(uint32_t aDragAction, uint32_t aDropEffect);

    /**
     * Initiates an asynchronous request for permission for the
     * provided principal.
     *
     * @param aRequests
     *   The array of permissions to request.
     * @param aPrincipal
     *   The principal of the request.
     * @param aTopLevelPrincipal
     *   The principal of the top level page the request comes from.
     * @param tabId
     *   To identify which tab issues this request.
     *
     * NOTE: The principal is untrusted in the parent process. Only
     *       principals that can live in the content process should
     *       provided.
     */
    async PContentPermissionRequest(PermissionRequest[] aRequests, Principal aPrincipal,
                                    Principal aTopLevelPrincipal, bool aIsHandlingUserInput,
                                    bool aDocumentHasUserInput, uint64_t aPageLoadTimestamp, TabId tabId);

    async ShutdownProfile(nsCString aProfile);

    /**
     * Request graphics initialization information from the parent.
     */
    sync GetGraphicsDeviceInitData()
        returns (ContentDeviceData aData);

    /**
     * A shared font list (see gfx/thebes/SharedFontList.*) contains a list
     * of shared-memory blocks that are used to store all the font list data.
     * The font list created in the parent process is the only one that can
     * create or store objects into the shared memory; content processes font
     * lists have read-only access to it.
     *
     * To minimize the cost of record allocations, the shared font list
     * bump-allocates new objects that it adds to the shared memory blocks
     * (i.e. the records stored in the shared memory blocks are only ever
     * appended, and never freed except when the entire font list is
     * reconstructed).
     *
     * When initially created by the parent process, the font list may contain
     * nothing except a header, and the list of the system's installed font
     * family names. Additional data about the families (styled faces available
     * and character coverage) is appended to the font list during the session
     * as a given font is considered for use, because loading all data for all
     * installed fonts during startup is too expensive/slow.
     *
     * During content process launch, a content process's first step in
     * gaining access to the font list is to call GetFontListShmBlock,
     * passing index zero in order to get access to the first block, which
     * contains the font list header and the list of font-family records
     * (which may be virtually all uninitialized at this time, containing
     * nothing but the family names). Once a content process determines a
     * font-family name it wants to use (e.g. from a CSS font-family list, or
     * from preferences), if that Family record has not yet been initialized,
     * it will call InitializeFamily (below) to have the parent process
     * populate Face records in the shared memory with the family's styles.
     * The content process can then pick the face with best style match from
     * the available faces according to the CSS font matching algorithm, load
     * its character map, then send the map to the parent process using
     * SetCharacterMap (so that the parent process can share the map with all
     * processes to avoid duplication of work).
     *
     * At some point, as the parent process adds data to the font list, a new
     * shared-memory block will probably be needed. At that point the parent
     * will create a new block and append it to its share memory block list.
     * The new Block index will start to appear in Pointer records in the
     * shared memory, and the content process's can then fetch those other
     * blocks using this function as needed.
     *
     * @param aGeneration
     *   The font list has a Generation ID stored in its Header, and any time
     *   the parent process needs to reinitialize the list (because of a change
     *   in the available font repertoire) a new Generation ID is assigned.
     *   Content processes pass the Generation of the list they're using in
     *   all messages, so that the parent can recognize if they're out of date
     *   and safely ignore such messages. (When the parent rebuilds the list,
     *   it will notify all content processes, but they may still send a few
     *   messages that relate to the obsolete list before they have processed
     *   this notification.)
     * @param aIndex
     *   (Zero-based) index of the shared-memory block to be mapped.
     *   In a typical case, there will be a handful of blocks altogether, so
     *   each content process only needs to make this request a few times.
     * @returns aHandle
     *   Handle that can be used to construct a SharedMemoryBasic that maps the
     *   requested block of memory.
     *   If aGeneration does not match the parent's font list generation ID, or
     *   if requesting a block that does not exist (i.e. with aIndex greater
     *   than or equal to the number of blocks actually in existence), returns
     *   a null handle.
     *
     * This is a sync message because the content process needs font data in
     * order to perform font-matching (e.g. during reflow), and cannot continue
     * until it has mapped the font-list memory.
     */
    sync GetFontListShmBlock(uint32_t aGeneration, uint32_t aIndex)
        returns (Handle aHandle);

    /**
     * Ask the parent to initialize a given font family, so that face metadata
     * will be available. Content processes will only call this for families
     * where the Face data has not yet been populated, so it will generally be
     * called no more than once per family. (It may not be needed at all, if
     * the parent process has already initialized the families that content
     * wants to use.)
     *
     * @param aGeneration
     *   Font-list generation, so requests relating to an obsolete list can be
     *   ignored (see comments for GetFontListShmBlock).
     * @param aFamilyIndex
     *   The 0-based index of the Family within the font-list that a content
     *   process needs to use.
     *
     * This is a sync message because the content process cannot complete its
     * font-matching until the family is fully populated with Face records.
     * If we make it async, content processes will reflow using fallbacks,
     * and then have to reflow again once all the font information needed
     * becomes available.
     */
    sync InitializeFamily(uint32_t aGeneration, uint32_t aFamilyIndex);

    /**
     * Record the character map of a given Face in the font list.
     *
     * @param aGeneration
     *   Font-list generation, so requests relating to an obsolete list can be
     *   ignored (see comments for GetFontListShmBlock).
     * @param aFacePtr
     *   Font-list shared-memory "pointer" to the Face record to be updated.
     *   A Pointer is a record of a shared-memory block index and an offset
     *   within that block, which each process that maps the block can convert
     *   into a real pointer in its address space.
     * @param aMap
     *   The character coverage map of the face. (This will be stored as a
     *   SharedBitSet record within the shared font list, and the Face record
     *   will be updated to reference it.)
     */
    async SetCharacterMap(uint32_t aGeneration, Pointer aFacePtr, gfxSparseBitSet aMap);

    /**
     * Ask the parent to set up the merged charmap for a family, to accelerate
     * future fallback searches.
     * aFamilyPtr may refer to an element of either the Families() or AliasFamilies().
     */
    async SetupFamilyCharMap(uint32_t aGeneration, Pointer aFamilyPtr);

    /**
     * Ask the parent to try and complete the InitOtherFamilyNames task, because
     * we're trying to look up a localized font name. This is a sync method so that
     * the update will be available before the child continues reflow; however, it
     * is possible the task will have timed-out in the parent and not actually
     * completed during this call.
     *
     * @param aGeneration
     *   Font-list generation, so requests relating to an obsolete list can be
     *   ignored (see comments for GetFontListShmBlock).
     * @param aDefer
     *   Parameter aDeferOtherFamilyNamesLoading to be passed to
     *   gfxPlatformFontList::InitOtherFamilyNames, to determine whether name
     *   loading should be deferred to a background task or run immediately.
     * @param aLoaded
     *   Returns whether the font name loading process has completed.
     *
     * TODO: This is currently a sync message but can probably be made async,
     * at the cost of an increased chance of some testcases failing because
     * they depend on lazily-loaded font names.
     */
    sync InitOtherFamilyNames(uint32_t aGeneration, bool aDefer) returns (bool aLoaded);

    async CreateWindow(nullable PBrowser aThisTab,
                       PBrowser aNewTab,
                       uint32_t aChromeFlags,
                       bool aCalledFromJS,
                       bool aPositionSpecified,
                       bool aSizeSpecified,
                       URIParams? aURIToLoad,
                       nsCString aFeatures,
                       float aFullZoom,
                       Principal aTriggeringPrincipal,
                       nsIContentSecurityPolicy aCsp,
                       nsIReferrerInfo aReferrerInfo)
        returns (CreatedWindowInfo window);

    async CreateWindowInDifferentProcess(
      PBrowser aThisTab,
      uint32_t aChromeFlags,
      bool aCalledFromJS,
      bool aPositionSpecified,
      bool aSizeSpecified,
      URIParams? aURIToLoad,
      nsCString aFeatures,
      float aFullZoom,
      nsString aName,
      nsIPrincipal aTriggeringPrincipal,
      nsIContentSecurityPolicy aCsp,
      nsIReferrerInfo aReferrerInfo);

    /**
     * Tells the parent to ungrab the pointer on the default display.
     *
     * This is for GTK platforms where we have to ensure the pointer ungrab happens in the
     * chrome process as that's the process that receives the pointer event.
     */
    sync UngrabPointer(uint32_t time);

    sync RemovePermission(Principal principal, nsCString permissionType) returns (nsresult rv);

    /**
     * Tell the parent that a decoder's' benchmark has been completed.
     * The result can then be stored in permanent storage.
     */
    async NotifyBenchmarkResult(nsString aCodecName, uint32_t aDecodeFPS);

    /**
     * Notify `push-message` observers without data in the parent.
     */
    async NotifyPushObservers(nsCString scope, Principal principal,
                              nsString messageId);

    /**
     * Notify `push-message` observers with data in the parent.
     */
    async NotifyPushObserversWithData(nsCString scope, Principal principal,
                                      nsString messageId, uint8_t[] data);

    /**
     * Notify `push-subscription-change` observers in the parent.
     */
    async NotifyPushSubscriptionChangeObservers(nsCString scope,
                                                Principal principal);

     async GetFilesRequest(nsID aID, nsString aDirectory, bool aRecursiveFlag);
     async DeleteGetFilesRequest(nsID aID);

     async StoreAndBroadcastBlobURLRegistration(nsCString url, IPCBlob blob,
                                                Principal principal);

     async UnstoreAndBroadcastBlobURLUnregistration(nsCString url);

    /**
     * Messages for communicating child Telemetry to the parent process
     */
    async AccumulateChildHistograms(HistogramAccumulation[] accumulations);
    async AccumulateChildKeyedHistograms(KeyedHistogramAccumulation[] accumulations);
    async UpdateChildScalars(ScalarAction[] updates);
    async UpdateChildKeyedScalars(KeyedScalarAction[] updates);
    async RecordChildEvents(ChildEventData[] events);
    async RecordDiscardedData(DiscardedData data);
    async RecordOrigin(uint32_t metricId, nsCString origin);

    async ReportContentBlockingLog(IPCStream aJSONStream);

    sync GetA11yContentId() returns (uint32_t aContentId);
    async A11yHandlerControl(uint32_t aPid,
                             IHandlerControlHolder aHandlerControl);

    async AddMemoryReport(MemoryReport aReport);
    async FinishMemoryReport(uint32_t aGeneration);

    async MaybeReloadPlugins();

    async BHRThreadHang(HangDetails aHangDetails);

    async AddPerformanceMetrics(nsID aID, PerformanceInfo[] aMetrics);

    /*
     * Determines whether storage access can be granted automatically by the
     * storage access API without showing a user prompt.
     */
    async AutomaticStorageAccessCanBeGranted(Principal aPrincipal)
          returns (bool success);

    /*
     * A 3rd party tracking origin (aTrackingOrigin) has received the permission
     * granted to have access to aGrantedOrigin when loaded by aParentPrincipal.
     */
    async FirstPartyStorageAccessGrantedForOrigin(Principal aParentPrincipal,
                                                  Principal aTrackingPrincipal,
                                                  nsCString aTrackingOrigin,
                                                  nsCString aGrantedOrigin,
                                                  int aAllowMode)
          returns (bool unused);

    async StoreUserInteractionAsPermission(Principal aPrincipal);

   /**
    * When media started or stopped in content process, we have to notify the
    * chrome process in order to know which tab is playing media.
    */
    async NotifyMediaActiveChanged(BrowsingContext aContext, bool aActive);

   /**
    * When media became audible or inaudible in content process, we have to
    * notify chrome process in order to which tab is audible.
    */
    async NotifyMediaAudibleChanged(BrowsingContext aContext, bool aAudible);

both:
    async ScriptError(nsString message, nsString sourceName, nsString sourceLine,
                      uint32_t lineNumber, uint32_t colNumber, uint32_t flags,
                      nsCString category, bool privateWindow, uint64_t innerWindowId,
                      bool fromChromeContext);

    async CommitBrowsingContextTransaction(BrowsingContext aContext,
                                           BrowsingContextTransaction aTransaction,
                                           uint64_t aEpoch);

    async AsyncMessage(nsString aMessage, CpowEntry[] aCpows,
                       Principal aPrincipal, ClonedMessageData aData);

    /**
     * Notify `push-subscription-modified` observers in the parent and child.
     */
    async NotifyPushSubscriptionModifiedObservers(nsCString scope,
                                                  Principal principal);

    /**
     * Send a Push error message to all service worker clients in the parent or
     * child.
     */
    async PushError(nsCString scope, Principal principal, nsString message,
                    uint32_t flags);

    /**
     * Sync the BrowsingContext with id 'aContextId' and name 'aName' to the
     * parent, and attach it to the BrowsingContext 'aParentContext'. If
     * 'aParentContext' is 'nullptr' the BrowsingContext is a root in the
     * BrowsingContext tree. AttachBrowsingContext must only be called at most
     * once for any child BrowsingContext, and only for BrowsingContexts where
     * the parent and the child context contains their nsDocShell.
     */
    async AttachBrowsingContext(BrowsingContextInitializer aInit);

    /**
     * Remove the synced BrowsingContext with id 'aContextId' from the parent.
     * DetachBrowsingContext is only needed to be called once for any
     * BrowsingContext, since detaching a node in the BrowsingContext detaches
     * the entire sub-tree rooted at that node. Calling DetachBrowsingContext
     * with an already detached BrowsingContext effectively does nothing. Note
     * that it is not an error to call DetachBrowsingContext on a
     * BrowsingContext belonging to an already detached subtree.
     *
     * As the passed-in context is allowed to already be detached, it is passed
     * by id, rather than using BrowsingContext's serializer.
     *
     * Callers should keep the BrowsingContext alive until this async request is
     * resolved or rejected, in order to ensure that in-flight messages still
     * have valid targets.
     */
    async DetachBrowsingContext(uint64_t aContextId) returns (bool unused);

    /**
     * Removes all of 'aContext'\'s children, and caches them in the
     * BrowsingContextGroup.
     */
    async CacheBrowsingContextChildren(BrowsingContext aContext);

    /**
     * Re-attach all BrowsingContexts in a 'aContext'.
     */
    async RestoreBrowsingContextChildren(BrowsingContext aContext,
                                         BrowsingContext[] aChildren);

    async WindowClose(BrowsingContext aContext, bool aTrustedCaller);
    async WindowFocus(BrowsingContext aContext);
    async WindowBlur(BrowsingContext aContext);
    async WindowPostMessage(BrowsingContext aContext, ClonedMessageData aMessage,
                            PostMessageData aData);
};

}
}
