<!DOCTYPE HTML>
<html>
<head>
  <script type="application/javascript" src="pc.js"></script>
  <script type="application/javascript" src="iceTestUtils.js"></script>
</head>
<body>
<pre id="test">
<script type="application/javascript">
  createHTML({
    bug: "",
    title: ""
  });

  const tests = [
    async function checkIdReuseAfterClose() {
      // Takes the DTLS server role
      const pc1 = new RTCPeerConnection();
      // Takes the DTLS client role
      const pc2 = new RTCPeerConnection();

      info("Creating initial channels");
      const dc1pc1 = pc1.createDataChannel('');
      const dc1open = new Promise(r => dc1pc1.onopen = r);
      const dc2created = new Promise(r => pc2.ondatachannel = r);

      await connect(pc1, pc2, 2000, "Initial connection");
      const dc1pc2 = (await dc2created).channel;
      await dc1open;

      info("Checking initial ids");
      // By default, offerer (pc1) is in DTLS server role
      is(dc1pc1.id % 2, 1,
        `Channel created by the DTLS server role must be odd (was ${dc1pc1.id})`);
      is(dc1pc2.id, dc1pc1.id, 'Both pcs should have the same id for the first channel');
      const dc2pc2 = pc2.createDataChannel('another');
      const dc2pc1 = (await new Promise(r => pc1.ondatachannel = r)).channel;

      is(dc2pc2.id % 2, 0,
        `Channel created by the DTLS client role must be even (was ${dc2pc2.id})`);
      is(dc2pc1.id, dc2pc2.id, 'Both pcs should have the same id for the second channel');

      const id1 = dc1pc1.id;
      const id2 = dc2pc1.id;

      // Close from pc1
      dc1pc1.close();
      dc2pc1.close();

      info("Waiting for close events");
      await Promise.all([new Promise(r => dc1pc2.onclose = r), new Promise(r => dc2pc2.onclose = r), new Promise(r => dc1pc1.onclose = r), new Promise(r => dc2pc1.onclose = r)]);

      // Unfortunately, there's no way to detect that the stream resets are done.
      // This is why this is a mochitest and not a wpt.
      await new Promise(r => setTimeout(r, 1000));

      info("Creating new channels");
      const dc3pc1 = pc1.createDataChannel('again', {negotiated: true, id: id1});
      await new Promise(r => dc3pc1.onopen = r);
      is(dc3pc1.id, id1, 'id should be reused');

      const dc4pc2 = pc2.createDataChannel('yet again', {negotiated: true, id: id2});
      await new Promise(r => dc4pc2.onopen = r);
      is(dc4pc2.id, id2, 'id should be reused');
      pc1.close();
      pc2.close();
}
  ];

  runNetworkTest(async () => {
    for (const test of tests) {
      info(`Running test: ${test.name}`);
      await test();
      info(`Done running test: ${test.name}`);
    }
  });

</script>
</pre>
</body>
</html>
