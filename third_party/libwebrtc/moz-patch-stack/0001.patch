From: Byron Campen <docfaraday@gmail.com>
Date: Mon, 29 Jul 2024 11:51:03 -0500
Subject: (tmp-cherry-pick) Revert "Make ICE tiebreaker a construction time
 argument of Port" (6071f044e1)

This reverts commit 933357ec0e107162d38e84adebd801edac451c69.

Reason for revert: Breaks build.

Original change's description:
> Make ICE tiebreaker a construction time argument of Port
>
> and remove SetIceTieBreaker()
>
> BUG=webrtc:42224914
>
> Change-Id: Ib806decd061fde1b376064ac9f58df1dad8ee976
> Reviewed-on: https://webrtc-review.googlesource.com/c/src/+/352340
> Reviewed-by: Harald Alvestrand <hta@webrtc.org>
> Reviewed-by: Tomas Gunnarsson <tommi@webrtc.org>
> Commit-Queue: Philipp Hancke <phancke@meta.com>
> Cr-Commit-Position: refs/heads/main@{#42416}

Bug: webrtc:42224914
Change-Id: Ie50f095e697d6eb36cca6239f9e871b7d627d6f9
No-Presubmit: true
No-Tree-Checks: true
No-Try: true
Reviewed-on: https://webrtc-review.googlesource.com/c/src/+/353141
Commit-Queue: Manashi Sarkar <manashi@google.com>
Bot-Commit: rubber-stamper@appspot.gserviceaccount.com <rubber-stamper@appspot.gserviceaccount.com>
Reviewed-by: Tomas Gunnarsson <tommi@webrtc.org>
Cr-Commit-Position: refs/heads/main@{#42420}
---
 p2p/base/fake_port_allocator.h            |  17 +--
 p2p/base/p2p_transport_channel.cc         |   1 +
 p2p/base/port.cc                          |  15 +-
 p2p/base/port.h                           |   4 +-
 p2p/base/port_interface.h                 |   1 +
 p2p/base/port_unittest.cc                 | 174 ++++++++++++++--------
 p2p/base/stun_port_unittest.cc            |   8 +-
 p2p/base/tcp_port_unittest.cc             |  39 ++---
 p2p/base/turn_port.h                      |  25 ++--
 p2p/base/turn_port_unittest.cc            |   8 +-
 p2p/client/basic_port_allocator.cc        |  17 +--
 p2p/client/relay_port_factory_interface.h |   1 -
 12 files changed, 183 insertions(+), 127 deletions(-)

diff --git a/p2p/base/fake_port_allocator.h b/p2p/base/fake_port_allocator.h
index 09f0e34e51..d45d1e4998 100644
--- a/p2p/base/fake_port_allocator.h
+++ b/p2p/base/fake_port_allocator.h
@@ -107,16 +107,15 @@ class FakePortAllocatorSession : public PortAllocatorSession {
           (rtc::HasIPv6Enabled() && (flags() & PORTALLOCATOR_ENABLE_IPV6))
               ? ipv6_network_
               : ipv4_network_;
-      port_.reset(
-          TestUDPPort::Create({.network_thread = network_thread_,
-                               .socket_factory = factory_,
-                               .network = &network,
-                               .ice_username_fragment = username(),
-                               .ice_password = password(),
-                               .field_trials = field_trials_,
-                               .ice_tiebreaker = allocator_->ice_tiebreaker()},
-                              0, 0, false));
+      port_.reset(TestUDPPort::Create({.network_thread = network_thread_,
+                                       .socket_factory = factory_,
+                                       .network = &network,
+                                       .ice_username_fragment = username(),
+                                       .ice_password = password(),
+                                       .field_trials = field_trials_},
+                                      0, 0, false));
       RTC_DCHECK(port_);
+      port_->SetIceTiebreaker(allocator_->ice_tiebreaker());
       port_->SubscribePortDestroyed(
           [this](PortInterface* port) { OnPortDestroyed(port); });
       AddPort(port_.get());
diff --git a/p2p/base/p2p_transport_channel.cc b/p2p/base/p2p_transport_channel.cc
index 1c44a2f0eb..dcea5b0e47 100644
--- a/p2p/base/p2p_transport_channel.cc
+++ b/p2p/base/p2p_transport_channel.cc
@@ -914,6 +914,7 @@ void P2PTransportChannel::OnPortReady(PortAllocatorSession* session,
   // if one is pending.
 
   port->SetIceRole(ice_role_);
+  port->SetIceTiebreaker(allocator_->ice_tiebreaker());
   ports_.push_back(port);
   port->SignalUnknownAddress.connect(this,
                                      &P2PTransportChannel::OnUnknownAddress);
diff --git a/p2p/base/port.cc b/p2p/base/port.cc
index 45b43b3ac6..d9bacf3a5a 100644
--- a/p2p/base/port.cc
+++ b/p2p/base/port.cc
@@ -118,7 +118,7 @@ Port::Port(const PortParametersRef& args,
       timeout_delay_(kPortTimeoutDelay),
       enable_port_packets_(false),
       ice_role_(ICEROLE_UNKNOWN),
-      ice_tiebreaker_(args.ice_tiebreaker),
+      tiebreaker_(0),
       shared_socket_(shared_socket),
       network_cost_(args.network->GetCost(*field_trials_)),
       weak_factory_(this) {
@@ -160,8 +160,12 @@ void Port::SetIceRole(IceRole role) {
   ice_role_ = role;
 }
 
+void Port::SetIceTiebreaker(uint64_t tiebreaker) {
+  tiebreaker_ = tiebreaker;
+}
+
 uint64_t Port::IceTiebreaker() const {
-  return ice_tiebreaker_;
+  return tiebreaker_;
 }
 
 bool Port::SharedSocket() const {
@@ -220,7 +224,8 @@ void Port::AddAddress(const rtc::SocketAddress& address,
               type, generation_, "", network_->id(), network_cost_);
   // Set the relay protocol before computing the foundation field.
   c.set_relay_protocol(relay_protocol);
-  c.ComputeFoundation(base_address, ice_tiebreaker_);
+  // TODO(bugs.webrtc.org/14605): ensure IceTiebreaker() is set.
+  c.ComputeFoundation(base_address, tiebreaker_);
 
   c.set_priority(
       c.GetPriority(type_preference, network_->preference(), relay_preference,
@@ -645,7 +650,7 @@ bool Port::MaybeIceRoleConflict(const rtc::SocketAddress& addr,
   switch (ice_role_) {
     case ICEROLE_CONTROLLING:
       if (ICEROLE_CONTROLLING == remote_ice_role) {
-        if (remote_tiebreaker >= ice_tiebreaker_) {
+        if (remote_tiebreaker >= tiebreaker_) {
           SignalRoleConflict(this);
         } else {
           // Send Role Conflict (487) error response.
@@ -657,7 +662,7 @@ bool Port::MaybeIceRoleConflict(const rtc::SocketAddress& addr,
       break;
     case ICEROLE_CONTROLLED:
       if (ICEROLE_CONTROLLED == remote_ice_role) {
-        if (remote_tiebreaker < ice_tiebreaker_) {
+        if (remote_tiebreaker < tiebreaker_) {
           SignalRoleConflict(this);
         } else {
           // Send Role Conflict (487) error response.
diff --git a/p2p/base/port.h b/p2p/base/port.h
index b9eb343dba..2df1d35b8e 100644
--- a/p2p/base/port.h
+++ b/p2p/base/port.h
@@ -180,7 +180,6 @@ class RTC_EXPORT Port : public PortInterface, public sigslot::has_slots<> {
     absl::string_view ice_username_fragment;
     absl::string_view ice_password;
     const webrtc::FieldTrialsView* field_trials;
-    uint64_t ice_tiebreaker;
   };
 
  protected:
@@ -207,6 +206,7 @@ class RTC_EXPORT Port : public PortInterface, public sigslot::has_slots<> {
   IceRole GetIceRole() const override;
   void SetIceRole(IceRole role) override;
 
+  void SetIceTiebreaker(uint64_t tiebreaker) override;
   uint64_t IceTiebreaker() const override;
 
   bool SharedSocket() const override;
@@ -490,7 +490,7 @@ class RTC_EXPORT Port : public PortInterface, public sigslot::has_slots<> {
   int timeout_delay_;
   bool enable_port_packets_;
   IceRole ice_role_;
-  const uint64_t ice_tiebreaker_;
+  uint64_t tiebreaker_;
   bool shared_socket_;
 
   // A virtual cost perceived by the user, usually based on the network type
diff --git a/p2p/base/port_interface.h b/p2p/base/port_interface.h
index 6847727b10..34f835d138 100644
--- a/p2p/base/port_interface.h
+++ b/p2p/base/port_interface.h
@@ -60,6 +60,7 @@ class PortInterface {
   virtual void SetIceRole(IceRole role) = 0;
   virtual IceRole GetIceRole() const = 0;
 
+  virtual void SetIceTiebreaker(uint64_t tiebreaker) = 0;
   virtual uint64_t IceTiebreaker() const = 0;
 
   virtual bool SharedSocket() const = 0;
diff --git a/p2p/base/port_unittest.cc b/p2p/base/port_unittest.cc
index 35c79542df..be3b365427 100644
--- a/p2p/base/port_unittest.cc
+++ b/p2p/base/port_unittest.cc
@@ -105,7 +105,10 @@ const RelayCredentials kRelayCredentials("test", "test");
 const uint32_t kDefaultPrflxPriority = ICE_TYPE_PREFERENCE_PRFLX << 24 |
                                        30 << 8 |
                                        (256 - ICE_CANDIDATE_COMPONENT_DEFAULT);
-constexpr uint64_t kTiebreakerDefault = 44444;
+
+constexpr int kTiebreaker1 = 11111;
+constexpr int kTiebreaker2 = 22222;
+constexpr int kTiebreakerDefault = 44444;
 
 const char* data = "ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890";
 
@@ -532,57 +535,61 @@ class PortTest : public ::testing::Test, public sigslot::has_slots<> {
   }
   std::unique_ptr<UDPPort> CreateUdpPort(const SocketAddress& addr,
                                          PacketSocketFactory* socket_factory) {
-    return UDPPort::Create({.network_thread = &main_,
-                            .socket_factory = socket_factory,
-                            .network = MakeNetwork(addr),
-                            .ice_username_fragment = username_,
-                            .ice_password = password_,
-                            .field_trials = &field_trials_,
-                            .ice_tiebreaker = kTiebreakerDefault},
-                           0, 0, true, absl::nullopt);
+    auto port = UDPPort::Create({.network_thread = &main_,
+                                 .socket_factory = socket_factory,
+                                 .network = MakeNetwork(addr),
+                                 .ice_username_fragment = username_,
+                                 .ice_password = password_,
+                                 .field_trials = &field_trials_},
+                                0, 0, true, absl::nullopt);
+    port->SetIceTiebreaker(kTiebreakerDefault);
+    return port;
   }
 
   std::unique_ptr<UDPPort> CreateUdpPortMultipleAddrs(
       const SocketAddress& global_addr,
       const SocketAddress& link_local_addr,
       PacketSocketFactory* socket_factory) {
-    return UDPPort::Create(
+    auto port = UDPPort::Create(
         {.network_thread = &main_,
          .socket_factory = socket_factory,
          .network = MakeNetworkMultipleAddrs(global_addr, link_local_addr),
          .ice_username_fragment = username_,
          .ice_password = password_,
-         .field_trials = &field_trials_,
-         .ice_tiebreaker = kTiebreakerDefault},
+         .field_trials = &field_trials_},
         0, 0, true, absl::nullopt);
+    port->SetIceTiebreaker(kTiebreakerDefault);
+    return port;
   }
   std::unique_ptr<TCPPort> CreateTcpPort(const SocketAddress& addr) {
     return CreateTcpPort(addr, &socket_factory_);
   }
   std::unique_ptr<TCPPort> CreateTcpPort(const SocketAddress& addr,
                                          PacketSocketFactory* socket_factory) {
-    return TCPPort::Create({.network_thread = &main_,
-                            .socket_factory = socket_factory,
-                            .network = MakeNetwork(addr),
-                            .ice_username_fragment = username_,
-                            .ice_password = password_,
-                            .field_trials = &field_trials_,
-                            .ice_tiebreaker = kTiebreakerDefault},
-                           0, 0, true);
+    auto port = TCPPort::Create({.network_thread = &main_,
+                                 .socket_factory = socket_factory,
+                                 .network = MakeNetwork(addr),
+                                 .ice_username_fragment = username_,
+                                 .ice_password = password_,
+                                 .field_trials = &field_trials_},
+                                0, 0, true);
+    port->SetIceTiebreaker(kTiebreakerDefault);
+    return port;
   }
   std::unique_ptr<StunPort> CreateStunPort(
       const SocketAddress& addr,
       rtc::PacketSocketFactory* socket_factory) {
     ServerAddresses stun_servers;
     stun_servers.insert(kStunAddr);
-    return StunPort::Create({.network_thread = &main_,
-                             .socket_factory = socket_factory,
-                             .network = MakeNetwork(addr),
-                             .ice_username_fragment = username_,
-                             .ice_password = password_,
-                             .field_trials = &field_trials_,
-                             .ice_tiebreaker = kTiebreakerDefault},
-                            0, 0, stun_servers, absl::nullopt);
+    auto port = StunPort::Create({.network_thread = &main_,
+                                  .socket_factory = socket_factory,
+                                  .network = MakeNetwork(addr),
+                                  .ice_username_fragment = username_,
+                                  .ice_password = password_,
+                                  .field_trials = &field_trials_},
+                                 0, 0, stun_servers, absl::nullopt);
+    port->SetIceTiebreaker(kTiebreakerDefault);
+    return port;
   }
   std::unique_ptr<Port> CreateRelayPort(const SocketAddress& addr,
                                         ProtocolType int_proto,
@@ -616,9 +623,10 @@ class PortTest : public ::testing::Test, public sigslot::has_slots<> {
     args.server_address = &server_address;
     args.config = &config;
     args.field_trials = &field_trials_;
-    args.ice_tiebreaker = kTiebreakerDefault;
 
-    return TurnPort::Create(args, 0, 0);
+    auto port = TurnPort::Create(args, 0, 0);
+    port->SetIceTiebreaker(kTiebreakerDefault);
+    return port;
   }
 
   std::unique_ptr<rtc::NATServer> CreateNatServer(const SocketAddress& addr,
@@ -824,8 +832,7 @@ class PortTest : public ::testing::Test, public sigslot::has_slots<> {
                                     .network = MakeNetwork(addr),
                                     .ice_username_fragment = username,
                                     .ice_password = password,
-                                    .field_trials = field_trials,
-                                    .ice_tiebreaker = kTiebreakerDefault};
+                                    .field_trials = field_trials};
     auto port = std::make_unique<TestPort>(args, 0, 0);
     port->SignalRoleConflict.connect(this, &PortTest::OnRoleConflict);
     return port;
@@ -833,9 +840,11 @@ class PortTest : public ::testing::Test, public sigslot::has_slots<> {
   std::unique_ptr<TestPort> CreateTestPort(const rtc::SocketAddress& addr,
                                            absl::string_view username,
                                            absl::string_view password,
-                                           cricket::IceRole role) {
+                                           cricket::IceRole role,
+                                           int tiebreaker) {
     auto port = CreateTestPort(addr, username, password);
     port->SetIceRole(role);
+    port->SetIceTiebreaker(tiebreaker);
     return port;
   }
   // Overload to create a test port given an rtc::Network directly.
@@ -847,8 +856,7 @@ class PortTest : public ::testing::Test, public sigslot::has_slots<> {
                                     .network = network,
                                     .ice_username_fragment = username,
                                     .ice_password = password,
-                                    .field_trials = nullptr,
-                                    .ice_tiebreaker = kTiebreakerDefault};
+                                    .field_trials = nullptr};
     auto port = std::make_unique<TestPort>(args, 0, 0);
     port->SignalRoleConflict.connect(this, &PortTest::OnRoleConflict);
     return port;
@@ -1435,8 +1443,10 @@ TEST_F(PortTest, TestConnectionDeadWithDeadConnectionTimeout) {
 TEST_F(PortTest, TestConnectionDeadOutstandingPing) {
   auto port1 = CreateUdpPort(kLocalAddr1);
   port1->SetIceRole(cricket::ICEROLE_CONTROLLING);
+  port1->SetIceTiebreaker(kTiebreaker1);
   auto port2 = CreateUdpPort(kLocalAddr2);
   port2->SetIceRole(cricket::ICEROLE_CONTROLLED);
+  port2->SetIceTiebreaker(kTiebreaker2);
 
   TestChannel ch1(std::move(port1));
   TestChannel ch2(std::move(port2));
@@ -1476,8 +1486,10 @@ TEST_F(PortTest, TestConnectionDeadOutstandingPing) {
 TEST_F(PortTest, TestLocalToLocalStandard) {
   auto port1 = CreateUdpPort(kLocalAddr1);
   port1->SetIceRole(cricket::ICEROLE_CONTROLLING);
+  port1->SetIceTiebreaker(kTiebreaker1);
   auto port2 = CreateUdpPort(kLocalAddr2);
   port2->SetIceRole(cricket::ICEROLE_CONTROLLED);
+  port2->SetIceTiebreaker(kTiebreaker2);
   // Same parameters as TestLocalToLocal above.
   TestConnectivity("udp", std::move(port1), "udp", std::move(port2), true, true,
                    true, true);
@@ -1490,6 +1502,7 @@ TEST_F(PortTest, TestLocalToLocalStandard) {
 TEST_F(PortTest, TestLoopbackCall) {
   auto lport = CreateTestPort(kLocalAddr1, "lfrag", "lpass");
   lport->SetIceRole(cricket::ICEROLE_CONTROLLING);
+  lport->SetIceTiebreaker(kTiebreaker1);
   lport->PrepareAddress();
   ASSERT_FALSE(lport->Candidates().empty());
   Connection* conn =
@@ -1526,7 +1539,7 @@ TEST_F(PortTest, TestLoopbackCall) {
   // To make sure we receive error response, adding tiebreaker less than
   // what's present in request.
   modified_req->AddAttribute(std::make_unique<StunUInt64Attribute>(
-      STUN_ATTR_ICE_CONTROLLING, lport->IceTiebreaker() - 1));
+      STUN_ATTR_ICE_CONTROLLING, kTiebreaker1 - 1));
   modified_req->AddMessageIntegrity("lpass");
   modified_req->AddFingerprint();
 
@@ -1549,8 +1562,10 @@ TEST_F(PortTest, TestLoopbackCall) {
 TEST_F(PortTest, TestIceRoleConflict) {
   auto lport = CreateTestPort(kLocalAddr1, "lfrag", "lpass");
   lport->SetIceRole(cricket::ICEROLE_CONTROLLING);
+  lport->SetIceTiebreaker(kTiebreaker1);
   auto rport = CreateTestPort(kLocalAddr2, "rfrag", "rpass");
   rport->SetIceRole(cricket::ICEROLE_CONTROLLING);
+  rport->SetIceTiebreaker(kTiebreaker2);
 
   lport->PrepareAddress();
   rport->PrepareAddress();
@@ -1653,7 +1668,9 @@ TEST_F(PortTest, TestDisableInterfaceOfTcpPort) {
   rsocket->Bind(kLocalAddr2);
 
   lport->SetIceRole(cricket::ICEROLE_CONTROLLING);
+  lport->SetIceTiebreaker(kTiebreaker1);
   rport->SetIceRole(cricket::ICEROLE_CONTROLLED);
+  rport->SetIceTiebreaker(kTiebreaker2);
 
   lport->PrepareAddress();
   rport->PrepareAddress();
@@ -1792,6 +1809,7 @@ TEST_F(PortTest, TestUdpMultipleAddressesV6CrossTypePorts) {
     factory.set_next_udp_socket(socket);
     ports[i] =
         CreateUdpPortMultipleAddrs(addresses[i], kLinkLocalIPv6Addr, &factory);
+    ports[i]->SetIceTiebreaker(kTiebreakerDefault);
     socket->set_state(AsyncPacketSocket::STATE_BINDING);
     socket->SignalAddressReady(socket, addresses[i]);
     ports[i]->PrepareAddress();
@@ -1849,7 +1867,9 @@ TEST_F(PortTest, TestSendStunMessage) {
   auto lport = CreateTestPort(kLocalAddr1, "lfrag", "lpass");
   auto rport = CreateTestPort(kLocalAddr2, "rfrag", "rpass");
   lport->SetIceRole(cricket::ICEROLE_CONTROLLING);
+  lport->SetIceTiebreaker(kTiebreaker1);
   rport->SetIceRole(cricket::ICEROLE_CONTROLLED);
+  rport->SetIceTiebreaker(kTiebreaker2);
 
   // Send a fake ping from lport to rport.
   lport->PrepareAddress();
@@ -2010,7 +2030,9 @@ TEST_F(PortTest, TestNomination) {
   auto lport = CreateTestPort(kLocalAddr1, "lfrag", "lpass");
   auto rport = CreateTestPort(kLocalAddr2, "rfrag", "rpass");
   lport->SetIceRole(cricket::ICEROLE_CONTROLLING);
+  lport->SetIceTiebreaker(kTiebreaker1);
   rport->SetIceRole(cricket::ICEROLE_CONTROLLED);
+  rport->SetIceTiebreaker(kTiebreaker2);
 
   lport->PrepareAddress();
   rport->PrepareAddress();
@@ -2064,7 +2086,9 @@ TEST_F(PortTest, TestRoundTripTime) {
   auto lport = CreateTestPort(kLocalAddr1, "lfrag", "lpass");
   auto rport = CreateTestPort(kLocalAddr2, "rfrag", "rpass");
   lport->SetIceRole(cricket::ICEROLE_CONTROLLING);
+  lport->SetIceTiebreaker(kTiebreaker1);
   rport->SetIceRole(cricket::ICEROLE_CONTROLLED);
+  rport->SetIceTiebreaker(kTiebreaker2);
 
   lport->PrepareAddress();
   rport->PrepareAddress();
@@ -2101,7 +2125,9 @@ TEST_F(PortTest, TestUseCandidateAttribute) {
   auto lport = CreateTestPort(kLocalAddr1, "lfrag", "lpass");
   auto rport = CreateTestPort(kLocalAddr2, "rfrag", "rpass");
   lport->SetIceRole(cricket::ICEROLE_CONTROLLING);
+  lport->SetIceTiebreaker(kTiebreaker1);
   rport->SetIceRole(cricket::ICEROLE_CONTROLLED);
+  rport->SetIceTiebreaker(kTiebreaker2);
 
   // Send a fake ping from lport to rport.
   lport->PrepareAddress();
@@ -2128,7 +2154,9 @@ TEST_F(PortTest, TestNetworkCostChange) {
   auto lport = CreateTestPort(test_network, "lfrag", "lpass");
   auto rport = CreateTestPort(test_network, "rfrag", "rpass");
   lport->SetIceRole(cricket::ICEROLE_CONTROLLING);
+  lport->SetIceTiebreaker(kTiebreaker1);
   rport->SetIceRole(cricket::ICEROLE_CONTROLLED);
+  rport->SetIceTiebreaker(kTiebreaker2);
   lport->PrepareAddress();
   rport->PrepareAddress();
 
@@ -2183,7 +2211,9 @@ TEST_F(PortTest, TestNetworkInfoAttribute) {
   auto lport = CreateTestPort(test_network, "lfrag", "lpass");
   auto rport = CreateTestPort(test_network, "rfrag", "rpass");
   lport->SetIceRole(cricket::ICEROLE_CONTROLLING);
+  lport->SetIceTiebreaker(kTiebreaker1);
   rport->SetIceRole(cricket::ICEROLE_CONTROLLED);
+  rport->SetIceTiebreaker(kTiebreaker2);
 
   uint16_t lnetwork_id = 9;
   test_network->set_id(lnetwork_id);
@@ -2484,9 +2514,9 @@ TEST_F(PortTest,
        TestHandleStunResponseWithUnknownComprehensionRequiredAttribute) {
   // Generic setup.
   auto lport = CreateTestPort(kLocalAddr1, "lfrag", "lpass",
-                              cricket::ICEROLE_CONTROLLING);
+                              cricket::ICEROLE_CONTROLLING, kTiebreakerDefault);
   auto rport = CreateTestPort(kLocalAddr2, "rfrag", "rpass",
-                              cricket::ICEROLE_CONTROLLED);
+                              cricket::ICEROLE_CONTROLLED, kTiebreakerDefault);
   lport->PrepareAddress();
   rport->PrepareAddress();
   ASSERT_FALSE(lport->Candidates().empty());
@@ -2523,9 +2553,9 @@ TEST_F(PortTest,
        TestHandleStunIndicationWithUnknownComprehensionRequiredAttribute) {
   // Generic set up.
   auto lport = CreateTestPort(kLocalAddr2, "lfrag", "lpass",
-                              cricket::ICEROLE_CONTROLLING);
+                              cricket::ICEROLE_CONTROLLING, kTiebreakerDefault);
   auto rport = CreateTestPort(kLocalAddr2, "rfrag", "rpass",
-                              cricket::ICEROLE_CONTROLLED);
+                              cricket::ICEROLE_CONTROLLED, kTiebreakerDefault);
   lport->PrepareAddress();
   rport->PrepareAddress();
   ASSERT_FALSE(lport->Candidates().empty());
@@ -2549,7 +2579,7 @@ TEST_F(PortTest,
 // indications are allowed only to the connection which is in read mode.
 TEST_F(PortTest, TestHandleStunBindingIndication) {
   auto lport = CreateTestPort(kLocalAddr2, "lfrag", "lpass",
-                              cricket::ICEROLE_CONTROLLING);
+                              cricket::ICEROLE_CONTROLLING, kTiebreaker1);
 
   // Verifying encoding and decoding STUN indication message.
   std::unique_ptr<IceMessage> in_msg, out_msg;
@@ -2570,6 +2600,7 @@ TEST_F(PortTest, TestHandleStunBindingIndication) {
   // last_ping_received.
   auto rport = CreateTestPort(kLocalAddr2, "rfrag", "rpass");
   rport->SetIceRole(cricket::ICEROLE_CONTROLLED);
+  rport->SetIceTiebreaker(kTiebreaker2);
 
   lport->PrepareAddress();
   rport->PrepareAddress();
@@ -2604,6 +2635,7 @@ TEST_F(PortTest, TestHandleStunBindingIndication) {
 
 TEST_F(PortTest, TestComputeCandidatePriority) {
   auto port = CreateTestPort(kLocalAddr1, "name", "pass");
+  port->SetIceTiebreaker(kTiebreakerDefault);
   port->set_type_preference(90);
   port->set_component(177);
   port->AddCandidateAddress(SocketAddress("192.168.1.4", 1234));
@@ -2641,6 +2673,7 @@ TEST_F(PortTest, TestComputeCandidatePriorityWithPriorityAdjustment) {
   webrtc::test::ScopedKeyValueConfig field_trials(
       "WebRTC-IncreaseIceCandidatePriorityHostSrflx/Enabled/");
   auto port = CreateTestPort(kLocalAddr1, "name", "pass", &field_trials);
+  port->SetIceTiebreaker(kTiebreakerDefault);
   port->set_type_preference(90);
   port->set_component(177);
   port->AddCandidateAddress(SocketAddress("192.168.1.4", 1234));
@@ -2678,6 +2711,7 @@ TEST_F(PortTest, TestComputeCandidatePriorityWithPriorityAdjustment) {
 // Test that candidates with different types will have different foundation.
 TEST_F(PortTest, TestFoundation) {
   auto testport = CreateTestPort(kLocalAddr1, "name", "pass");
+  testport->SetIceTiebreaker(kTiebreakerDefault);
   testport->AddCandidateAddress(kLocalAddr1, kLocalAddr1,
                                 IceCandidateType::kHost,
                                 cricket::ICE_TYPE_PREFERENCE_HOST, false);
@@ -2800,9 +2834,11 @@ TEST_F(PortTest, TestCandidatePriority) {
 // Test the Connection priority is calculated correctly.
 TEST_F(PortTest, TestConnectionPriority) {
   auto lport = CreateTestPort(kLocalAddr1, "lfrag", "lpass");
+  lport->SetIceTiebreaker(kTiebreakerDefault);
   lport->set_type_preference(cricket::ICE_TYPE_PREFERENCE_HOST);
 
   auto rport = CreateTestPort(kLocalAddr2, "rfrag", "rpass");
+  rport->SetIceTiebreaker(kTiebreakerDefault);
   rport->set_type_preference(cricket::ICE_TYPE_PREFERENCE_RELAY_UDP);
   lport->set_component(123);
   lport->AddCandidateAddress(SocketAddress("192.168.1.4", 1234));
@@ -2840,9 +2876,11 @@ TEST_F(PortTest, TestConnectionPriorityWithPriorityAdjustment) {
   webrtc::test::ScopedKeyValueConfig field_trials(
       "WebRTC-IncreaseIceCandidatePriorityHostSrflx/Enabled/");
   auto lport = CreateTestPort(kLocalAddr1, "lfrag", "lpass", &field_trials);
+  lport->SetIceTiebreaker(kTiebreakerDefault);
   lport->set_type_preference(cricket::ICE_TYPE_PREFERENCE_HOST);
 
   auto rport = CreateTestPort(kLocalAddr2, "rfrag", "rpass", &field_trials);
+  rport->SetIceTiebreaker(kTiebreakerDefault);
   rport->set_type_preference(cricket::ICE_TYPE_PREFERENCE_RELAY_UDP);
   lport->set_component(123);
   lport->AddCandidateAddress(SocketAddress("192.168.1.4", 1234));
@@ -3047,12 +3085,13 @@ TEST_F(PortTest, TestTimeoutForNeverWritable) {
 // In this test `ch1` behaves like FULL mode client and we have created
 // port which responds to the ping message just like LITE client.
 TEST_F(PortTest, TestIceLiteConnectivity) {
-  auto ice_full_port = CreateTestPort(kLocalAddr1, "lfrag", "lpass",
-                                      cricket::ICEROLE_CONTROLLING);
+  auto ice_full_port =
+      CreateTestPort(kLocalAddr1, "lfrag", "lpass",
+                     cricket::ICEROLE_CONTROLLING, kTiebreaker1);
   auto* ice_full_port_ptr = ice_full_port.get();
 
-  auto ice_lite_port = CreateTestPort(kLocalAddr2, "rfrag", "rpass",
-                                      cricket::ICEROLE_CONTROLLED);
+  auto ice_lite_port = CreateTestPort(
+      kLocalAddr2, "rfrag", "rpass", cricket::ICEROLE_CONTROLLED, kTiebreaker2);
   // Setup TestChannel. This behaves like FULL mode client.
   TestChannel ch1(std::move(ice_full_port));
   ch1.SetIceMode(ICEMODE_FULL);
@@ -3158,11 +3197,12 @@ TEST_P(GoogPingTest, TestGoogPingAnnounceEnable) {
                    << trials.announce_goog_ping
                    << " enable:" << trials.enable_goog_ping;
 
-  auto port1_unique = CreateTestPort(kLocalAddr1, "lfrag", "lpass",
-                                     cricket::ICEROLE_CONTROLLING);
+  auto port1_unique =
+      CreateTestPort(kLocalAddr1, "lfrag", "lpass",
+                     cricket::ICEROLE_CONTROLLING, kTiebreaker1);
   auto* port1 = port1_unique.get();
   auto port2 = CreateTestPort(kLocalAddr2, "rfrag", "rpass",
-                              cricket::ICEROLE_CONTROLLED);
+                              cricket::ICEROLE_CONTROLLED, kTiebreaker2);
 
   TestChannel ch1(std::move(port1_unique));
   // Block usage of STUN_ATTR_USE_CANDIDATE so that
@@ -3248,11 +3288,12 @@ TEST_F(PortTest, TestGoogPingUnsupportedVersionInStunBinding) {
   trials.announce_goog_ping = true;
   trials.enable_goog_ping = true;
 
-  auto port1_unique = CreateTestPort(kLocalAddr1, "lfrag", "lpass",
-                                     cricket::ICEROLE_CONTROLLING);
+  auto port1_unique =
+      CreateTestPort(kLocalAddr1, "lfrag", "lpass",
+                     cricket::ICEROLE_CONTROLLING, kTiebreaker1);
   auto* port1 = port1_unique.get();
   auto port2 = CreateTestPort(kLocalAddr2, "rfrag", "rpass",
-                              cricket::ICEROLE_CONTROLLED);
+                              cricket::ICEROLE_CONTROLLED, kTiebreaker2);
 
   TestChannel ch1(std::move(port1_unique));
   // Block usage of STUN_ATTR_USE_CANDIDATE so that
@@ -3318,11 +3359,12 @@ TEST_F(PortTest, TestGoogPingUnsupportedVersionInStunBindingResponse) {
   trials.announce_goog_ping = true;
   trials.enable_goog_ping = true;
 
-  auto port1_unique = CreateTestPort(kLocalAddr1, "lfrag", "lpass",
-                                     cricket::ICEROLE_CONTROLLING);
+  auto port1_unique =
+      CreateTestPort(kLocalAddr1, "lfrag", "lpass",
+                     cricket::ICEROLE_CONTROLLING, kTiebreaker1);
   auto* port1 = port1_unique.get();
   auto port2 = CreateTestPort(kLocalAddr2, "rfrag", "rpass",
-                              cricket::ICEROLE_CONTROLLED);
+                              cricket::ICEROLE_CONTROLLED, kTiebreaker2);
 
   TestChannel ch1(std::move(port1_unique));
   // Block usage of STUN_ATTR_USE_CANDIDATE so that
@@ -3418,11 +3460,12 @@ TEST_F(PortTest, TestChangeInAttributeMakesGoogPingFallsbackToStunBinding) {
   trials.announce_goog_ping = true;
   trials.enable_goog_ping = true;
 
-  auto port1_unique = CreateTestPort(kLocalAddr1, "lfrag", "lpass",
-                                     cricket::ICEROLE_CONTROLLING);
+  auto port1_unique =
+      CreateTestPort(kLocalAddr1, "lfrag", "lpass",
+                     cricket::ICEROLE_CONTROLLING, kTiebreaker1);
   auto* port1 = port1_unique.get();
   auto port2 = CreateTestPort(kLocalAddr2, "rfrag", "rpass",
-                              cricket::ICEROLE_CONTROLLED);
+                              cricket::ICEROLE_CONTROLLED, kTiebreaker2);
 
   TestChannel ch1(std::move(port1_unique));
   // Block usage of STUN_ATTR_USE_CANDIDATE so that
@@ -3502,11 +3545,12 @@ TEST_F(PortTest, TestErrorResponseMakesGoogPingFallBackToStunBinding) {
   trials.announce_goog_ping = true;
   trials.enable_goog_ping = true;
 
-  auto port1_unique = CreateTestPort(kLocalAddr1, "lfrag", "lpass",
-                                     cricket::ICEROLE_CONTROLLING);
+  auto port1_unique =
+      CreateTestPort(kLocalAddr1, "lfrag", "lpass",
+                     cricket::ICEROLE_CONTROLLING, kTiebreaker1);
   auto* port1 = port1_unique.get();
   auto port2 = CreateTestPort(kLocalAddr2, "rfrag", "rpass",
-                              cricket::ICEROLE_CONTROLLED);
+                              cricket::ICEROLE_CONTROLLED, kTiebreaker2);
 
   TestChannel ch1(std::move(port1_unique));
   // Block usage of STUN_ATTR_USE_CANDIDATE so that
@@ -3597,11 +3641,13 @@ TEST_F(PortTest, TestPortTimeoutIfNotKeptAlive) {
   ConnectToSignalDestroyed(port1.get());
   port1->set_timeout_delay(timeout_delay);  // milliseconds
   port1->SetIceRole(cricket::ICEROLE_CONTROLLING);
+  port1->SetIceTiebreaker(kTiebreaker1);
 
   auto port2 = CreateUdpPort(kLocalAddr2);
   ConnectToSignalDestroyed(port2.get());
   port2->set_timeout_delay(timeout_delay);  // milliseconds
   port2->SetIceRole(cricket::ICEROLE_CONTROLLED);
+  port2->SetIceTiebreaker(kTiebreaker2);
 
   // Set up channels and ensure both ports will be deleted.
   TestChannel ch1(std::move(port1));
@@ -3624,12 +3670,14 @@ TEST_F(PortTest, TestPortTimeoutAfterNewConnectionCreatedAndDestroyed) {
   ConnectToSignalDestroyed(port1.get());
   port1->set_timeout_delay(timeout_delay);  // milliseconds
   port1->SetIceRole(cricket::ICEROLE_CONTROLLING);
+  port1->SetIceTiebreaker(kTiebreaker1);
 
   auto port2 = CreateUdpPort(kLocalAddr2);
   ConnectToSignalDestroyed(port2.get());
   port2->set_timeout_delay(timeout_delay);  // milliseconds
 
   port2->SetIceRole(cricket::ICEROLE_CONTROLLED);
+  port2->SetIceTiebreaker(kTiebreaker2);
 
   // Set up channels and ensure both ports will be deleted.
   TestChannel ch1(std::move(port1));
@@ -3663,11 +3711,13 @@ TEST_F(PortTest, TestPortNotTimeoutUntilPruned) {
   ConnectToSignalDestroyed(port1.get());
   port1->set_timeout_delay(timeout_delay);  // milliseconds
   port1->SetIceRole(cricket::ICEROLE_CONTROLLING);
+  port1->SetIceTiebreaker(kTiebreaker1);
 
   auto port2 = CreateUdpPort(kLocalAddr2);
   ConnectToSignalDestroyed(port2.get());
   port2->set_timeout_delay(timeout_delay);  // milliseconds
   port2->SetIceRole(cricket::ICEROLE_CONTROLLED);
+  port2->SetIceTiebreaker(kTiebreaker2);
   // The connection must not be destroyed before a connection is attempted.
   EXPECT_EQ(0, ports_destroyed());
 
@@ -3716,6 +3766,7 @@ TEST_F(PortTest, TestSupportsProtocol) {
 // on both the port itself and its candidates.
 TEST_F(PortTest, TestSetIceParameters) {
   auto port = CreateTestPort(kLocalAddr1, "ufrag1", "password1");
+  port->SetIceTiebreaker(kTiebreakerDefault);
   port->PrepareAddress();
   EXPECT_EQ(1UL, port->Candidates().size());
   port->SetIceParameters(1, "ufrag2", "password2");
@@ -3730,6 +3781,7 @@ TEST_F(PortTest, TestSetIceParameters) {
 
 TEST_F(PortTest, TestAddConnectionWithSameAddress) {
   auto port = CreateTestPort(kLocalAddr1, "ufrag1", "password1");
+  port->SetIceTiebreaker(kTiebreakerDefault);
   port->PrepareAddress();
   EXPECT_EQ(1u, port->Candidates().size());
   rtc::SocketAddress address("1.1.1.1", 5000);
@@ -3765,7 +3817,9 @@ class ConnectionTest : public PortTest {
     lport_ = CreateTestPort(kLocalAddr1, "lfrag", "lpass");
     rport_ = CreateTestPort(kLocalAddr2, "rfrag", "rpass");
     lport_->SetIceRole(cricket::ICEROLE_CONTROLLING);
+    lport_->SetIceTiebreaker(kTiebreaker1);
     rport_->SetIceRole(cricket::ICEROLE_CONTROLLED);
+    rport_->SetIceTiebreaker(kTiebreaker2);
 
     lport_->PrepareAddress();
     rport_->PrepareAddress();
diff --git a/p2p/base/stun_port_unittest.cc b/p2p/base/stun_port_unittest.cc
index 1277d58e38..423d16b11b 100644
--- a/p2p/base/stun_port_unittest.cc
+++ b/p2p/base/stun_port_unittest.cc
@@ -142,9 +142,9 @@ class StunPortTestBase : public ::testing::Test, public sigslot::has_slots<> {
          .network = &network_,
          .ice_username_fragment = rtc::CreateRandomString(16),
          .ice_password = rtc::CreateRandomString(22),
-         .field_trials = field_trials,
-         .ice_tiebreaker = kTiebreakerDefault},
+         .field_trials = field_trials},
         0, 0, stun_servers, absl::nullopt);
+    stun_port_->SetIceTiebreaker(kTiebreakerDefault);
     stun_port_->set_stun_keepalive_delay(stun_keepalive_delay_);
     // If `stun_keepalive_lifetime_` is negative, let the stun port
     // choose its lifetime from the network type.
@@ -179,10 +179,10 @@ class StunPortTestBase : public ::testing::Test, public sigslot::has_slots<> {
          .network = &network_,
          .ice_username_fragment = rtc::CreateRandomString(16),
          .ice_password = rtc::CreateRandomString(22),
-         .field_trials = field_trials,
-         .ice_tiebreaker = kTiebreakerDefault},
+         .field_trials = field_trials},
         socket_.get(), false, absl::nullopt);
     ASSERT_TRUE(stun_port_ != NULL);
+    stun_port_->SetIceTiebreaker(kTiebreakerDefault);
     ServerAddresses stun_servers;
     stun_servers.insert(server_addr);
     stun_port_->set_server_addresses(stun_servers);
diff --git a/p2p/base/tcp_port_unittest.cc b/p2p/base/tcp_port_unittest.cc
index fa3f7f329b..be246a8576 100644
--- a/p2p/base/tcp_port_unittest.cc
+++ b/p2p/base/tcp_port_unittest.cc
@@ -83,28 +83,29 @@ class TCPPortTest : public ::testing::Test, public sigslot::has_slots<> {
   }
 
   std::unique_ptr<TCPPort> CreateTCPPort(const SocketAddress& addr) {
-    return TCPPort::Create(
-        {
-            .network_thread = &main_,
-            .socket_factory = &socket_factory_,
-            .network = MakeNetwork(addr),
-            .ice_username_fragment = username_,
-            .ice_password = password_,
-            .field_trials = &field_trials_,
-            .ice_tiebreaker = kTiebreakerDefault,
-        },
-        0, 0, true);
+    auto port = std::unique_ptr<TCPPort>(
+        TCPPort::Create({.network_thread = &main_,
+                         .socket_factory = &socket_factory_,
+                         .network = MakeNetwork(addr),
+                         .ice_username_fragment = username_,
+                         .ice_password = password_,
+                         .field_trials = &field_trials_},
+                        0, 0, true));
+    port->SetIceTiebreaker(kTiebreakerDefault);
+    return port;
   }
 
   std::unique_ptr<TCPPort> CreateTCPPort(const rtc::Network* network) {
-    return TCPPort::Create({.network_thread = &main_,
-                            .socket_factory = &socket_factory_,
-                            .network = network,
-                            .ice_username_fragment = username_,
-                            .ice_password = password_,
-                            .field_trials = &field_trials_,
-                            .ice_tiebreaker = kTiebreakerDefault},
-                           0, 0, true);
+    auto port = std::unique_ptr<TCPPort>(
+        TCPPort::Create({.network_thread = &main_,
+                         .socket_factory = &socket_factory_,
+                         .network = network,
+                         .ice_username_fragment = username_,
+                         .ice_password = password_,
+                         .field_trials = &field_trials_},
+                        0, 0, true));
+    port->SetIceTiebreaker(kTiebreakerDefault);
+    return port;
   }
 
  protected:
diff --git a/p2p/base/turn_port.h b/p2p/base/turn_port.h
index 299a8980db..f8783d5daf 100644
--- a/p2p/base/turn_port.h
+++ b/p2p/base/turn_port.h
@@ -80,20 +80,17 @@ class TurnPort : public Port {
       return nullptr;
     }
     // Using `new` to access a non-public constructor.
-    return absl::WrapUnique(new TurnPort(
-        {
-            .network_thread = args.network_thread,
-            .socket_factory = args.socket_factory,
-            .network = args.network,
-            .ice_username_fragment = args.username,
-            .ice_password = args.password,
-            .field_trials = args.field_trials,
-            .ice_tiebreaker = args.ice_tiebreaker,
-        },
-        socket, *args.server_address, args.config->credentials,
-        args.relative_priority, args.config->tls_alpn_protocols,
-        args.config->tls_elliptic_curves, args.turn_customizer,
-        args.config->tls_cert_verifier));
+    return absl::WrapUnique(
+        new TurnPort({.network_thread = args.network_thread,
+                      .socket_factory = args.socket_factory,
+                      .network = args.network,
+                      .ice_username_fragment = args.username,
+                      .ice_password = args.password,
+                      .field_trials = args.field_trials},
+                     socket, *args.server_address, args.config->credentials,
+                     args.relative_priority, args.config->tls_alpn_protocols,
+                     args.config->tls_elliptic_curves, args.turn_customizer,
+                     args.config->tls_cert_verifier));
   }
 
   // Create a TURN port that will use a new socket, bound to `network` and
diff --git a/p2p/base/turn_port_unittest.cc b/p2p/base/turn_port_unittest.cc
index 1a62cf3751..66a154048b 100644
--- a/p2p/base/turn_port_unittest.cc
+++ b/p2p/base/turn_port_unittest.cc
@@ -295,7 +295,6 @@ class TurnPortTest : public ::testing::Test,
     args.config = &config;
     args.turn_customizer = turn_customizer_.get();
     args.field_trials = &field_trials_;
-    args.ice_tiebreaker = kTiebreakerDefault;
 
     turn_port_ = TurnPort::Create(args, 0, 0);
     if (!turn_port_) {
@@ -303,6 +302,7 @@ class TurnPortTest : public ::testing::Test,
     }
     // This TURN port will be the controlling.
     turn_port_->SetIceRole(ICEROLE_CONTROLLING);
+    turn_port_->SetIceTiebreaker(kTiebreakerDefault);
     ConnectSignals();
 
     if (server_address.proto == cricket::PROTO_TLS) {
@@ -343,10 +343,10 @@ class TurnPortTest : public ::testing::Test,
     args.config = &config;
     args.turn_customizer = turn_customizer_.get();
     args.field_trials = &field_trials_;
-    args.ice_tiebreaker = kTiebreakerDefault;
     turn_port_ = TurnPort::Create(args, socket_.get());
     // This TURN port will be the controlling.
     turn_port_->SetIceRole(ICEROLE_CONTROLLING);
+    turn_port_->SetIceTiebreaker(kTiebreakerDefault);
     ConnectSignals();
   }
 
@@ -371,11 +371,11 @@ class TurnPortTest : public ::testing::Test,
                                  .network = MakeNetwork(address),
                                  .ice_username_fragment = kIceUfrag2,
                                  .ice_password = kIcePwd2,
-                                 .field_trials = &field_trials_,
-                                 .ice_tiebreaker = kTiebreakerDefault},
+                                 .field_trials = &field_trials_},
                                 0, 0, false, absl::nullopt);
     // UDP port will be controlled.
     udp_port_->SetIceRole(ICEROLE_CONTROLLED);
+    udp_port_->SetIceTiebreaker(kTiebreakerDefault);
     udp_port_->SignalPortComplete.connect(this,
                                           &TurnPortTest::OnUdpPortComplete);
   }
diff --git a/p2p/client/basic_port_allocator.cc b/p2p/client/basic_port_allocator.cc
index ae136fe35f..f1525b0589 100644
--- a/p2p/client/basic_port_allocator.cc
+++ b/p2p/client/basic_port_allocator.cc
@@ -1475,8 +1475,7 @@ void AllocationSequence::CreateUDPPorts() {
          .network = network_,
          .ice_username_fragment = session_->username(),
          .ice_password = session_->password(),
-         .field_trials = session_->allocator()->field_trials(),
-         .ice_tiebreaker = session_->allocator()->ice_tiebreaker()},
+         .field_trials = session_->allocator()->field_trials()},
         udp_socket_.get(), emit_local_candidate_for_anyaddress,
         session_->allocator()->stun_candidate_keepalive_interval());
   } else {
@@ -1486,14 +1485,14 @@ void AllocationSequence::CreateUDPPorts() {
          .network = network_,
          .ice_username_fragment = session_->username(),
          .ice_password = session_->password(),
-         .field_trials = session_->allocator()->field_trials(),
-         .ice_tiebreaker = session_->allocator()->ice_tiebreaker()},
+         .field_trials = session_->allocator()->field_trials()},
         session_->allocator()->min_port(), session_->allocator()->max_port(),
         emit_local_candidate_for_anyaddress,
         session_->allocator()->stun_candidate_keepalive_interval());
   }
 
   if (port) {
+    port->SetIceTiebreaker(session_->allocator()->ice_tiebreaker());
     // If shared socket is enabled, STUN candidate will be allocated by the
     // UDPPort.
     if (IsFlagSet(PORTALLOCATOR_ENABLE_SHARED_SOCKET)) {
@@ -1528,12 +1527,12 @@ void AllocationSequence::CreateTCPPorts() {
        .network = network_,
        .ice_username_fragment = session_->username(),
        .ice_password = session_->password(),
-       .field_trials = session_->allocator()->field_trials(),
-       .ice_tiebreaker = session_->allocator()->ice_tiebreaker()},
+       .field_trials = session_->allocator()->field_trials()},
       session_->allocator()->min_port(), session_->allocator()->max_port(),
 
       session_->allocator()->allow_tcp_listen());
   if (port) {
+    port->SetIceTiebreaker(session_->allocator()->ice_tiebreaker());
     session_->AddAllocatedPort(port.release(), this);
     // Since TCPPort is not created using shared socket, `port` will not be
     // added to the dequeue.
@@ -1562,12 +1561,12 @@ void AllocationSequence::CreateStunPorts() {
        .network = network_,
        .ice_username_fragment = session_->username(),
        .ice_password = session_->password(),
-       .field_trials = session_->allocator()->field_trials(),
-       .ice_tiebreaker = session_->allocator()->ice_tiebreaker()},
+       .field_trials = session_->allocator()->field_trials()},
       session_->allocator()->min_port(), session_->allocator()->max_port(),
       config_->StunServers(),
       session_->allocator()->stun_candidate_keepalive_interval());
   if (port) {
+    port->SetIceTiebreaker(session_->allocator()->ice_tiebreaker());
     session_->AddAllocatedPort(port.release(), this);
     // Since StunPort is not created using shared socket, `port` will not be
     // added to the dequeue.
@@ -1635,7 +1634,6 @@ void AllocationSequence::CreateTurnPort(const RelayServerConfig& config,
     args.turn_customizer = session_->allocator()->turn_customizer();
     args.field_trials = session_->allocator()->field_trials();
     args.relative_priority = relative_priority;
-    args.ice_tiebreaker = session_->allocator()->ice_tiebreaker();
 
     std::unique_ptr<cricket::Port> port;
     // Shared socket mode must be enabled only for UDP based ports. Hence
@@ -1671,6 +1669,7 @@ void AllocationSequence::CreateTurnPort(const RelayServerConfig& config,
       }
     }
     RTC_DCHECK(port != NULL);
+    port->SetIceTiebreaker(session_->allocator()->ice_tiebreaker());
     session_->AddAllocatedPort(port.release(), this);
   }
 }
diff --git a/p2p/client/relay_port_factory_interface.h b/p2p/client/relay_port_factory_interface.h
index bdc8c3d448..edfca3697b 100644
--- a/p2p/client/relay_port_factory_interface.h
+++ b/p2p/client/relay_port_factory_interface.h
@@ -49,7 +49,6 @@ struct CreateRelayPortArgs {
   // to the candidates from other servers. Required because ICE priorities
   // need to be unique.
   int relative_priority = 0;
-  uint64_t ice_tiebreaker = 0;
 };
 
 // A factory for creating RelayPort's.
