From: Alessio Bazzica <alessiob@webrtc.org>
Date: Wed, 13 Nov 2024 13:49:30 +0100
Subject: (cherry-pick-branch-heads/6834) With stereo decoding and mono packets
 produce mono after CN/PLC
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

The workaround in https://webrtc-review.googlesource.com/c/src/+/367740
is incomplete because it does not fix the issue for the first decoded
mono packet after CN/PLC. This CL extends the workaround to such a case
and adds a unit test for it.

Note: it was verified that the 2nd packet after CN/PLC is trivial
stereo.

Credits: jakobi@webrtc.org for raising the concern

(cherry picked from commit ebb11c4c87e4c0288d1ac18f38b4efa4254b3c6a)

Bug: chromium:378896415
Change-Id: Ide27e411781693f14629cf9db8b6c0c0fc762a17
Reviewed-on: https://webrtc-review.googlesource.com/c/src/+/368160
Reviewed-by: Jakob Ivarssonâ€Ž <jakobi@webrtc.org>
Commit-Queue: Alessio Bazzica <alessiob@webrtc.org>
Cr-Original-Commit-Position: refs/heads/main@{#43393}
Reviewed-on: https://webrtc-review.googlesource.com/c/src/+/368560
Reviewed-by: Henrik Lundin <henrik.lundin@webrtc.org>
Cr-Commit-Position: refs/branch-heads/6834@{#1}
Cr-Branched-From: a5d71009ac1dce7da23813dc9413c03073cfa8ca-refs/heads/main@{#43387}
---
 modules/audio_coding/BUILD.gn                 |  1 +
 .../opus/audio_decoder_opus_unittest.cc       | 83 ++++++++++++++++---
 .../codecs/opus/opus_interface.cc             | 30 ++++---
 3 files changed, 88 insertions(+), 26 deletions(-)

diff --git a/modules/audio_coding/BUILD.gn b/modules/audio_coding/BUILD.gn
index a2a1ca8328..78bdccfefe 100644
--- a/modules/audio_coding/BUILD.gn
+++ b/modules/audio_coding/BUILD.gn
@@ -1505,6 +1505,7 @@ if (rtc_include_tests) {
         "../../test:test_support",
         "codecs/opus/test",
         "codecs/opus/test:test_unittest",
+        "//testing/gmock",
         "//testing/gtest",
         "//third_party/abseil-cpp/absl/flags:flag",
         "//third_party/abseil-cpp/absl/memory",
diff --git a/modules/audio_coding/codecs/opus/audio_decoder_opus_unittest.cc b/modules/audio_coding/codecs/opus/audio_decoder_opus_unittest.cc
index 71f0d38b25..998b88a105 100644
--- a/modules/audio_coding/codecs/opus/audio_decoder_opus_unittest.cc
+++ b/modules/audio_coding/codecs/opus/audio_decoder_opus_unittest.cc
@@ -28,6 +28,7 @@
 #include "rtc_base/checks.h"
 #include "rtc_base/random.h"
 #include "test/explicit_key_value_config.h"
+#include "test/gmock.h"
 #include "test/gtest.h"
 #include "test/testsupport/file_utils.h"
 
@@ -35,6 +36,7 @@ namespace webrtc {
 namespace {
 
 using test::ExplicitKeyValueConfig;
+using testing::SizeIs;
 
 using DecodeResult = ::webrtc::AudioDecoder::EncodedAudioFrame::DecodeResult;
 using ParseResult = ::webrtc::AudioDecoder::ParseResult;
@@ -158,7 +160,6 @@ void EncodeDecodeNoiseUntilDecoderInDtxMode(AudioEncoderOpusImpl& encoder,
   std::vector<int16_t> decoded_frame(kEncoderFrameLength *
                                      decoder_num_channels);
 
-  bool dtx_packet_found = false;
   for (int i = 0; i < 50; ++i) {
     generator.GenerateNextFrame(input_frame);
     rtc::Buffer payload;
@@ -170,8 +171,9 @@ void EncodeDecodeNoiseUntilDecoderInDtxMode(AudioEncoderOpusImpl& encoder,
       continue;
     }
 
-    // Decode `payload`. If not a DTX packet, decoding it may update the
-    // internal decoder parameters for comfort noise generation.
+    // Decode `payload`. If it encodes a DTX packet (i.e., 1 byte payload), the
+    // decoder will switch to DTX mode. Otherwise, it may update the internal
+    // decoder parameters for comfort noise generation.
     std::vector<ParseResult> parse_results =
         decoder.ParsePayload(std::move(payload), timestamp++);
     RTC_CHECK_EQ(parse_results.size(), 1);
@@ -179,14 +181,62 @@ void EncodeDecodeNoiseUntilDecoderInDtxMode(AudioEncoderOpusImpl& encoder,
         parse_results[0].frame->Decode(decoded_frame);
     RTC_CHECK(decode_results);
     RTC_CHECK_EQ(decode_results->num_decoded_samples, decoded_frame.size());
-
     if (parse_results[0].frame->IsDtxPacket()) {
-      // The decoder is now in DTX mode.
-      dtx_packet_found = true;
+      return;
+    }
+  }
+  RTC_CHECK_NOTREACHED();
+}
+
+// Generates packets by encoding speech frames and decodes them until a non-DTX
+// packet is generated and, when that condition is met, returns the decoded
+// audio samples.
+std::vector<int16_t> EncodeDecodeSpeechUntilOneFrameIsDecoded(
+    AudioEncoderOpusImpl& encoder,
+    AudioDecoderOpusImpl& decoder,
+    uint32_t& rtp_timestamp,
+    uint32_t& timestamp) {
+  RTC_CHECK(encoder.NumChannels() == 1 || encoder.NumChannels() == 2);
+  const bool stereo_encoding = encoder.NumChannels() == 2;
+  const size_t decoder_num_channels = decoder.Channels();
+  std::vector<int16_t> decoded_frame(kEncoderFrameLength *
+                                     decoder_num_channels);
+
+  PCMFile pcm_file;
+  pcm_file.Open(test::ResourcePath(
+                    stereo_encoding ? "near48_stereo" : "near48_mono", "pcm"),
+                kSampleRateHz, "rb");
+  pcm_file.ReadStereo(stereo_encoding);
+
+  AudioFrame audio_frame;
+  while (true) {
+    if (pcm_file.EndOfFile()) {
       break;
     }
+    pcm_file.Read10MsData(audio_frame);
+    rtc::Buffer payload;
+    encoder.Encode(rtp_timestamp++, audio_frame.data_view().data(), &payload);
+
+    // Ignore empty payloads: the encoder needs more audio to produce a packet.
+    if (payload.size() == 0) {
+      continue;
+    }
+
+    // Decode `payload`.
+    std::vector<ParseResult> parse_results =
+        decoder.ParsePayload(std::move(payload), timestamp++);
+    RTC_CHECK_EQ(parse_results.size(), 1);
+    std::optional<DecodeResult> decode_results =
+        parse_results[0].frame->Decode(decoded_frame);
+    RTC_CHECK(decode_results);
+
+    if (parse_results[0].frame->IsDtxPacket()) {
+      continue;
+    }
+    RTC_CHECK_EQ(decode_results->num_decoded_samples, decoded_frame.size());
+    return decoded_frame;
   }
-  RTC_CHECK(dtx_packet_found);
+  RTC_CHECK_NOTREACHED();
 }
 
 }  // namespace
@@ -239,6 +289,7 @@ TEST(AudioDecoderOpusTest,
   constexpr size_t kDecoderNumChannels = 2;
   AudioDecoderOpusImpl decoder(env.field_trials(), kDecoderNumChannels,
                                kSampleRateHz);
+  std::vector<int16_t> decoded_frame;
 
   uint32_t rtp_timestamp = 0xFFFu;
   uint32_t timestamp = 0;
@@ -250,7 +301,7 @@ TEST(AudioDecoderOpusTest,
                                          timestamp);
 
   // Decode an empty packet so that Opus generates comfort noise.
-  std::array<int16_t, kEncoderFrameLength * kDecoderNumChannels> decoded_frame;
+  decoded_frame.resize(kEncoderFrameLength * kDecoderNumChannels);
   AudioDecoder::SpeechType speech_type;
   const int num_decoded_samples =
       decoder.Decode(/*encoded=*/nullptr, /*encoded_len=*/0, kSampleRateHz,
@@ -262,8 +313,14 @@ TEST(AudioDecoderOpusTest,
                                              num_decoded_samples);
   // Make sure that comfort noise is not a muted frame.
   ASSERT_FALSE(IsZeroedFrame(decoded_view));
-
   EXPECT_TRUE(IsTrivialStereo(decoded_view));
+
+  // Also check the first decoded audio frame after comfort noise.
+  decoded_frame = EncodeDecodeSpeechUntilOneFrameIsDecoded(
+      encoder, decoder, rtp_timestamp, timestamp);
+  ASSERT_THAT(decoded_frame, SizeIs(kDecoderNumChannels * kEncoderFrameLength));
+  ASSERT_FALSE(IsZeroedFrame(decoded_frame));
+  EXPECT_TRUE(IsTrivialStereo(decoded_frame));
 }
 
 TEST(AudioDecoderOpusTest, MonoEncoderStereoDecoderOutputsTrivialStereoPlc) {
@@ -296,8 +353,14 @@ TEST(AudioDecoderOpusTest, MonoEncoderStereoDecoderOutputsTrivialStereoPlc) {
                                              concealment_audio.size());
   // Make sure that packet loss concealment is not a muted frame.
   ASSERT_FALSE(IsZeroedFrame(decoded_view));
-
   EXPECT_TRUE(IsTrivialStereo(decoded_view));
+
+  // Also check the first decoded audio frame after packet loss concealment.
+  std::vector<int16_t> decoded_frame = EncodeDecodeSpeechUntilOneFrameIsDecoded(
+      encoder, decoder, rtp_timestamp, timestamp);
+  ASSERT_THAT(decoded_frame, SizeIs(kDecoderNumChannels * kEncoderFrameLength));
+  ASSERT_FALSE(IsZeroedFrame(decoded_frame));
+  EXPECT_TRUE(IsTrivialStereo(decoded_frame));
 }
 
 TEST(AudioDecoderOpusTest,
diff --git a/modules/audio_coding/codecs/opus/opus_interface.cc b/modules/audio_coding/codecs/opus/opus_interface.cc
index 565f803741..d18b517fe4 100644
--- a/modules/audio_coding/codecs/opus/opus_interface.cc
+++ b/modules/audio_coding/codecs/opus/opus_interface.cc
@@ -547,22 +547,9 @@ int WebRtcOpus_Decode(OpusDecInst* inst,
                       int16_t* decoded,
                       int16_t* audio_type) {
   int decoded_samples_per_channel;
-
   if (encoded_bytes == 0) {
     *audio_type = DetermineAudioType(inst, encoded_bytes);
     decoded_samples_per_channel = DecodePlc(inst, decoded);
-
-    // TODO: https://issues.webrtc.org/376493209 - When fixed, remove block
-    // below.
-    if (inst->channels == 2 && inst->last_packet_num_channels == 1) {
-      // Stereo decoding is enabled and the last observed packet to decode
-      // encoded mono audio. In this case, Opus generates non-trivial stereo
-      // audio. Since this is unwanted, copy the left channel into the right
-      // one.
-      for (int i = 0; i < decoded_samples_per_channel << 1; i += 2) {
-        decoded[i + 1] = decoded[i];
-      }
-    }
   } else {
     decoded_samples_per_channel = DecodeNative(
         inst, encoded, encoded_bytes,
@@ -570,14 +557,25 @@ int WebRtcOpus_Decode(OpusDecInst* inst,
 
     // TODO: https://issues.webrtc.org/376493209 - When fixed, remove block
     // below.
-    const int num_channels = opus_packet_get_nb_channels(encoded);
-    RTC_DCHECK(num_channels == 1 || num_channels == 2);
-    inst->last_packet_num_channels = num_channels;
+    inst->last_packet_num_channels = opus_packet_get_nb_channels(encoded);
+    RTC_DCHECK(inst->last_packet_num_channels == 1 ||
+               inst->last_packet_num_channels == 2);
   }
   if (decoded_samples_per_channel < 0) {
     return -1;
   }
 
+  // TODO: https://issues.webrtc.org/376493209 - When fixed, remove block below.
+  // When stereo decoding is enabled and the last observed non-empty packet
+  // encoded mono audio, the Opus decoder may generate non-trivial stereo audio.
+  // As that is undesired, in that case make sure that `decoded` contains
+  // trivial stereo audio by copying the left channel into the right one.
+  if (inst->channels == 2 && inst->last_packet_num_channels == 1) {
+    for (int i = 0; i < decoded_samples_per_channel << 1; i += 2) {
+      decoded[i + 1] = decoded[i];
+    }
+  }
+
   return decoded_samples_per_channel;
 }
 
