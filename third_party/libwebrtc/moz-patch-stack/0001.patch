From: Michael Froman <mjfroman@mac.com>
Date: Wed, 4 Dec 2024 22:02:06 -0600
Subject: (tmp-cherry-pick) Revert "Rename `requested_resolution` to
 `scale_resolution_down_to`." (af44d8ff06)
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This reverts commit 82617ac51e7825db53451818f4d1ad52b69761fd.

Reason for revert: Break downstream projects

Original change's description:
> Rename `requested_resolution` to `scale_resolution_down_to`.
>
> This is a pure refactor/rename CL without any changes in behavior.
>
> This field is called scaleResolutionDownTo in the spec and JavaScript.
> Let's make C++ match to avoid confusion.
>
> In order not to break downstream during the transition a variable with
> the old name being a pure reference to the renamed attribute is added.
> This means we have to add custom constructors, but we can change this
> back to "= default" when the transition is completed, which should only
> be a couple of CLs away.
>
> Bug: webrtc:375048799
> Change-Id: If755102ccd79d46020ce5b33acd3dfcc29799e47
> Reviewed-on: https://webrtc-review.googlesource.com/c/src/+/366560
> Reviewed-by: Ilya Nikolaevskiy <ilnik@webrtc.org>
> Reviewed-by: Henrik Andreassson <henrika@webrtc.org>
> Commit-Queue: Henrik Bostr√∂m <hbos@webrtc.org>
> Cr-Commit-Position: refs/heads/main@{#43300}

Bug: webrtc:375048799
Change-Id: Ie41723a39420e12e7b5b681d3d00ccd14f66b4b1
No-Presubmit: true
No-Tree-Checks: true
No-Try: true
Reviewed-on: https://webrtc-review.googlesource.com/c/src/+/366642
Reviewed-by: Harald Alvestrand <hta@webrtc.org>
Commit-Queue: Florent Castelli <orphis@webrtc.org>
Bot-Commit: rubber-stamper@appspot.gserviceaccount.com <rubber-stamper@appspot.gserviceaccount.com>
Cr-Commit-Position: refs/heads/main@{#43301}
---
 api/rtp_parameters.cc                         |  24 +---
 api/rtp_parameters.h                          |  49 +++----
 api/video/video_source_interface.h            |  10 +-
 media/base/media_engine.cc                    |  14 +-
 media/base/video_adapter.cc                   |  73 +++++-----
 media/base/video_adapter.h                    |   8 +-
 media/base/video_adapter_unittest.cc          |  77 ++++++-----
 media/base/video_broadcaster.cc               |  31 +++--
 media/base/video_broadcaster_unittest.cc      |  39 +++---
 media/engine/webrtc_video_engine.cc           |  10 +-
 media/engine/webrtc_video_engine_unittest.cc  |  72 +++++-----
 ...er_connection_encodings_integrationtest.cc | 126 ++++++++----------
 video/config/encoder_stream_factory.cc        |  52 ++++----
 video/config/encoder_stream_factory.h         |   4 +-
 .../config/encoder_stream_factory_unittest.cc |  73 +++++-----
 video/config/video_encoder_config.cc          |   4 +-
 video/config/video_encoder_config.h           |  10 +-
 video/video_source_sink_controller.cc         |  12 +-
 video/video_source_sink_controller.h          |   9 +-
 .../video_source_sink_controller_unittest.cc  |  12 +-
 video/video_stream_encoder.cc                 |  38 +++---
 video/video_stream_encoder_unittest.cc        |  44 +++---
 22 files changed, 358 insertions(+), 433 deletions(-)

diff --git a/api/rtp_parameters.cc b/api/rtp_parameters.cc
index 6b550d0fbf..178aeb8b66 100644
--- a/api/rtp_parameters.cc
+++ b/api/rtp_parameters.cc
@@ -106,27 +106,9 @@ RtpRtxParameters::RtpRtxParameters(uint32_t ssrc) : ssrc(ssrc) {}
 RtpRtxParameters::RtpRtxParameters(const RtpRtxParameters& rhs) = default;
 RtpRtxParameters::~RtpRtxParameters() = default;
 
-// TODO(https://crbug.com/webrtc/375048799): Use "= default" when
-// `requested_resolution` has been deleted
-RtpEncodingParameters::RtpEncodingParameters()
-    : requested_resolution(scale_resolution_down_to) {}
-RtpEncodingParameters::RtpEncodingParameters(const RtpEncodingParameters& rhs)
-    : ssrc(rhs.ssrc),
-      bitrate_priority(rhs.bitrate_priority),
-      network_priority(rhs.network_priority),
-      max_bitrate_bps(rhs.max_bitrate_bps),
-      min_bitrate_bps(rhs.min_bitrate_bps),
-      max_framerate(rhs.max_framerate),
-      num_temporal_layers(rhs.num_temporal_layers),
-      scale_resolution_down_by(rhs.scale_resolution_down_by),
-      scalability_mode(rhs.scalability_mode),
-      scale_resolution_down_to(rhs.scale_resolution_down_to),
-      requested_resolution(scale_resolution_down_to),
-      active(rhs.active),
-      rid(rhs.rid),
-      request_key_frame(rhs.request_key_frame),
-      adaptive_ptime(rhs.adaptive_ptime),
-      codec(rhs.codec) {}
+RtpEncodingParameters::RtpEncodingParameters() = default;
+RtpEncodingParameters::RtpEncodingParameters(const RtpEncodingParameters& rhs) =
+    default;
 RtpEncodingParameters::~RtpEncodingParameters() = default;
 
 RtpCodecParameters::RtpCodecParameters() = default;
diff --git a/api/rtp_parameters.h b/api/rtp_parameters.h
index b82e5b6745..ec2243dc85 100644
--- a/api/rtp_parameters.h
+++ b/api/rtp_parameters.h
@@ -497,22 +497,23 @@ struct RTC_EXPORT RtpEncodingParameters {
   // https://w3c.github.io/webrtc-svc/#rtcrtpencodingparameters
   std::optional<std::string> scalability_mode;
 
-  // This is an alternative API to `scale_resolution_down_by` but expressed in
-  // absolute terms (max width and max height) as opposed to relative terms (a
-  // scaling factor that is relative to the input frame size).
+  // Requested encode resolution.
   //
-  // If both `scale_resolution_down_by` and `scale_resolution_down_to` are
-  // specified, the "scale by" value is ignored.
+  // This field provides an alternative to `scale_resolution_down_by`
+  // that is not dependent on the video source.
   //
-  // See spec:
-  // https://w3c.github.io/webrtc-extensions/#dom-rtcrtpencodingparameters-scaleresolutiondownto
+  // When setting requested_resolution it is not necessary to adapt the
+  // video source using OnOutputFormatRequest, since the VideoStreamEncoder
+  // will apply downscaling if necessary. requested_resolution will also be
+  // propagated to the video source, this allows downscaling earlier in the
+  // pipeline which can be beneficial if the source is consumed by multiple
+  // encoders, but is not strictly necessary.
   //
-  // This was previously known as "requested_resolution" in C++.
-  std::optional<Resolution> scale_resolution_down_to;
-  // Alternative name for `scale_resolution_down_to`.
-  // TODO(https://crbug.com/webrtc/375048799): Delete when downstream projects
-  // have migrated from `requested_resolution` to `scale_resolution_down_to`.
-  std::optional<Resolution>& requested_resolution;
+  // The `requested_resolution` is subject to resource adaptation.
+  //
+  // It is an error to set both `requested_resolution` and
+  // `scale_resolution_down_by`.
+  std::optional<Resolution> requested_resolution;
 
   // For an RtpSender, set to true to cause this encoding to be encoded and
   // sent, and false for it not to be encoded and sent. This allows control
@@ -544,31 +545,11 @@ struct RTC_EXPORT RtpEncodingParameters {
            scale_resolution_down_by == o.scale_resolution_down_by &&
            active == o.active && rid == o.rid &&
            adaptive_ptime == o.adaptive_ptime &&
-           scale_resolution_down_to == o.scale_resolution_down_to &&
-           codec == o.codec;
+           requested_resolution == o.requested_resolution && codec == o.codec;
   }
   bool operator!=(const RtpEncodingParameters& o) const {
     return !(*this == o);
   }
-  // TODO(https://crbug.com/webrtc/375048799): Delete this operator overload
-  // when `requested_resolution` has been deleted in favor of auto generated op.
-  void operator=(const RtpEncodingParameters& o) {
-    ssrc = o.ssrc;
-    bitrate_priority = o.bitrate_priority;
-    network_priority = o.network_priority;
-    max_bitrate_bps = o.max_bitrate_bps;
-    min_bitrate_bps = o.min_bitrate_bps;
-    max_framerate = o.max_framerate;
-    num_temporal_layers = o.num_temporal_layers;
-    scale_resolution_down_by = o.scale_resolution_down_by;
-    scalability_mode = o.scalability_mode;
-    scale_resolution_down_to = o.scale_resolution_down_to;
-    active = o.active;
-    rid = o.rid;
-    request_key_frame = o.request_key_frame;
-    adaptive_ptime = o.adaptive_ptime;
-    codec = o.codec;
-  }
 };
 
 struct RTC_EXPORT RtpCodecParameters : public RtpCodec {
diff --git a/api/video/video_source_interface.h b/api/video/video_source_interface.h
index 1ef53a63bc..d85e56bd8c 100644
--- a/api/video/video_source_interface.h
+++ b/api/video/video_source_interface.h
@@ -83,11 +83,11 @@ struct RTC_EXPORT VideoSinkWants {
   std::vector<FrameSize> resolutions;
 
   // This is the resolution requested by the user using RtpEncodingParameters.
-  std::optional<FrameSize> scale_resolution_down_to;
+  std::optional<FrameSize> requested_resolution;
 
   // `is_active` : Is this VideoSinkWants from an encoder that is encoding any
   // layer. IF YES, it will affect how the VideoAdapter will choose to
-  // prioritize the OnOutputFormatRequest vs. scale_resolution_down_to. IF NO,
+  // prioritize the OnOutputFormatRequest vs. requested_resolution. IF NO,
   // VideoAdapter consider this VideoSinkWants as a passive listener (e.g a
   // VideoRenderer or a VideoEncoder that is not currently actively encoding).
   bool is_active = false;
@@ -96,11 +96,11 @@ struct RTC_EXPORT VideoSinkWants {
   // that aggregates several VideoSinkWants (and sends them to
   // AdaptedVideoTrackSource).
   struct Aggregates {
-    // `any_active_without_scale_resolution_down_to` is set by VideoBroadcaster
+    // `active_without_requested_resolution` is set by VideoBroadcaster
     // when aggregating sink wants if there exists any sink (encoder) that is
-    // active but has not set the `scale_resolution_down_to`, i.e is relying on
+    // active but has not set the `requested_resolution`, i.e is relying on
     // OnOutputFormatRequest to handle encode resolution.
-    bool any_active_without_scale_resolution_down_to = false;
+    bool any_active_without_requested_resolution = false;
   };
   std::optional<Aggregates> aggregates;
 };
diff --git a/media/base/media_engine.cc b/media/base/media_engine.cc
index 0ce26ff9b6..0b4b9302f5 100644
--- a/media/base/media_engine.cc
+++ b/media/base/media_engine.cc
@@ -160,7 +160,7 @@ webrtc::RTCError CheckRtpParametersValues(
     const webrtc::FieldTrialsView& field_trials) {
   using webrtc::RTCErrorType;
 
-  bool has_scale_resolution_down_to = false;
+  bool has_requested_resolution = false;
   for (size_t i = 0; i < rtp_parameters.encodings.size(); ++i) {
     if (rtp_parameters.encodings[i].bitrate_priority <= 0) {
       LOG_AND_RETURN_ERROR(RTCErrorType::INVALID_RANGE,
@@ -199,10 +199,10 @@ webrtc::RTCError CheckRtpParametersValues(
       }
     }
 
-    if (rtp_parameters.encodings[i].scale_resolution_down_to.has_value()) {
-      has_scale_resolution_down_to = true;
-      if (rtp_parameters.encodings[i].scale_resolution_down_to->width <= 0 ||
-          rtp_parameters.encodings[i].scale_resolution_down_to->height <= 0) {
+    if (rtp_parameters.encodings[i].requested_resolution.has_value()) {
+      has_requested_resolution = true;
+      if (rtp_parameters.encodings[i].requested_resolution->width <= 0 ||
+          rtp_parameters.encodings[i].requested_resolution->height <= 0) {
         LOG_AND_RETURN_ERROR(RTCErrorType::INVALID_MODIFICATION,
                              "The resolution dimensions must be positive.");
       }
@@ -218,11 +218,11 @@ webrtc::RTCError CheckRtpParametersValues(
     }
   }
 
-  if (has_scale_resolution_down_to &&
+  if (has_requested_resolution &&
       absl::c_any_of(rtp_parameters.encodings,
                      [](const webrtc::RtpEncodingParameters& encoding) {
                        return encoding.active &&
-                              !encoding.scale_resolution_down_to.has_value();
+                              !encoding.requested_resolution.has_value();
                      })) {
     LOG_AND_RETURN_ERROR(RTCErrorType::INVALID_MODIFICATION,
                          "If a resolution is specified on any encoding then "
diff --git a/media/base/video_adapter.cc b/media/base/video_adapter.cc
index 12ea800d41..22ce693cbe 100644
--- a/media/base/video_adapter.cc
+++ b/media/base/video_adapter.cc
@@ -244,30 +244,27 @@ bool VideoAdapter::AdaptFrameResolution(int in_width,
   RTC_DCHECK_EQ(0, *out_height % resolution_alignment_);
 
   // Lastly, make the output size fit within the resolution restrictions as
-  // specified by `scale_resolution_down_to_`. This does not modify aspect ratio
-  // or cropping, only `out_width` and `out_height`.
-  if (scale_resolution_down_to_.has_value()) {
-    // Make frame and "scale to" have matching orientation.
-    webrtc::Resolution scale_resolution_down_to =
-        scale_resolution_down_to_.value();
-    if ((*out_width < *out_height) != (scale_resolution_down_to_->width <
-                                       scale_resolution_down_to_->height)) {
-      scale_resolution_down_to = {.width = scale_resolution_down_to_->height,
-                                  .height = scale_resolution_down_to_->width};
+  // specified by `requested_resolution_`. This does not modify aspect ratio or
+  // cropping, only `out_width` and `out_height`.
+  if (requested_resolution_.has_value()) {
+    // Make frame and requested resolution have matching orientation.
+    webrtc::Resolution requested_resolution = requested_resolution_.value();
+    if ((*out_width < *out_height) !=
+        (requested_resolution_->width < requested_resolution_->height)) {
+      requested_resolution = {.width = requested_resolution_->height,
+                              .height = requested_resolution_->width};
     }
     // Downscale by smallest scaling factor, if necessary.
     if (*out_width > 0 && *out_height > 0 &&
-        (scale_resolution_down_to.width < *out_width ||
-         scale_resolution_down_to.height < *out_height)) {
+        (requested_resolution.width < *out_width ||
+         requested_resolution.height < *out_height)) {
       double scale_factor = std::min(
-          scale_resolution_down_to.width / static_cast<double>(*out_width),
-          scale_resolution_down_to.height / static_cast<double>(*out_height));
-      *out_width =
-          roundUp(std::round(*out_width * scale_factor), resolution_alignment_,
-                  scale_resolution_down_to.width);
-      *out_height =
-          roundUp(std::round(*out_height * scale_factor), resolution_alignment_,
-                  scale_resolution_down_to.height);
+          requested_resolution.width / static_cast<double>(*out_width),
+          requested_resolution.height / static_cast<double>(*out_height));
+      *out_width = roundUp(std::round(*out_width * scale_factor),
+                           resolution_alignment_, requested_resolution.width);
+      *out_height = roundUp(std::round(*out_height * scale_factor),
+                            resolution_alignment_, requested_resolution.height);
       RTC_DCHECK_EQ(0, *out_width % resolution_alignment_);
       RTC_DCHECK_EQ(0, *out_height % resolution_alignment_);
     }
@@ -349,7 +346,7 @@ void VideoAdapter::OnOutputFormatRequest(
   if (stashed_output_format_request_) {
     // Save the output format request for later use in case the encoder making
     // this call would become active, because currently all active encoders use
-    // scale_resolution_down_to instead.
+    // requested_resolution instead.
     stashed_output_format_request_ = request;
     RTC_LOG(LS_INFO) << "Stashing OnOutputFormatRequest: "
                      << stashed_output_format_request_->ToString();
@@ -373,22 +370,21 @@ void VideoAdapter::OnSinkWants(const rtc::VideoSinkWants& sink_wants) {
       source_resolution_alignment_, sink_wants.resolution_alignment);
   // Convert from std::optional<rtc::VideoSinkWants::FrameSize> to
   // std::optional<webrtc::Resolution>. Both are {int,int}.
-  scale_resolution_down_to_ = std::nullopt;
-  if (sink_wants.scale_resolution_down_to.has_value()) {
-    scale_resolution_down_to_ = {
-        .width = sink_wants.scale_resolution_down_to->width,
-        .height = sink_wants.scale_resolution_down_to->height};
+  requested_resolution_ = std::nullopt;
+  if (sink_wants.requested_resolution.has_value()) {
+    requested_resolution_ = {.width = sink_wants.requested_resolution->width,
+                             .height = sink_wants.requested_resolution->height};
   }
 
-  // If scale_resolution_down_to is used, and there are no active encoders
-  // that are NOT using scale_resolution_down_to (aka newapi), then override
-  // calls to OnOutputFormatRequest and use values from scale_resolution_down_to
+  // If requested_resolution is used, and there are no active encoders
+  // that are NOT using requested_resolution (aka newapi), then override
+  // calls to OnOutputFormatRequest and use values from requested_resolution
   // instead (combined with qualityscaling based on pixel counts above).
-  if (!sink_wants.scale_resolution_down_to) {
+  if (!sink_wants.requested_resolution) {
     if (stashed_output_format_request_) {
       // because current active_output_format_request is based on
-      // scale_resolution_down_to logic, while current encoder(s) doesn't want
-      // that, we have to restore the stashed request.
+      // requested_resolution logic, while current encoder(s) doesn't want that,
+      // we have to restore the stashed request.
       RTC_LOG(LS_INFO) << "Unstashing OnOutputFormatRequest: "
                        << stashed_output_format_request_->ToString();
       output_format_request_ = *stashed_output_format_request_;
@@ -397,15 +393,14 @@ void VideoAdapter::OnSinkWants(const rtc::VideoSinkWants& sink_wants) {
     return;
   }
 
-  // The code below is only needed when `scale_resolution_down_to` is signalled
-  // back to the video source which only happens if
-  // `VideoStreamEncoderSettings::use_standard_scale_resolution_down_to` is
-  // false.
+  // The code below is only needed when `requested_resolution` is signalled back
+  // to the video source which only happens if
+  // `VideoStreamEncoderSettings::use_standard_requested_resolution` is false.
   // TODO(https://crbug.com/webrtc/366284861): Delete the code below as part of
   // deleting this flag and only supporting the standard behavior.
 
   if (sink_wants.aggregates.has_value() &&
-      sink_wants.aggregates->any_active_without_scale_resolution_down_to) {
+      sink_wants.aggregates->any_active_without_requested_resolution) {
     return;
   }
 
@@ -418,8 +413,8 @@ void VideoAdapter::OnSinkWants(const rtc::VideoSinkWants& sink_wants) {
                      << stashed_output_format_request_->ToString();
   }
 
-  // Clear the output format request, `scale_resolution_down_to_` will be
-  // applied instead which happens inside AdaptFrameResolution().
+  // Clear the output format request. Requested resolution will be applied
+  // instead which happens inside AdaptFrameResolution().
   output_format_request_ = {};
 }
 
diff --git a/media/base/video_adapter.h b/media/base/video_adapter.h
index 8628cd944a..4cc4a38cfb 100644
--- a/media/base/video_adapter.h
+++ b/media/base/video_adapter.h
@@ -149,14 +149,14 @@ class RTC_EXPORT VideoAdapter {
   int resolution_request_target_pixel_count_ RTC_GUARDED_BY(mutex_);
   int resolution_request_max_pixel_count_ RTC_GUARDED_BY(mutex_);
   int max_framerate_request_ RTC_GUARDED_BY(mutex_);
-  std::optional<webrtc::Resolution> scale_resolution_down_to_
+  std::optional<webrtc::Resolution> requested_resolution_
       RTC_GUARDED_BY(mutex_);
 
   // Stashed OutputFormatRequest that is used to save value of
   // OnOutputFormatRequest in case all active encoders are using
-  // scale_resolution_down_to. I.e when all active encoders are using
-  // scale_resolution_down_to, the call to OnOutputFormatRequest is ignored
-  // and the value from scale_resolution_down_to is used instead (to scale/crop
+  // requested_resolution. I.e when all active encoders are using
+  // requested_resolution, the call to OnOutputFormatRequest is ignored
+  // and the value from requested_resolution is used instead (to scale/crop
   // frame). This allows for an application to only use
   // RtpEncodingParameters::request_resolution and get the same behavior as if
   // it had used VideoAdapter::OnOutputFormatRequest.
diff --git a/media/base/video_adapter_unittest.cc b/media/base/video_adapter_unittest.cc
index ec3658bc68..98dd5b9b27 100644
--- a/media/base/video_adapter_unittest.cc
+++ b/media/base/video_adapter_unittest.cc
@@ -47,24 +47,24 @@ rtc::VideoSinkWants BuildSinkWants(std::optional<int> target_pixel_count,
   wants.resolution_alignment = sink_alignment;
   wants.is_active = true;
   wants.aggregates.emplace(rtc::VideoSinkWants::Aggregates());
-  wants.aggregates->any_active_without_scale_resolution_down_to = false;
+  wants.aggregates->any_active_without_requested_resolution = false;
   return wants;
 }
 
 rtc::VideoSinkWants BuildSinkWants(
-    std::optional<webrtc::Resolution> scale_resolution_down_to,
-    bool any_active_without_scale_resolution_down_to) {
+    std::optional<webrtc::Resolution> requested_resolution,
+    bool any_active_without_requested_resolution) {
   rtc::VideoSinkWants wants;
   wants.max_framerate_fps = kDefaultFps;
   wants.resolution_alignment = 1;
   wants.is_active = true;
-  if (scale_resolution_down_to) {
-    wants.scale_resolution_down_to.emplace(rtc::VideoSinkWants::FrameSize(
-        scale_resolution_down_to->width, scale_resolution_down_to->height));
+  if (requested_resolution) {
+    wants.requested_resolution.emplace(rtc::VideoSinkWants::FrameSize(
+        requested_resolution->width, requested_resolution->height));
   }
   wants.aggregates.emplace(rtc::VideoSinkWants::Aggregates());
-  wants.aggregates->any_active_without_scale_resolution_down_to =
-      any_active_without_scale_resolution_down_to;
+  wants.aggregates->any_active_without_requested_resolution =
+      any_active_without_requested_resolution;
   return wants;
 }
 
@@ -1202,15 +1202,14 @@ TEST_P(VideoAdapterTest, AdaptResolutionWithSinkAlignment) {
 }
 
 // Verify the cases the OnOutputFormatRequest is ignored and
-// scale_resolution_down_to is used instead.
-TEST_P(VideoAdapterTest,
-       UseScaleResolutionDownToInsteadOfOnOutputFormatRequest) {
+// requested_resolution is used instead.
+TEST_P(VideoAdapterTest, UseRequestedResolutionInsteadOfOnOutputFormatRequest) {
   {
     // Both new and old API active => Use OnOutputFormatRequest
     OnOutputFormatRequest(640, 360, kDefaultFps);
-    adapter_.OnSinkWants(BuildSinkWants(
-        Resolution{.width = 960, .height = 540},
-        /* any_active_without_scale_resolution_down_to= */ true));
+    adapter_.OnSinkWants(
+        BuildSinkWants(Resolution{.width = 960, .height = 540},
+                       /* any_active_without_requested_resolution= */ true));
 
     EXPECT_THAT(
         AdaptFrameResolution(/* input frame */ {.width = 1280, .height = 720})
@@ -1219,11 +1218,11 @@ TEST_P(VideoAdapterTest,
   }
   {
     // New API active, old API inactive, ignore OnOutputFormatRequest and use
-    // scale_resolution_down_to.
+    // requested_resolution.
     OnOutputFormatRequest(640, 360, kDefaultFps);
-    adapter_.OnSinkWants(BuildSinkWants(
-        Resolution{.width = 960, .height = 540},
-        /* any_active_without_scale_resolution_down_to= */ false));
+    adapter_.OnSinkWants(
+        BuildSinkWants(Resolution{.width = 960, .height = 540},
+                       /* any_active_without_requested_resolution= */ false));
 
     EXPECT_THAT(
         AdaptFrameResolution(/* input frame */ {.width = 1280, .height = 720})
@@ -1234,9 +1233,9 @@ TEST_P(VideoAdapterTest,
   {
     // New API inactive, old API inactive, use OnOutputFormatRequest.
     OnOutputFormatRequest(640, 360, kDefaultFps);
-    adapter_.OnSinkWants(BuildSinkWants(
-        std::nullopt,
-        /* any_active_without_scale_resolution_down_to= */ false));
+    adapter_.OnSinkWants(
+        BuildSinkWants(std::nullopt,
+                       /* any_active_without_requested_resolution= */ false));
 
     EXPECT_THAT(
         AdaptFrameResolution(/* input frame */ {.width = 1280, .height = 720})
@@ -1247,9 +1246,9 @@ TEST_P(VideoAdapterTest,
   {
     // New API active, old API inactive, remember OnOutputFormatRequest.
     OnOutputFormatRequest(640, 360, kDefaultFps);
-    adapter_.OnSinkWants(BuildSinkWants(
-        Resolution{.width = 960, .height = 540},
-        /* any_active_without_scale_resolution_down_to= */ false));
+    adapter_.OnSinkWants(
+        BuildSinkWants(Resolution{.width = 960, .height = 540},
+                       /* any_active_without_requested_resolution= */ false));
 
     EXPECT_THAT(
         AdaptFrameResolution(/* input frame */ {.width = 1280, .height = 720})
@@ -1257,7 +1256,7 @@ TEST_P(VideoAdapterTest,
         Eq(Resolution{.width = 960, .height = 540}));
 
     // This is ignored since there is not any active NOT using
-    // scale_resolution_down_to.
+    // requested_resolution.
     OnOutputFormatRequest(320, 180, kDefaultFps);
 
     EXPECT_THAT(
@@ -1266,9 +1265,9 @@ TEST_P(VideoAdapterTest,
         Eq(Resolution{.width = 960, .height = 540}));
 
     // Disable new API => fallback to last OnOutputFormatRequest.
-    adapter_.OnSinkWants(BuildSinkWants(
-        std::nullopt,
-        /* any_active_without_scale_resolution_down_to= */ false));
+    adapter_.OnSinkWants(
+        BuildSinkWants(std::nullopt,
+                       /* any_active_without_requested_resolution= */ false));
 
     EXPECT_THAT(
         AdaptFrameResolution(/* input frame */ {.width = 1280, .height = 720})
@@ -1277,12 +1276,12 @@ TEST_P(VideoAdapterTest,
   }
 }
 
-TEST_P(VideoAdapterTest, ScaleResolutionDownToIsOrientationAgnostic) {
+TEST_P(VideoAdapterTest, RequestedResolutionIsOrientationAgnostic) {
   // Request 1280x720 when frame is 720x1280.
   {
-    adapter_.OnSinkWants(BuildSinkWants(
-        Resolution{.width = 1280, .height = 720},
-        /* any_active_without_scale_resolution_down_to= */ false));
+    adapter_.OnSinkWants(
+        BuildSinkWants(Resolution{.width = 1280, .height = 720},
+                       /* any_active_without_requested_resolution= */ false));
 
     EXPECT_THAT(
         AdaptFrameResolution(/* input frame */ {.width = 720, .height = 1280})
@@ -1291,9 +1290,9 @@ TEST_P(VideoAdapterTest, ScaleResolutionDownToIsOrientationAgnostic) {
   }
   // Request 720x1280 when frame is 1280x720.
   {
-    adapter_.OnSinkWants(BuildSinkWants(
-        Resolution{.width = 720, .height = 1280},
-        /* any_active_without_scale_resolution_down_to= */ false));
+    adapter_.OnSinkWants(
+        BuildSinkWants(Resolution{.width = 720, .height = 1280},
+                       /* any_active_without_requested_resolution= */ false));
 
     EXPECT_THAT(
         AdaptFrameResolution(/* input frame */ {.width = 1280, .height = 720})
@@ -1302,11 +1301,11 @@ TEST_P(VideoAdapterTest, ScaleResolutionDownToIsOrientationAgnostic) {
   }
 }
 
-TEST_P(VideoAdapterTest, ScaleResolutionDownToMaintainsAspectRatio) {
+TEST_P(VideoAdapterTest, RequestedResolutionMaintainsAspectRatio) {
   // Request 720x720.
   adapter_.OnSinkWants(
       BuildSinkWants(Resolution{.width = 720, .height = 720},
-                     /* any_active_without_scale_resolution_down_to= */ false));
+                     /* any_active_without_requested_resolution= */ false));
 
   // A 1280x720 frame restricted to 720x720 produces 720x405.
   EXPECT_TRUE(adapter_.AdaptFrameResolution(1280, 720, /*in_timestamp_ns=*/0,
@@ -1367,11 +1366,11 @@ TEST_P(VideoAdapterWithSourceAlignmentTest, AdaptResolutionWithSinkAlignment) {
 }
 
 TEST_P(VideoAdapterWithSourceAlignmentTest,
-       ScaleResolutionDownToMaintainsAspectRatioWithAlignment) {
+       RequestedResolutionMaintainsAspectRatioWithAlignment) {
   // Request 720x720.
   adapter_.OnSinkWants(
       BuildSinkWants(Resolution{.width = 720, .height = 720},
-                     /* any_active_without_scale_resolution_down_to= */ false));
+                     /* any_active_without_requested_resolution= */ false));
 
   // A 1280x720 frame restricted to 720x720 produces 720x405 but this is not a
   // multiple of `kSourceResolutionAlignment` (= 7), the rounded up multiple of
diff --git a/media/base/video_broadcaster.cc b/media/base/video_broadcaster.cc
index 712957bd25..b34b8dbb6b 100644
--- a/media/base/video_broadcaster.cc
+++ b/media/base/video_broadcaster.cc
@@ -131,21 +131,20 @@ void VideoBroadcaster::UpdateWants() {
   // "ignore" encoders that are not active. But that would
   // probably require a controlled roll out with a field trials?
   // To play it safe, only ignore inactive encoders is there is an
-  // active encoder using the new api (scale_resolution_down_to),
+  // active encoder using the new api (requested_resolution),
   // this means that there is only a behavioural change when using new
   // api.
   bool ignore_inactive_encoders_old_api = false;
   for (auto& sink : sink_pairs()) {
-    if (sink.wants.is_active &&
-        sink.wants.scale_resolution_down_to.has_value()) {
+    if (sink.wants.is_active && sink.wants.requested_resolution.has_value()) {
       ignore_inactive_encoders_old_api = true;
       break;
     }
   }
 
   for (auto& sink : sink_pairs()) {
-    if (!sink.wants.is_active && (sink.wants.scale_resolution_down_to ||
-                                  ignore_inactive_encoders_old_api)) {
+    if (!sink.wants.is_active &&
+        (sink.wants.requested_resolution || ignore_inactive_encoders_old_api)) {
       continue;
     }
     // wants.rotation_applied == ANY(sink.wants.rotation_applied)
@@ -172,21 +171,21 @@ void VideoBroadcaster::UpdateWants() {
     wants.resolution_alignment = cricket::LeastCommonMultiple(
         wants.resolution_alignment, sink.wants.resolution_alignment);
 
-    // Pick MAX(scale_resolution_down_to) since the actual can be downscaled
+    // Pick MAX(requested_resolution) since the actual can be downscaled
     // in encoder instead.
-    if (sink.wants.scale_resolution_down_to) {
-      if (!wants.scale_resolution_down_to) {
-        wants.scale_resolution_down_to = sink.wants.scale_resolution_down_to;
+    if (sink.wants.requested_resolution) {
+      if (!wants.requested_resolution) {
+        wants.requested_resolution = sink.wants.requested_resolution;
       } else {
-        wants.scale_resolution_down_to->width =
-            std::max(wants.scale_resolution_down_to->width,
-                     sink.wants.scale_resolution_down_to->width);
-        wants.scale_resolution_down_to->height =
-            std::max(wants.scale_resolution_down_to->height,
-                     sink.wants.scale_resolution_down_to->height);
+        wants.requested_resolution->width =
+            std::max(wants.requested_resolution->width,
+                     sink.wants.requested_resolution->width);
+        wants.requested_resolution->height =
+            std::max(wants.requested_resolution->height,
+                     sink.wants.requested_resolution->height);
       }
     } else if (sink.wants.is_active) {
-      wants.aggregates->any_active_without_scale_resolution_down_to = true;
+      wants.aggregates->any_active_without_requested_resolution = true;
     }
 
     wants.is_active |= sink.wants.is_active;
diff --git a/media/base/video_broadcaster_unittest.cc b/media/base/video_broadcaster_unittest.cc
index b4e605ff7f..7ab122d64b 100644
--- a/media/base/video_broadcaster_unittest.cc
+++ b/media/base/video_broadcaster_unittest.cc
@@ -332,26 +332,26 @@ TEST(VideoBroadcasterTest, ForwardsConstraintsToSink) {
   broadcaster.ProcessConstraints(webrtc::VideoTrackSourceConstraints{2, 3});
 }
 
-TEST(VideoBroadcasterTest, AppliesMaxOfSinkWantsScaleResolutionDownTo) {
+TEST(VideoBroadcasterTest, AppliesMaxOfSinkWantsRequestedResolution) {
   VideoBroadcaster broadcaster;
 
   FakeVideoRenderer sink1;
   VideoSinkWants wants1;
   wants1.is_active = true;
-  wants1.scale_resolution_down_to = FrameSize(640, 360);
+  wants1.requested_resolution = FrameSize(640, 360);
 
   broadcaster.AddOrUpdateSink(&sink1, wants1);
-  EXPECT_EQ(FrameSize(640, 360), *broadcaster.wants().scale_resolution_down_to);
+  EXPECT_EQ(FrameSize(640, 360), *broadcaster.wants().requested_resolution);
 
   FakeVideoRenderer sink2;
   VideoSinkWants wants2;
   wants2.is_active = true;
-  wants2.scale_resolution_down_to = FrameSize(650, 350);
+  wants2.requested_resolution = FrameSize(650, 350);
   broadcaster.AddOrUpdateSink(&sink2, wants2);
-  EXPECT_EQ(FrameSize(650, 360), *broadcaster.wants().scale_resolution_down_to);
+  EXPECT_EQ(FrameSize(650, 360), *broadcaster.wants().requested_resolution);
 
   broadcaster.RemoveSink(&sink2);
-  EXPECT_EQ(FrameSize(640, 360), *broadcaster.wants().scale_resolution_down_to);
+  EXPECT_EQ(FrameSize(640, 360), *broadcaster.wants().requested_resolution);
 }
 
 TEST(VideoBroadcasterTest, AnyActive) {
@@ -374,42 +374,43 @@ TEST(VideoBroadcasterTest, AnyActive) {
   EXPECT_EQ(false, broadcaster.wants().is_active);
 }
 
-TEST(VideoBroadcasterTest, AnyActiveWithoutScaleResolutionDownTo) {
+TEST(VideoBroadcasterTest, AnyActiveWithoutRequestedResolution) {
   VideoBroadcaster broadcaster;
 
   FakeVideoRenderer sink1;
   VideoSinkWants wants1;
   wants1.is_active = true;
-  wants1.scale_resolution_down_to = FrameSize(640, 360);
+  wants1.requested_resolution = FrameSize(640, 360);
 
   broadcaster.AddOrUpdateSink(&sink1, wants1);
-  EXPECT_EQ(false,
-            broadcaster.wants()
-                .aggregates->any_active_without_scale_resolution_down_to);
+  EXPECT_EQ(
+      false,
+      broadcaster.wants().aggregates->any_active_without_requested_resolution);
 
   FakeVideoRenderer sink2;
   VideoSinkWants wants2;
   wants2.is_active = true;
   broadcaster.AddOrUpdateSink(&sink2, wants2);
-  EXPECT_EQ(true, broadcaster.wants()
-                      .aggregates->any_active_without_scale_resolution_down_to);
+  EXPECT_EQ(
+      true,
+      broadcaster.wants().aggregates->any_active_without_requested_resolution);
 
   broadcaster.RemoveSink(&sink2);
-  EXPECT_EQ(false,
-            broadcaster.wants()
-                .aggregates->any_active_without_scale_resolution_down_to);
+  EXPECT_EQ(
+      false,
+      broadcaster.wants().aggregates->any_active_without_requested_resolution);
 }
 
 // This verifies that the VideoSinkWants from a Sink that is_active = false
-// is ignored IF there is an active sink using new api
-// (scale_resolution_down_to). The uses resolution_alignment for verification.
+// is ignored IF there is an active sink using new api (Requested_Resolution).
+// The uses resolution_alignment for verification.
 TEST(VideoBroadcasterTest, IgnoreInactiveSinkIfNewApiUsed) {
   VideoBroadcaster broadcaster;
 
   FakeVideoRenderer sink1;
   VideoSinkWants wants1;
   wants1.is_active = true;
-  wants1.scale_resolution_down_to = FrameSize(640, 360);
+  wants1.requested_resolution = FrameSize(640, 360);
   wants1.resolution_alignment = 2;
   broadcaster.AddOrUpdateSink(&sink1, wants1);
   EXPECT_EQ(broadcaster.wants().resolution_alignment, 2);
diff --git a/media/engine/webrtc_video_engine.cc b/media/engine/webrtc_video_engine.cc
index 996f0d7329..27512b90ea 100644
--- a/media/engine/webrtc_video_engine.cc
+++ b/media/engine/webrtc_video_engine.cc
@@ -2087,8 +2087,8 @@ WebRtcVideoSendChannel::WebRtcVideoSendStream::SetRtpParameters(
          rtp_parameters_.encodings[i].scale_resolution_down_by) ||
         (new_parameters.encodings[i].num_temporal_layers !=
          rtp_parameters_.encodings[i].num_temporal_layers) ||
-        (new_parameters.encodings[i].scale_resolution_down_to !=
-         rtp_parameters_.encodings[i].scale_resolution_down_to) ||
+        (new_parameters.encodings[i].requested_resolution !=
+         rtp_parameters_.encodings[i].requested_resolution) ||
         (new_parameters.encodings[i].scalability_mode !=
          rtp_parameters_.encodings[i].scalability_mode) ||
         (new_parameters.encodings[i].codec !=
@@ -2228,7 +2228,7 @@ WebRtcVideoSendChannel::WebRtcVideoSendStream::CreateVideoEncoderConfig(
        rtp_parameters_.encodings) {
     if (encoding.scalability_mode.has_value() &&
         (encoding.scale_resolution_down_by.has_value() ||
-         encoding.scale_resolution_down_to.has_value())) {
+         encoding.requested_resolution.has_value())) {
       legacy_scalability_mode = false;
       break;
     }
@@ -2309,8 +2309,8 @@ WebRtcVideoSendChannel::WebRtcVideoSendStream::CreateVideoEncoderConfig(
       encoder_config.simulcast_layers[i].num_temporal_layers =
           *rtp_parameters_.encodings[i].num_temporal_layers;
     }
-    encoder_config.simulcast_layers[i].scale_resolution_down_to =
-        rtp_parameters_.encodings[i].scale_resolution_down_to;
+    encoder_config.simulcast_layers[i].requested_resolution =
+        rtp_parameters_.encodings[i].requested_resolution;
   }
 
   encoder_config.legacy_conference_mode = parameters_.conference_mode;
diff --git a/media/engine/webrtc_video_engine_unittest.cc b/media/engine/webrtc_video_engine_unittest.cc
index e2153e8026..ea9f7034ea 100644
--- a/media/engine/webrtc_video_engine_unittest.cc
+++ b/media/engine/webrtc_video_engine_unittest.cc
@@ -9750,7 +9750,7 @@ TEST_F(WebRtcVideoChannelBaseTest, EncoderSelectorSwitchCodec) {
   send_channel_->SetEncoderSelector(kSsrc, nullptr);
 }
 
-TEST_F(WebRtcVideoChannelTest, ScaleResolutionDownToSinglecast) {
+TEST_F(WebRtcVideoChannelTest, RequestedResolutionSinglecast) {
   cricket::VideoSenderParameters parameters;
   parameters.codecs.push_back(GetEngineCodec("VP8"));
   ASSERT_TRUE(send_channel_->SetSenderParameters(parameters));
@@ -9762,12 +9762,12 @@ TEST_F(WebRtcVideoChannelTest, ScaleResolutionDownToSinglecast) {
   EXPECT_TRUE(
       send_channel_->SetVideoSend(last_ssrc_, nullptr, &frame_forwarder));
 
-  {  // TEST scale_resolution_down_to < frame size
+  {  // TEST requested_resolution < frame size
     webrtc::RtpParameters rtp_parameters =
         send_channel_->GetRtpSendParameters(last_ssrc_);
     EXPECT_EQ(1UL, rtp_parameters.encodings.size());
-    rtp_parameters.encodings[0].scale_resolution_down_to = {.width = 640,
-                                                            .height = 360};
+    rtp_parameters.encodings[0].requested_resolution = {.width = 640,
+                                                        .height = 360};
     send_channel_->SetRtpSendParameters(last_ssrc_, rtp_parameters);
 
     frame_forwarder.IncomingCapturedFrame(frame_source.GetFrame());
@@ -9778,11 +9778,11 @@ TEST_F(WebRtcVideoChannelTest, ScaleResolutionDownToSinglecast) {
     EXPECT_EQ(rtc::checked_cast<size_t>(360), streams[0].height);
   }
 
-  {  // TEST scale_resolution_down_to == frame size
+  {  // TEST requested_resolution == frame size
     auto rtp_parameters = send_channel_->GetRtpSendParameters(last_ssrc_);
     EXPECT_EQ(1UL, rtp_parameters.encodings.size());
-    rtp_parameters.encodings[0].scale_resolution_down_to = {.width = 1280,
-                                                            .height = 720};
+    rtp_parameters.encodings[0].requested_resolution = {.width = 1280,
+                                                        .height = 720};
     send_channel_->SetRtpSendParameters(last_ssrc_, rtp_parameters);
 
     frame_forwarder.IncomingCapturedFrame(frame_source.GetFrame());
@@ -9792,11 +9792,11 @@ TEST_F(WebRtcVideoChannelTest, ScaleResolutionDownToSinglecast) {
     EXPECT_EQ(rtc::checked_cast<size_t>(720), streams[0].height);
   }
 
-  {  // TEST scale_resolution_down_to > frame size
+  {  // TEST requested_resolution > frame size
     auto rtp_parameters = send_channel_->GetRtpSendParameters(last_ssrc_);
     EXPECT_EQ(1UL, rtp_parameters.encodings.size());
-    rtp_parameters.encodings[0].scale_resolution_down_to = {.width = 2 * 1280,
-                                                            .height = 2 * 720};
+    rtp_parameters.encodings[0].requested_resolution = {.width = 2 * 1280,
+                                                        .height = 2 * 720};
     send_channel_->SetRtpSendParameters(last_ssrc_, rtp_parameters);
 
     frame_forwarder.IncomingCapturedFrame(frame_source.GetFrame());
@@ -9809,7 +9809,7 @@ TEST_F(WebRtcVideoChannelTest, ScaleResolutionDownToSinglecast) {
   EXPECT_TRUE(send_channel_->SetVideoSend(last_ssrc_, nullptr, nullptr));
 }
 
-TEST_F(WebRtcVideoChannelTest, ScaleResolutionDownToSinglecastScaling) {
+TEST_F(WebRtcVideoChannelTest, RequestedResolutionSinglecastScaling) {
   cricket::VideoSenderParameters parameters;
   parameters.codecs.push_back(GetEngineCodec("VP8"));
   ASSERT_TRUE(send_channel_->SetSenderParameters(parameters));
@@ -9824,8 +9824,8 @@ TEST_F(WebRtcVideoChannelTest, ScaleResolutionDownToSinglecastScaling) {
   {
     auto rtp_parameters = send_channel_->GetRtpSendParameters(last_ssrc_);
     EXPECT_EQ(1UL, rtp_parameters.encodings.size());
-    rtp_parameters.encodings[0].scale_resolution_down_to = {.width = 720,
-                                                            .height = 720};
+    rtp_parameters.encodings[0].requested_resolution = {.width = 720,
+                                                        .height = 720};
     send_channel_->SetRtpSendParameters(last_ssrc_, rtp_parameters);
 
     frame_forwarder.IncomingCapturedFrame(frame_source.GetFrame());
@@ -9841,8 +9841,8 @@ TEST_F(WebRtcVideoChannelTest, ScaleResolutionDownToSinglecastScaling) {
   {
     auto rtp_parameters = send_channel_->GetRtpSendParameters(last_ssrc_);
     EXPECT_EQ(1UL, rtp_parameters.encodings.size());
-    rtp_parameters.encodings[0].scale_resolution_down_to = {.width = 1280,
-                                                            .height = 1280};
+    rtp_parameters.encodings[0].requested_resolution = {.width = 1280,
+                                                        .height = 1280};
     send_channel_->SetRtpSendParameters(last_ssrc_, rtp_parameters);
 
     frame_forwarder.IncomingCapturedFrame(frame_source.GetFrame());
@@ -9857,8 +9857,8 @@ TEST_F(WebRtcVideoChannelTest, ScaleResolutionDownToSinglecastScaling) {
   {
     auto rtp_parameters = send_channel_->GetRtpSendParameters(last_ssrc_);
     EXPECT_EQ(1UL, rtp_parameters.encodings.size());
-    rtp_parameters.encodings[0].scale_resolution_down_to = {.width = 650,
-                                                            .height = 650};
+    rtp_parameters.encodings[0].requested_resolution = {.width = 650,
+                                                        .height = 650};
     send_channel_->SetRtpSendParameters(last_ssrc_, rtp_parameters);
 
     auto streams = stream->GetVideoStreams();
@@ -9872,8 +9872,8 @@ TEST_F(WebRtcVideoChannelTest, ScaleResolutionDownToSinglecastScaling) {
   {
     auto rtp_parameters = send_channel_->GetRtpSendParameters(last_ssrc_);
     EXPECT_EQ(1UL, rtp_parameters.encodings.size());
-    rtp_parameters.encodings[0].scale_resolution_down_to = {.width = 2560,
-                                                            .height = 1440};
+    rtp_parameters.encodings[0].requested_resolution = {.width = 2560,
+                                                        .height = 1440};
     send_channel_->SetRtpSendParameters(last_ssrc_, rtp_parameters);
 
     auto streams = stream->GetVideoStreams();
@@ -9886,7 +9886,7 @@ TEST_F(WebRtcVideoChannelTest, ScaleResolutionDownToSinglecastScaling) {
   EXPECT_TRUE(send_channel_->SetVideoSend(last_ssrc_, nullptr, nullptr));
 }
 
-TEST_F(WebRtcVideoChannelTest, ScaleResolutionDownToSimulcast) {
+TEST_F(WebRtcVideoChannelTest, RequestedResolutionSimulcast) {
   cricket::VideoSenderParameters parameters;
   parameters.codecs.push_back(GetEngineCodec("VP8"));
   ASSERT_TRUE(send_channel_->SetSenderParameters(parameters));
@@ -9902,12 +9902,12 @@ TEST_F(WebRtcVideoChannelTest, ScaleResolutionDownToSimulcast) {
     webrtc::RtpParameters rtp_parameters =
         send_channel_->GetRtpSendParameters(last_ssrc_);
     EXPECT_EQ(3UL, rtp_parameters.encodings.size());
-    rtp_parameters.encodings[0].scale_resolution_down_to = {.width = 320,
-                                                            .height = 180};
-    rtp_parameters.encodings[1].scale_resolution_down_to = {.width = 640,
-                                                            .height = 360};
-    rtp_parameters.encodings[2].scale_resolution_down_to = {.width = 1280,
-                                                            .height = 720};
+    rtp_parameters.encodings[0].requested_resolution = {.width = 320,
+                                                        .height = 180};
+    rtp_parameters.encodings[1].requested_resolution = {.width = 640,
+                                                        .height = 360};
+    rtp_parameters.encodings[2].requested_resolution = {.width = 1280,
+                                                        .height = 720};
     send_channel_->SetRtpSendParameters(last_ssrc_, rtp_parameters);
 
     frame_forwarder.IncomingCapturedFrame(frame_source.GetFrame());
@@ -9924,12 +9924,12 @@ TEST_F(WebRtcVideoChannelTest, ScaleResolutionDownToSimulcast) {
     webrtc::RtpParameters rtp_parameters =
         send_channel_->GetRtpSendParameters(last_ssrc_);
     EXPECT_EQ(3UL, rtp_parameters.encodings.size());
-    rtp_parameters.encodings[0].scale_resolution_down_to = {.width = 320,
-                                                            .height = 180};
+    rtp_parameters.encodings[0].requested_resolution = {.width = 320,
+                                                        .height = 180};
     rtp_parameters.encodings[1].active = false;
 
-    rtp_parameters.encodings[2].scale_resolution_down_to = {.width = 1280,
-                                                            .height = 720};
+    rtp_parameters.encodings[2].requested_resolution = {.width = 1280,
+                                                        .height = 720};
     send_channel_->SetRtpSendParameters(last_ssrc_, rtp_parameters);
 
     frame_forwarder.IncomingCapturedFrame(frame_source.GetFrame());
@@ -9945,13 +9945,13 @@ TEST_F(WebRtcVideoChannelTest, ScaleResolutionDownToSimulcast) {
     webrtc::RtpParameters rtp_parameters =
         send_channel_->GetRtpSendParameters(last_ssrc_);
     EXPECT_EQ(3UL, rtp_parameters.encodings.size());
-    rtp_parameters.encodings[0].scale_resolution_down_to = {.width = 320,
-                                                            .height = 180};
+    rtp_parameters.encodings[0].requested_resolution = {.width = 320,
+                                                        .height = 180};
     rtp_parameters.encodings[1].active = true;
-    rtp_parameters.encodings[1].scale_resolution_down_to = {.width = 640,
-                                                            .height = 360};
-    rtp_parameters.encodings[2].scale_resolution_down_to = {.width = 960,
-                                                            .height = 540};
+    rtp_parameters.encodings[1].requested_resolution = {.width = 640,
+                                                        .height = 360};
+    rtp_parameters.encodings[2].requested_resolution = {.width = 960,
+                                                        .height = 540};
     send_channel_->SetRtpSendParameters(last_ssrc_, rtp_parameters);
 
     frame_forwarder.IncomingCapturedFrame(frame_source.GetFrame());
diff --git a/pc/peer_connection_encodings_integrationtest.cc b/pc/peer_connection_encodings_integrationtest.cc
index fd86173cd3..079dbbec73 100644
--- a/pc/peer_connection_encodings_integrationtest.cc
+++ b/pc/peer_connection_encodings_integrationtest.cc
@@ -2115,16 +2115,17 @@ TEST_F(PeerConnectionEncodingsIntegrationTest,
   ASSERT_TRUE(transceiver_or_error.ok());
 }
 
-TEST_F(PeerConnectionEncodingsIntegrationTest, ScaleToParameterChecking) {
+TEST_F(PeerConnectionEncodingsIntegrationTest,
+       RequestedResolutionParameterChecking) {
   rtc::scoped_refptr<PeerConnectionTestWrapper> pc_wrapper = CreatePc();
 
-  // AddTransceiver: If `scale_resolution_down_to` is specified on any encoding
-  // it must be specified on all encodings.
+  // AddTransceiver: If `requested_resolution` is specified on any encoding it
+  // must be specified on all encodings.
   RtpTransceiverInit init;
   RtpEncodingParameters encoding;
-  encoding.scale_resolution_down_to = std::nullopt;
+  encoding.requested_resolution = std::nullopt;
   init.send_encodings.push_back(encoding);
-  encoding.scale_resolution_down_to = {.width = 1280, .height = 720};
+  encoding.requested_resolution = {.width = 1280, .height = 720};
   init.send_encodings.push_back(encoding);
   auto transceiver_or_error =
       pc_wrapper->pc()->AddTransceiver(cricket::MEDIA_TYPE_VIDEO, init);
@@ -2133,74 +2134,64 @@ TEST_F(PeerConnectionEncodingsIntegrationTest, ScaleToParameterChecking) {
             RTCErrorType::UNSUPPORTED_OPERATION);
 
   // AddTransceiver: Width and height must not be zero.
-  init.send_encodings[0].scale_resolution_down_to = {.width = 1280,
-                                                     .height = 0};
-  init.send_encodings[1].scale_resolution_down_to = {.width = 0, .height = 720};
+  init.send_encodings[0].requested_resolution = {.width = 1280, .height = 0};
+  init.send_encodings[1].requested_resolution = {.width = 0, .height = 720};
   transceiver_or_error =
       pc_wrapper->pc()->AddTransceiver(cricket::MEDIA_TYPE_VIDEO, init);
   EXPECT_FALSE(transceiver_or_error.ok());
   EXPECT_EQ(transceiver_or_error.error().type(),
             RTCErrorType::UNSUPPORTED_OPERATION);
 
-  // AddTransceiver: Specifying both `scale_resolution_down_to` and
+  // AddTransceiver: Specifying both `requested_resolution` and
   // `scale_resolution_down_by` is allowed (the latter is ignored).
-  init.send_encodings[0].scale_resolution_down_to = {.width = 640,
-                                                     .height = 480};
+  init.send_encodings[0].requested_resolution = {.width = 640, .height = 480};
   init.send_encodings[0].scale_resolution_down_by = 1.0;
-  init.send_encodings[1].scale_resolution_down_to = {.width = 1280,
-                                                     .height = 720};
+  init.send_encodings[1].requested_resolution = {.width = 1280, .height = 720};
   init.send_encodings[1].scale_resolution_down_by = 2.0;
   transceiver_or_error =
       pc_wrapper->pc()->AddTransceiver(cricket::MEDIA_TYPE_VIDEO, init);
   ASSERT_TRUE(transceiver_or_error.ok());
 
-  // SetParameters: If `scale_resolution_down_to` is specified on any active
+  // SetParameters: If `requested_resolution` is specified on any active
   // encoding it must be specified on all active encodings.
   auto sender = transceiver_or_error.value()->sender();
   auto parameters = sender->GetParameters();
-  parameters.encodings[0].scale_resolution_down_to = {.width = 640,
-                                                      .height = 480};
-  parameters.encodings[1].scale_resolution_down_to = std::nullopt;
+  parameters.encodings[0].requested_resolution = {.width = 640, .height = 480};
+  parameters.encodings[1].requested_resolution = std::nullopt;
   auto error = sender->SetParameters(parameters);
   EXPECT_FALSE(error.ok());
   EXPECT_EQ(error.type(), RTCErrorType::INVALID_MODIFICATION);
-  // But it's OK not to specify `scale_resolution_down_to` on an inactive
-  // encoding.
+  // But it's OK not to specify `requested_resolution` on an inactive encoding.
   parameters = sender->GetParameters();
-  parameters.encodings[0].scale_resolution_down_to = {.width = 640,
-                                                      .height = 480};
+  parameters.encodings[0].requested_resolution = {.width = 640, .height = 480};
   parameters.encodings[1].active = false;
-  parameters.encodings[1].scale_resolution_down_to = std::nullopt;
+  parameters.encodings[1].requested_resolution = std::nullopt;
   error = sender->SetParameters(parameters);
   EXPECT_TRUE(error.ok());
 
   // SetParameters: Width and height must not be zero.
   sender = transceiver_or_error.value()->sender();
   parameters = sender->GetParameters();
-  parameters.encodings[0].scale_resolution_down_to = {.width = 1280,
-                                                      .height = 0};
+  parameters.encodings[0].requested_resolution = {.width = 1280, .height = 0};
   parameters.encodings[1].active = true;
-  parameters.encodings[1].scale_resolution_down_to = {.width = 0,
-                                                      .height = 720};
+  parameters.encodings[1].requested_resolution = {.width = 0, .height = 720};
   error = sender->SetParameters(parameters);
   EXPECT_FALSE(error.ok());
   EXPECT_EQ(error.type(), RTCErrorType::INVALID_MODIFICATION);
 
-  // SetParameters: Specifying both `scale_resolution_down_to` and
+  // SetParameters: Specifying both `requested_resolution` and
   // `scale_resolution_down_by` is allowed (the latter is ignored).
   parameters = sender->GetParameters();
-  parameters.encodings[0].scale_resolution_down_to = {.width = 640,
-                                                      .height = 480};
+  parameters.encodings[0].requested_resolution = {.width = 640, .height = 480};
   parameters.encodings[0].scale_resolution_down_by = 2.0;
-  parameters.encodings[1].scale_resolution_down_to = {.width = 1280,
-                                                      .height = 720};
+  parameters.encodings[1].requested_resolution = {.width = 1280, .height = 720};
   parameters.encodings[1].scale_resolution_down_by = 1.0;
   error = sender->SetParameters(parameters);
   EXPECT_TRUE(error.ok());
 }
 
 TEST_F(PeerConnectionEncodingsIntegrationTest,
-       ScaleResolutionDownByIsIgnoredWhenScaleToIsSpecified) {
+       ScaleResolutionDownByIsIgnoredWhenRequestedResolutionIsSpecified) {
   rtc::scoped_refptr<PeerConnectionTestWrapper> local_pc_wrapper = CreatePc();
   rtc::scoped_refptr<PeerConnectionTestWrapper> remote_pc_wrapper = CreatePc();
 
@@ -2213,7 +2204,7 @@ TEST_F(PeerConnectionEncodingsIntegrationTest,
   RtpTransceiverInit init;
   RtpEncodingParameters encoding;
   encoding.scale_resolution_down_by = 2.0;
-  encoding.scale_resolution_down_to = {.width = 640, .height = 360};
+  encoding.requested_resolution = {.width = 640, .height = 360};
   init.send_encodings.push_back(encoding);
   auto transceiver_or_error =
       local_pc_wrapper->pc()->AddTransceiver(track, init);
@@ -2231,7 +2222,7 @@ TEST_F(PeerConnectionEncodingsIntegrationTest,
 }
 
 // Tests that use the standard path (specifying both `scalability_mode` and
-// `scale_resolution_down_by` or `scale_resolution_down_to`) should pass for all
+// `scale_resolution_down_by` or `requested_resolution`) should pass for all
 // codecs.
 class PeerConnectionEncodingsIntegrationParameterizedTest
     : public PeerConnectionEncodingsIntegrationTest,
@@ -2367,9 +2358,9 @@ TEST_P(PeerConnectionEncodingsIntegrationParameterizedTest, Simulcast) {
   EXPECT_THAT(*outbound_rtps[2]->scalability_mode, StrEq("L1T3"));
 }
 
-// Configure 4:2:1 using `scale_resolution_down_to`.
+// Configure 4:2:1 using `requested_resolution`.
 TEST_P(PeerConnectionEncodingsIntegrationParameterizedTest,
-       SimulcastWithScaleTo) {
+       SimulcastWithRequestedResolution) {
   rtc::scoped_refptr<PeerConnectionTestWrapper> local_pc_wrapper = CreatePc();
   if (SkipTestDueToAv1Missing(local_pc_wrapper)) {
     return;
@@ -2390,14 +2381,11 @@ TEST_P(PeerConnectionEncodingsIntegrationParameterizedTest,
   RtpParameters parameters = sender->GetParameters();
   ASSERT_THAT(parameters.encodings, SizeIs(3));
   parameters.encodings[0].scalability_mode = "L1T3";
-  parameters.encodings[0].scale_resolution_down_to = {.width = 320,
-                                                      .height = 180};
+  parameters.encodings[0].requested_resolution = {.width = 320, .height = 180};
   parameters.encodings[1].scalability_mode = "L1T3";
-  parameters.encodings[1].scale_resolution_down_to = {.width = 640,
-                                                      .height = 360};
+  parameters.encodings[1].requested_resolution = {.width = 640, .height = 360};
   parameters.encodings[2].scalability_mode = "L1T3";
-  parameters.encodings[2].scale_resolution_down_to = {.width = 1280,
-                                                      .height = 720};
+  parameters.encodings[2].requested_resolution = {.width = 1280, .height = 720};
   sender->SetParameters(parameters);
 
   NegotiateWithSimulcastTweaks(local_pc_wrapper, remote_pc_wrapper);
@@ -2513,9 +2501,9 @@ TEST_P(PeerConnectionEncodingsIntegrationParameterizedTest,
 }
 
 // Simulcast starting in 720p 4:2:1 then changing to {180p, 360p, 540p} using
-// the `scale_resolution_down_to` API.
+// the `requested_resolution` API.
 TEST_P(PeerConnectionEncodingsIntegrationParameterizedTest,
-       SimulcastScaleToNoLongerPowerOfTwo) {
+       SimulcastRequestedResolutionNoLongerPowerOfTwo) {
   rtc::scoped_refptr<PeerConnectionTestWrapper> local_pc_wrapper = CreatePc();
   if (SkipTestDueToAv1Missing(local_pc_wrapper)) {
     return;
@@ -2537,14 +2525,11 @@ TEST_P(PeerConnectionEncodingsIntegrationParameterizedTest,
   RtpParameters parameters = sender->GetParameters();
   ASSERT_THAT(parameters.encodings, SizeIs(3));
   parameters.encodings[0].scalability_mode = "L1T1";
-  parameters.encodings[0].scale_resolution_down_to = {.width = 320,
-                                                      .height = 180};
+  parameters.encodings[0].requested_resolution = {.width = 320, .height = 180};
   parameters.encodings[1].scalability_mode = "L1T1";
-  parameters.encodings[1].scale_resolution_down_to = {.width = 640,
-                                                      .height = 360};
+  parameters.encodings[1].requested_resolution = {.width = 640, .height = 360};
   parameters.encodings[2].scalability_mode = "L1T1";
-  parameters.encodings[2].scale_resolution_down_to = {.width = 1280,
-                                                      .height = 720};
+  parameters.encodings[2].requested_resolution = {.width = 1280, .height = 720};
   sender->SetParameters(parameters);
 
   NegotiateWithSimulcastTweaks(local_pc_wrapper, remote_pc_wrapper);
@@ -2563,12 +2548,9 @@ TEST_P(PeerConnectionEncodingsIntegrationParameterizedTest,
 
   // Configure {180p, 360p, 540p}.
   parameters = sender->GetParameters();
-  parameters.encodings[0].scale_resolution_down_to = {.width = 320,
-                                                      .height = 180};
-  parameters.encodings[1].scale_resolution_down_to = {.width = 640,
-                                                      .height = 360};
-  parameters.encodings[2].scale_resolution_down_to = {.width = 960,
-                                                      .height = 540};
+  parameters.encodings[0].requested_resolution = {.width = 320, .height = 180};
+  parameters.encodings[1].requested_resolution = {.width = 640, .height = 360};
+  parameters.encodings[2].requested_resolution = {.width = 960, .height = 540};
   sender->SetParameters(parameters);
 
   // Wait for the new resolutions to be produced.
@@ -2595,11 +2577,11 @@ TEST_P(PeerConnectionEncodingsIntegrationParameterizedTest,
 }
 
 // The code path that disables layers based on resolution size should NOT run
-// when `scale_resolution_down_to` is specified. (It shouldn't run in any case
-// but that is an existing legacy code and non-compliance problem that we don't
-// have to repeat here.)
+// when `requested_resolution` is specified. (It shouldn't run in any case but
+// that is an existing legacy code and non-compliance problem that we don't have
+// to repeat here.)
 TEST_P(PeerConnectionEncodingsIntegrationParameterizedTest,
-       LowResolutionSimulcastWithScaleTo) {
+       LowResolutionSimulcastWithRequestedResolution) {
   rtc::scoped_refptr<PeerConnectionTestWrapper> local_pc_wrapper = CreatePc();
   if (SkipTestDueToAv1Missing(local_pc_wrapper)) {
     return;
@@ -2615,13 +2597,13 @@ TEST_P(PeerConnectionEncodingsIntegrationParameterizedTest,
   RtpEncodingParameters encoding;
   encoding.scalability_mode = "L1T3";
   encoding.rid = "q";
-  encoding.scale_resolution_down_to = {.width = 40, .height = 20};
+  encoding.requested_resolution = {.width = 40, .height = 20};
   init.send_encodings.push_back(encoding);
   encoding.rid = "h";
-  encoding.scale_resolution_down_to = {.width = 80, .height = 40};
+  encoding.requested_resolution = {.width = 80, .height = 40};
   init.send_encodings.push_back(encoding);
   encoding.rid = "f";
-  encoding.scale_resolution_down_to = {.width = 160, .height = 80};
+  encoding.requested_resolution = {.width = 160, .height = 80};
   init.send_encodings.push_back(encoding);
   rtc::scoped_refptr<MediaStreamInterface> stream =
       local_pc_wrapper->GetUserMedia(
@@ -2716,7 +2698,7 @@ TEST_P(PeerConnectionEncodingsIntegrationParameterizedTest,
 }
 
 TEST_P(PeerConnectionEncodingsIntegrationParameterizedTest,
-       ScaleToDownscaleAndThenUpscale) {
+       RequestedResolutionDownscaleAndThenUpscale) {
   rtc::scoped_refptr<PeerConnectionTestWrapper> local_pc_wrapper = CreatePc();
   if (SkipTestDueToAv1Missing(local_pc_wrapper)) {
     return;
@@ -2744,8 +2726,7 @@ TEST_P(PeerConnectionEncodingsIntegrationParameterizedTest,
   RtpParameters parameters = sender->GetParameters();
   ASSERT_THAT(parameters.encodings, SizeIs(1));
   parameters.encodings[0].scalability_mode = "L1T3";
-  parameters.encodings[0].scale_resolution_down_to = {.width = 640,
-                                                      .height = 360};
+  parameters.encodings[0].requested_resolution = {.width = 640, .height = 360};
   sender->SetParameters(parameters);
   // Confirm 640x360 is sent.
   ASSERT_TRUE_WAIT(GetEncodingResolution(local_pc_wrapper) ==
@@ -2763,8 +2744,7 @@ TEST_P(PeerConnectionEncodingsIntegrationParameterizedTest,
 
   // Request the full 1280x720 resolution.
   parameters = sender->GetParameters();
-  parameters.encodings[0].scale_resolution_down_to = {.width = 1280,
-                                                      .height = 720};
+  parameters.encodings[0].requested_resolution = {.width = 1280, .height = 720};
   sender->SetParameters(parameters);
   // Confirm 1280x720 is sent.
   ASSERT_TRUE_WAIT(GetEncodingResolution(local_pc_wrapper) ==
@@ -2773,7 +2753,7 @@ TEST_P(PeerConnectionEncodingsIntegrationParameterizedTest,
 }
 
 TEST_P(PeerConnectionEncodingsIntegrationParameterizedTest,
-       ScaleToIsOrientationAgnostic) {
+       RequestedResolutionIsOrientationAgnostic) {
   rtc::scoped_refptr<PeerConnectionTestWrapper> local_pc_wrapper = CreatePc();
   if (SkipTestDueToAv1Missing(local_pc_wrapper)) {
     return;
@@ -2801,8 +2781,7 @@ TEST_P(PeerConnectionEncodingsIntegrationParameterizedTest,
   rtc::scoped_refptr<RtpSenderInterface> sender = transceiver->sender();
   RtpParameters parameters = sender->GetParameters();
   ASSERT_THAT(parameters.encodings, SizeIs(1));
-  parameters.encodings[0].scale_resolution_down_to = {.width = 360,
-                                                      .height = 640};
+  parameters.encodings[0].requested_resolution = {.width = 360, .height = 640};
   sender->SetParameters(parameters);
   // Confirm 640x360 is sent.
   ASSERT_TRUE_WAIT(GetEncodingResolution(local_pc_wrapper) ==
@@ -2811,7 +2790,7 @@ TEST_P(PeerConnectionEncodingsIntegrationParameterizedTest,
 }
 
 TEST_P(PeerConnectionEncodingsIntegrationParameterizedTest,
-       ScaleToMaintainsAspectRatio) {
+       RequestedResolutionMaintainsAspectRatio) {
   rtc::scoped_refptr<PeerConnectionTestWrapper> local_pc_wrapper = CreatePc();
   if (SkipTestDueToAv1Missing(local_pc_wrapper)) {
     return;
@@ -2839,8 +2818,7 @@ TEST_P(PeerConnectionEncodingsIntegrationParameterizedTest,
   rtc::scoped_refptr<RtpSenderInterface> sender = transceiver->sender();
   RtpParameters parameters = sender->GetParameters();
   ASSERT_THAT(parameters.encodings, SizeIs(1));
-  parameters.encodings[0].scale_resolution_down_to = {.width = 1280,
-                                                      .height = 360};
+  parameters.encodings[0].requested_resolution = {.width = 1280, .height = 360};
   sender->SetParameters(parameters);
   // Confirm 640x360 is sent.
   ASSERT_TRUE_WAIT(GetEncodingResolution(local_pc_wrapper) ==
diff --git a/video/config/encoder_stream_factory.cc b/video/config/encoder_stream_factory.cc
index 62b00ad043..ad1ee4daf1 100644
--- a/video/config/encoder_stream_factory.cc
+++ b/video/config/encoder_stream_factory.cc
@@ -150,7 +150,7 @@ void OverrideStreamSettings(
     webrtc::VideoStream& layer = layers[i];
     layer.active = overrides.active;
     layer.scalability_mode = overrides.scalability_mode;
-    layer.scale_resolution_down_to = overrides.scale_resolution_down_to;
+    layer.requested_resolution = overrides.requested_resolution;
     // Update with configured num temporal layers if supported by codec.
     if (overrides.num_temporal_layers > 0 && temporal_layers_supported) {
       layer.num_temporal_layers = *overrides.num_temporal_layers;
@@ -352,18 +352,18 @@ EncoderStreamFactory::CreateDefaultVideoStreams(
   layer.width = width;
   layer.height = height;
   layer.max_framerate = max_framerate;
-  layer.scale_resolution_down_to =
-      encoder_config.simulcast_layers[0].scale_resolution_down_to;
+  layer.requested_resolution =
+      encoder_config.simulcast_layers[0].requested_resolution;
   // Note: VP9 seems to have be sending if any layer is active,
   // (see `UpdateSendState`) and still use parameters only from
   // encoder_config.simulcast_layers[0].
   layer.active = absl::c_any_of(encoder_config.simulcast_layers,
                                 [](const auto& layer) { return layer.active; });
 
-  if (encoder_config.simulcast_layers[0].scale_resolution_down_to) {
-    auto res = GetLayerResolutionFromScaleResolutionDownTo(
+  if (encoder_config.simulcast_layers[0].requested_resolution) {
+    auto res = GetLayerResolutionFromRequestedResolution(
         width, height,
-        *encoder_config.simulcast_layers[0].scale_resolution_down_to);
+        *encoder_config.simulcast_layers[0].requested_resolution);
     layer.width = res.width;
     layer.height = res.height;
   } else if (encoder_config.simulcast_layers[0].scale_resolution_down_by > 1.) {
@@ -468,23 +468,23 @@ EncoderStreamFactory::CreateSimulcastOrConferenceModeScreenshareStreams(
 }
 
 webrtc::Resolution
-EncoderStreamFactory::GetLayerResolutionFromScaleResolutionDownTo(
+EncoderStreamFactory::GetLayerResolutionFromRequestedResolution(
     int frame_width,
     int frame_height,
-    webrtc::Resolution scale_resolution_down_to) const {
-  // Make frame and `scale_resolution_down_to` have matching orientation.
+    webrtc::Resolution requested_resolution) const {
+  // Make frame and requested resolution have matching orientation.
   if ((frame_width < frame_height) !=
-      (scale_resolution_down_to.width < scale_resolution_down_to.height)) {
-    scale_resolution_down_to = {.width = scale_resolution_down_to.height,
-                                .height = scale_resolution_down_to.width};
+      (requested_resolution.width < requested_resolution.height)) {
+    requested_resolution = {.width = requested_resolution.height,
+                            .height = requested_resolution.width};
   }
   // Downscale by smallest scaling factor, if necessary.
   if (frame_width > 0 && frame_height > 0 &&
-      (scale_resolution_down_to.width < frame_width ||
-       scale_resolution_down_to.height < frame_height)) {
+      (requested_resolution.width < frame_width ||
+       requested_resolution.height < frame_height)) {
     double scale_factor = std::min(
-        scale_resolution_down_to.width / static_cast<double>(frame_width),
-        scale_resolution_down_to.height / static_cast<double>(frame_height));
+        requested_resolution.width / static_cast<double>(frame_width),
+        requested_resolution.height / static_cast<double>(frame_height));
     frame_width = std::round(frame_width * scale_factor);
     frame_height = std::round(frame_height * scale_factor);
   }
@@ -528,34 +528,33 @@ std::vector<webrtc::Resolution> EncoderStreamFactory::GetStreamResolutions(
   } else {
     size_t min_num_layers = FindRequiredActiveLayers(encoder_config);
     size_t max_num_layers =
-        !encoder_config.HasScaleResolutionDownTo()
+        !encoder_config.HasRequestedResolution()
             ? LimitSimulcastLayerCount(
                   min_num_layers, encoder_config.number_of_streams, width,
                   height, trials, encoder_config.codec_type)
             : encoder_config.number_of_streams;
     RTC_DCHECK_LE(max_num_layers, encoder_config.number_of_streams);
 
-    // When the `scale_resolution_down_to` API is used, disable upper layers
-    // that are bigger than what adaptation restrictions allow. For example if
+    // When the `requested_resolution` API is used, disable upper layers that
+    // are bigger than what adaptation restrictions allow. For example if
     // restrictions are 540p, simulcast 180p:360p:720p becomes 180p:360p:- as
     // opposed to 180p:360p:540p. This makes CPU adaptation consistent with BW
     // adaptation (bitrate allocator disabling layers rather than downscaling)
     // and means we don't have to break power of two optimization paths (i.e.
     // S-modes based simulcast). Note that the lowest layer is never disabled.
-    if (encoder_config.HasScaleResolutionDownTo() &&
-        restrictions_.has_value() &&
+    if (encoder_config.HasRequestedResolution() && restrictions_.has_value() &&
         restrictions_->max_pixels_per_frame().has_value()) {
       int max_pixels = rtc::dchecked_cast<int>(
           restrictions_->max_pixels_per_frame().value());
       int prev_pixel_count =
           encoder_config.simulcast_layers[0]
-              .scale_resolution_down_to.value_or(webrtc::Resolution())
+              .requested_resolution.value_or(webrtc::Resolution())
               .PixelCount();
       std::optional<size_t> restricted_num_layers;
       for (size_t i = 1; i < max_num_layers; ++i) {
         int pixel_count =
             encoder_config.simulcast_layers[i]
-                .scale_resolution_down_to.value_or(webrtc::Resolution())
+                .requested_resolution.value_or(webrtc::Resolution())
                 .PixelCount();
         if (!restricted_num_layers.has_value() && max_pixels < pixel_count) {
           // Current layer is the highest layer allowed by restrictions.
@@ -597,11 +596,10 @@ std::vector<webrtc::Resolution> EncoderStreamFactory::GetStreamResolutions(
 
     resolutions.resize(max_num_layers);
     for (size_t i = 0; i < max_num_layers; i++) {
-      if (encoder_config.simulcast_layers[i]
-              .scale_resolution_down_to.has_value()) {
-        resolutions[i] = GetLayerResolutionFromScaleResolutionDownTo(
+      if (encoder_config.simulcast_layers[i].requested_resolution.has_value()) {
+        resolutions[i] = GetLayerResolutionFromRequestedResolution(
             normalized_width, normalized_height,
-            *encoder_config.simulcast_layers[i].scale_resolution_down_to);
+            *encoder_config.simulcast_layers[i].requested_resolution);
       } else if (has_scale_resolution_down_by) {
         const double scale_resolution_down_by = std::max(
             encoder_config.simulcast_layers[i].scale_resolution_down_by, 1.0);
diff --git a/video/config/encoder_stream_factory.h b/video/config/encoder_stream_factory.h
index 8fd2013147..3d0705eaf9 100644
--- a/video/config/encoder_stream_factory.h
+++ b/video/config/encoder_stream_factory.h
@@ -49,10 +49,10 @@ class EncoderStreamFactory
       const webrtc::VideoEncoderConfig& encoder_config,
       const std::optional<webrtc::DataRate>& experimental_min_bitrate) const;
 
-  webrtc::Resolution GetLayerResolutionFromScaleResolutionDownTo(
+  webrtc::Resolution GetLayerResolutionFromRequestedResolution(
       int in_frame_width,
       int in_frame_height,
-      webrtc::Resolution scale_resolution_down_to) const;
+      webrtc::Resolution requested_resolution) const;
 
   std::vector<webrtc::Resolution> GetStreamResolutions(
       const webrtc::FieldTrialsView& trials,
diff --git a/video/config/encoder_stream_factory_unittest.cc b/video/config/encoder_stream_factory_unittest.cc
index 4638e48d50..1cf901dbbf 100644
--- a/video/config/encoder_stream_factory_unittest.cc
+++ b/video/config/encoder_stream_factory_unittest.cc
@@ -79,23 +79,23 @@ std::vector<VideoStream> CreateEncoderStreams(
 
 }  // namespace
 
-TEST(EncoderStreamFactory, SinglecastScaleResolutionDownTo) {
+TEST(EncoderStreamFactory, SinglecastRequestedResolution) {
   ExplicitKeyValueConfig field_trials("");
   VideoEncoderConfig encoder_config;
   encoder_config.number_of_streams = 1;
   encoder_config.simulcast_layers.resize(1);
-  encoder_config.simulcast_layers[0].scale_resolution_down_to = {.width = 640,
-                                                                 .height = 360};
+  encoder_config.simulcast_layers[0].requested_resolution = {.width = 640,
+                                                             .height = 360};
   auto streams = CreateEncoderStreams(
       field_trials, {.width = 1280, .height = 720}, encoder_config);
-  EXPECT_EQ(streams[0].scale_resolution_down_to,
+  EXPECT_EQ(streams[0].requested_resolution,
             (Resolution{.width = 640, .height = 360}));
   EXPECT_EQ(GetStreamResolutions(streams), (std::vector<Resolution>{
                                                {.width = 640, .height = 360},
                                            }));
 }
 
-TEST(EncoderStreamFactory, SinglecastScaleResolutionDownToWithAdaptation) {
+TEST(EncoderStreamFactory, SinglecastRequestedResolutionWithAdaptation) {
   ExplicitKeyValueConfig field_trials("");
   VideoSourceRestrictions restrictions(
       /* max_pixels_per_frame= */ (320 * 320),
@@ -104,29 +104,29 @@ TEST(EncoderStreamFactory, SinglecastScaleResolutionDownToWithAdaptation) {
   VideoEncoderConfig encoder_config;
   encoder_config.number_of_streams = 1;
   encoder_config.simulcast_layers.resize(1);
-  encoder_config.simulcast_layers[0].scale_resolution_down_to = {.width = 640,
-                                                                 .height = 360};
+  encoder_config.simulcast_layers[0].requested_resolution = {.width = 640,
+                                                             .height = 360};
   auto streams =
       CreateEncoderStreams(field_trials, {.width = 1280, .height = 720},
                            encoder_config, restrictions);
-  EXPECT_EQ(streams[0].scale_resolution_down_to,
+  EXPECT_EQ(streams[0].requested_resolution,
             (Resolution{.width = 640, .height = 360}));
   EXPECT_EQ(GetStreamResolutions(streams), (std::vector<Resolution>{
                                                {.width = 320, .height = 180},
                                            }));
 }
 
-TEST(EncoderStreamFactory, SimulcastScaleResolutionDownToUnrestricted) {
+TEST(EncoderStreamFactory, SimulcastRequestedResolutionUnrestricted) {
   ExplicitKeyValueConfig field_trials("");
   VideoEncoderConfig encoder_config;
   encoder_config.number_of_streams = 3;
   encoder_config.simulcast_layers.resize(3);
-  encoder_config.simulcast_layers[0].scale_resolution_down_to = {.width = 320,
-                                                                 .height = 180};
-  encoder_config.simulcast_layers[1].scale_resolution_down_to = {.width = 640,
-                                                                 .height = 360};
-  encoder_config.simulcast_layers[2].scale_resolution_down_to = {.width = 1280,
-                                                                 .height = 720};
+  encoder_config.simulcast_layers[0].requested_resolution = {.width = 320,
+                                                             .height = 180};
+  encoder_config.simulcast_layers[1].requested_resolution = {.width = 640,
+                                                             .height = 360};
+  encoder_config.simulcast_layers[2].requested_resolution = {.width = 1280,
+                                                             .height = 720};
   auto streams = CreateEncoderStreams(
       field_trials, {.width = 1280, .height = 720}, encoder_config);
   std::vector<Resolution> stream_resolutions = GetStreamResolutions(streams);
@@ -136,7 +136,7 @@ TEST(EncoderStreamFactory, SimulcastScaleResolutionDownToUnrestricted) {
   EXPECT_EQ(stream_resolutions[2], (Resolution{.width = 1280, .height = 720}));
 }
 
-TEST(EncoderStreamFactory, SimulcastScaleResolutionDownToWith360pRestriction) {
+TEST(EncoderStreamFactory, SimulcastRequestedResolutionWith360pRestriction) {
   ExplicitKeyValueConfig field_trials("");
   VideoSourceRestrictions restrictions(
       /* max_pixels_per_frame= */ (640 * 360),
@@ -145,12 +145,12 @@ TEST(EncoderStreamFactory, SimulcastScaleResolutionDownToWith360pRestriction) {
   VideoEncoderConfig encoder_config;
   encoder_config.number_of_streams = 3;
   encoder_config.simulcast_layers.resize(3);
-  encoder_config.simulcast_layers[0].scale_resolution_down_to = {.width = 320,
-                                                                 .height = 180};
-  encoder_config.simulcast_layers[1].scale_resolution_down_to = {.width = 640,
-                                                                 .height = 360};
-  encoder_config.simulcast_layers[2].scale_resolution_down_to = {.width = 1280,
-                                                                 .height = 720};
+  encoder_config.simulcast_layers[0].requested_resolution = {.width = 320,
+                                                             .height = 180};
+  encoder_config.simulcast_layers[1].requested_resolution = {.width = 640,
+                                                             .height = 360};
+  encoder_config.simulcast_layers[2].requested_resolution = {.width = 1280,
+                                                             .height = 720};
   auto streams =
       CreateEncoderStreams(field_trials, {.width = 1280, .height = 720},
                            encoder_config, restrictions);
@@ -161,7 +161,7 @@ TEST(EncoderStreamFactory, SimulcastScaleResolutionDownToWith360pRestriction) {
   EXPECT_EQ(stream_resolutions[1], (Resolution{.width = 640, .height = 360}));
 }
 
-TEST(EncoderStreamFactory, SimulcastScaleResolutionDownToWith90pRestriction) {
+TEST(EncoderStreamFactory, SimulcastRequestedResolutionWith90pRestriction) {
   ExplicitKeyValueConfig field_trials("");
   VideoSourceRestrictions restrictions(
       /* max_pixels_per_frame= */ (160 * 90),
@@ -170,12 +170,12 @@ TEST(EncoderStreamFactory, SimulcastScaleResolutionDownToWith90pRestriction) {
   VideoEncoderConfig encoder_config;
   encoder_config.number_of_streams = 3;
   encoder_config.simulcast_layers.resize(3);
-  encoder_config.simulcast_layers[0].scale_resolution_down_to = {.width = 320,
-                                                                 .height = 180};
-  encoder_config.simulcast_layers[1].scale_resolution_down_to = {.width = 640,
-                                                                 .height = 360};
-  encoder_config.simulcast_layers[2].scale_resolution_down_to = {.width = 1280,
-                                                                 .height = 720};
+  encoder_config.simulcast_layers[0].requested_resolution = {.width = 320,
+                                                             .height = 180};
+  encoder_config.simulcast_layers[1].requested_resolution = {.width = 640,
+                                                             .height = 360};
+  encoder_config.simulcast_layers[2].requested_resolution = {.width = 1280,
+                                                             .height = 720};
   auto streams =
       CreateEncoderStreams(field_trials, {.width = 1280, .height = 720},
                            encoder_config, restrictions);
@@ -186,8 +186,7 @@ TEST(EncoderStreamFactory, SimulcastScaleResolutionDownToWith90pRestriction) {
   EXPECT_EQ(stream_resolutions[0], (Resolution{.width = 160, .height = 90}));
 }
 
-TEST(EncoderStreamFactory,
-     ReverseSimulcastScaleResolutionDownToWithRestriction) {
+TEST(EncoderStreamFactory, ReverseSimulcastRequestedResolutionWithRestriction) {
   ExplicitKeyValueConfig field_trials("");
   VideoSourceRestrictions restrictions(
       /* max_pixels_per_frame= */ (640 * 360),
@@ -197,12 +196,12 @@ TEST(EncoderStreamFactory,
   encoder_config.number_of_streams = 3;
   encoder_config.simulcast_layers.resize(3);
   // 720p, 360p, 180p (instead of the usual 180p, 360p, 720p).
-  encoder_config.simulcast_layers[0].scale_resolution_down_to = {.width = 1280,
-                                                                 .height = 720};
-  encoder_config.simulcast_layers[1].scale_resolution_down_to = {.width = 640,
-                                                                 .height = 360};
-  encoder_config.simulcast_layers[2].scale_resolution_down_to = {.width = 320,
-                                                                 .height = 180};
+  encoder_config.simulcast_layers[0].requested_resolution = {.width = 1280,
+                                                             .height = 720};
+  encoder_config.simulcast_layers[1].requested_resolution = {.width = 640,
+                                                             .height = 360};
+  encoder_config.simulcast_layers[2].requested_resolution = {.width = 320,
+                                                             .height = 180};
   auto streams =
       CreateEncoderStreams(field_trials, {.width = 1280, .height = 720},
                            encoder_config, restrictions);
diff --git a/video/config/video_encoder_config.cc b/video/config/video_encoder_config.cc
index 9dc9a52c89..24b8f2a1f5 100644
--- a/video/config/video_encoder_config.cc
+++ b/video/config/video_encoder_config.cc
@@ -88,9 +88,9 @@ std::string VideoEncoderConfig::ToString() const {
   return ss.str();
 }
 
-bool VideoEncoderConfig::HasScaleResolutionDownTo() const {
+bool VideoEncoderConfig::HasRequestedResolution() const {
   for (const VideoStream& simulcast_layer : simulcast_layers) {
-    if (simulcast_layer.scale_resolution_down_to.has_value()) {
+    if (simulcast_layer.requested_resolution.has_value()) {
       return true;
     }
   }
diff --git a/video/config/video_encoder_config.h b/video/config/video_encoder_config.h
index 59ee866f53..bd05ab0683 100644
--- a/video/config/video_encoder_config.h
+++ b/video/config/video_encoder_config.h
@@ -36,7 +36,7 @@ struct VideoStream {
 
   // Width/Height in pixels.
   // This is the actual width and height used to configure encoder,
-  // which might be less than `scale_resolution_down_to` due to adaptation
+  // which might be less than `requested_resolution` due to adaptation
   // or due to the source providing smaller frames than requested.
   size_t width;
   size_t height;
@@ -75,14 +75,14 @@ struct VideoStream {
 
   // An optional user supplied max_frame_resolution
   // than can be set independently of (adapted) VideoSource.
-  // This value is set from RtpEncodingParameters::scale_resolution_down_to
+  // This value is set from RtpEncodingParameters::requested_resolution
   // (i.e. used for signaling app-level settings).
   //
   // The actual encode resolution is in `width` and `height`,
-  // which can be lower than scale_resolution_down_to,
+  // which can be lower than requested_resolution,
   // e.g. if source only provides lower resolution or
   // if resource adaptation is active.
-  std::optional<Resolution> scale_resolution_down_to;
+  std::optional<Resolution> requested_resolution;
 };
 
 class VideoEncoderConfig {
@@ -166,7 +166,7 @@ class VideoEncoderConfig {
   ~VideoEncoderConfig();
   std::string ToString() const;
 
-  bool HasScaleResolutionDownTo() const;
+  bool HasRequestedResolution() const;
 
   // TODO(bugs.webrtc.org/6883): Consolidate on one of these.
   VideoCodecType codec_type;
diff --git a/video/video_source_sink_controller.cc b/video/video_source_sink_controller.cc
index e2adecdf25..3a4904432c 100644
--- a/video/video_source_sink_controller.cc
+++ b/video/video_source_sink_controller.cc
@@ -105,9 +105,9 @@ bool VideoSourceSinkController::active() const {
 }
 
 std::optional<rtc::VideoSinkWants::FrameSize>
-VideoSourceSinkController::scale_resolution_down_to() const {
+VideoSourceSinkController::requested_resolution() const {
   RTC_DCHECK_RUN_ON(&sequence_checker_);
-  return scale_resolution_down_to_;
+  return requested_resolution_;
 }
 
 void VideoSourceSinkController::SetRestrictions(
@@ -150,10 +150,10 @@ void VideoSourceSinkController::SetActive(bool active) {
   active_ = active;
 }
 
-void VideoSourceSinkController::SetScaleResolutionDownTo(
-    std::optional<rtc::VideoSinkWants::FrameSize> scale_resolution_down_to) {
+void VideoSourceSinkController::SetRequestedResolution(
+    std::optional<rtc::VideoSinkWants::FrameSize> requested_resolution) {
   RTC_DCHECK_RUN_ON(&sequence_checker_);
-  scale_resolution_down_to_ = std::move(scale_resolution_down_to);
+  requested_resolution_ = std::move(requested_resolution);
 }
 
 // RTC_EXCLUSIVE_LOCKS_REQUIRED(sequence_checker_)
@@ -186,7 +186,7 @@ rtc::VideoSinkWants VideoSourceSinkController::CurrentSettingsToSinkWants()
                    : std::numeric_limits<int>::max());
   wants.resolutions = resolutions_;
   wants.is_active = active_;
-  wants.scale_resolution_down_to = scale_resolution_down_to_;
+  wants.requested_resolution = requested_resolution_;
   return wants;
 }
 
diff --git a/video/video_source_sink_controller.h b/video/video_source_sink_controller.h
index 33cb792287..9ce0fb552a 100644
--- a/video/video_source_sink_controller.h
+++ b/video/video_source_sink_controller.h
@@ -52,8 +52,7 @@ class VideoSourceSinkController {
   int resolution_alignment() const;
   const std::vector<rtc::VideoSinkWants::FrameSize>& resolutions() const;
   bool active() const;
-  std::optional<rtc::VideoSinkWants::FrameSize> scale_resolution_down_to()
-      const;
+  std::optional<rtc::VideoSinkWants::FrameSize> requested_resolution() const;
 
   // Updates the settings stored internally. In order for these settings to be
   // applied to the sink, PushSourceSinkSettings() must subsequently be called.
@@ -65,8 +64,8 @@ class VideoSourceSinkController {
   void SetResolutionAlignment(int resolution_alignment);
   void SetResolutions(std::vector<rtc::VideoSinkWants::FrameSize> resolutions);
   void SetActive(bool active);
-  void SetScaleResolutionDownTo(
-      std::optional<rtc::VideoSinkWants::FrameSize> scale_resolution_down_to);
+  void SetRequestedResolution(
+      std::optional<rtc::VideoSinkWants::FrameSize> requested_resolution);
 
  private:
   rtc::VideoSinkWants CurrentSettingsToSinkWants() const
@@ -94,7 +93,7 @@ class VideoSourceSinkController {
   std::vector<rtc::VideoSinkWants::FrameSize> resolutions_
       RTC_GUARDED_BY(&sequence_checker_);
   bool active_ RTC_GUARDED_BY(&sequence_checker_) = true;
-  std::optional<rtc::VideoSinkWants::FrameSize> scale_resolution_down_to_
+  std::optional<rtc::VideoSinkWants::FrameSize> requested_resolution_
       RTC_GUARDED_BY(&sequence_checker_);
 };
 
diff --git a/video/video_source_sink_controller_unittest.cc b/video/video_source_sink_controller_unittest.cc
index 67d6451fdf..bddfc0dcc7 100644
--- a/video/video_source_sink_controller_unittest.cc
+++ b/video/video_source_sink_controller_unittest.cc
@@ -62,7 +62,7 @@ TEST(VideoSourceSinkControllerTest, UnconstrainedByDefault) {
   EXPECT_FALSE(controller.pixels_per_frame_upper_limit().has_value());
   EXPECT_FALSE(controller.frame_rate_upper_limit().has_value());
   EXPECT_FALSE(controller.rotation_applied());
-  EXPECT_FALSE(controller.scale_resolution_down_to().has_value());
+  EXPECT_FALSE(controller.requested_resolution().has_value());
   EXPECT_EQ(controller.resolution_alignment(), 1);
 
   EXPECT_CALL(source, AddOrUpdateSink(_, _))
@@ -73,7 +73,7 @@ TEST(VideoSourceSinkControllerTest, UnconstrainedByDefault) {
         EXPECT_EQ(wants.target_pixel_count, std::nullopt);
         EXPECT_EQ(wants.max_framerate_fps, kIntUnconstrained);
         EXPECT_EQ(wants.resolution_alignment, 1);
-        EXPECT_FALSE(wants.scale_resolution_down_to.has_value());
+        EXPECT_FALSE(wants.requested_resolution.has_value());
       });
   controller.PushSourceSinkSettings();
 }
@@ -166,17 +166,17 @@ TEST(VideoSourceSinkControllerTest,
   controller.RequestRefreshFrame();
 }
 
-TEST(VideoSourceSinkControllerTest, ScaleResolutionDownToPropagatesToWants) {
+TEST(VideoSourceSinkControllerTest, RequestedResolutionPropagatesToWants) {
   MockVideoSinkWithVideoFrame sink;
   MockVideoSourceWithVideoFrame source;
   VideoSourceSinkController controller(&sink, &source);
-  controller.SetScaleResolutionDownTo(FrameSize(640, 360));
-  EXPECT_TRUE(controller.scale_resolution_down_to().has_value());
+  controller.SetRequestedResolution(FrameSize(640, 360));
+  EXPECT_TRUE(controller.requested_resolution().has_value());
 
   EXPECT_CALL(source, AddOrUpdateSink(_, _))
       .WillOnce([](rtc::VideoSinkInterface<VideoFrame>* sink,
                    const rtc::VideoSinkWants& wants) {
-        EXPECT_EQ(*wants.scale_resolution_down_to, FrameSize(640, 360));
+        EXPECT_EQ(*wants.requested_resolution, FrameSize(640, 360));
       });
   controller.PushSourceSinkSettings();
 }
diff --git a/video/video_stream_encoder.cc b/video/video_stream_encoder.cc
index 324c9f9e8f..4fc7771f0f 100644
--- a/video/video_stream_encoder.cc
+++ b/video/video_stream_encoder.cc
@@ -872,40 +872,38 @@ void VideoStreamEncoder::ConfigureEncoder(VideoEncoderConfig config,
   RTC_DCHECK_RUN_ON(worker_queue_);
 
   // Inform source about max configured framerate,
-  // scale_resolution_down_to and which layers are active.
+  // requested_resolution and which layers are active.
   int max_framerate = -1;
   // Is any layer active.
   bool active = false;
-  // The max scale_resolution_down_to.
-  std::optional<rtc::VideoSinkWants::FrameSize> scale_resolution_down_to;
+  // The max requested_resolution.
+  std::optional<rtc::VideoSinkWants::FrameSize> requested_resolution;
   for (const auto& stream : config.simulcast_layers) {
     active |= stream.active;
     if (stream.active) {
       max_framerate = std::max(stream.max_framerate, max_framerate);
     }
-    // Note: we propagate the highest scale_resolution_down_to regardless
+    // Note: we propagate the highest requested_resolution regardless
     // if layer is active or not.
-    if (stream.scale_resolution_down_to) {
-      if (!scale_resolution_down_to) {
-        scale_resolution_down_to.emplace(
-            stream.scale_resolution_down_to->width,
-            stream.scale_resolution_down_to->height);
+    if (stream.requested_resolution) {
+      if (!requested_resolution) {
+        requested_resolution.emplace(stream.requested_resolution->width,
+                                     stream.requested_resolution->height);
       } else {
-        scale_resolution_down_to.emplace(
-            std::max(stream.scale_resolution_down_to->width,
-                     scale_resolution_down_to->width),
-            std::max(stream.scale_resolution_down_to->height,
-                     scale_resolution_down_to->height));
+        requested_resolution.emplace(
+            std::max(stream.requested_resolution->width,
+                     requested_resolution->width),
+            std::max(stream.requested_resolution->height,
+                     requested_resolution->height));
       }
     }
   }
-  if (scale_resolution_down_to !=
-          video_source_sink_controller_.scale_resolution_down_to() ||
+  if (requested_resolution !=
+          video_source_sink_controller_.requested_resolution() ||
       active != video_source_sink_controller_.active() ||
       max_framerate !=
           video_source_sink_controller_.frame_rate_upper_limit().value_or(-1)) {
-    video_source_sink_controller_.SetScaleResolutionDownTo(
-        scale_resolution_down_to);
+    video_source_sink_controller_.SetRequestedResolution(requested_resolution);
     if (max_framerate >= 0) {
       video_source_sink_controller_.SetFrameRateUpperLimit(max_framerate);
     } else {
@@ -2414,12 +2412,12 @@ void VideoStreamEncoder::OnVideoSourceRestrictionsUpdated(
   // so that ownership on restrictions/wants is kept on &encoder_queue_
   latest_restrictions_ = restrictions;
 
-  // When the `scale_resolution_down_to` API is used, we need to reconfigure any
+  // When the `requested_resolution` API is used, we need to reconfigure any
   // time the restricted resolution is updated. When that API isn't used, the
   // encoder settings are relative to the frame size and reconfiguration happens
   // automatically on new frame size and we don't need to reconfigure here.
   if (encoder_ && max_pixels_updated &&
-      encoder_config_.HasScaleResolutionDownTo()) {
+      encoder_config_.HasRequestedResolution()) {
     // The encoder will be reconfigured on the next frame.
     pending_encoder_reconfiguration_ = true;
   }
diff --git a/video/video_stream_encoder_unittest.cc b/video/video_stream_encoder_unittest.cc
index 9fc90298e2..b93a1255da 100644
--- a/video/video_stream_encoder_unittest.cc
+++ b/video/video_stream_encoder_unittest.cc
@@ -2588,7 +2588,7 @@ TEST_F(VideoStreamEncoderTest, FrameRateLimitCanBeReset) {
 }
 
 TEST_F(VideoStreamEncoderTest, RequestInSinkWantsBeforeFirstFrame) {
-  // Use a real video stream factory or else `scale_resolution_down_to` is not
+  // Use a real video stream factory or else `requested_resolution` is not
   // applied correctly.
   video_encoder_config_.video_stream_factory = nullptr;
   ConfigureEncoder(video_encoder_config_.Copy());
@@ -2596,30 +2596,28 @@ TEST_F(VideoStreamEncoderTest, RequestInSinkWantsBeforeFirstFrame) {
       kTargetBitrate, kTargetBitrate, kTargetBitrate, 0, 0, 0);
 
   ASSERT_THAT(video_encoder_config_.simulcast_layers, SizeIs(1));
-  video_encoder_config_.simulcast_layers[0].scale_resolution_down_to.emplace(
+  video_encoder_config_.simulcast_layers[0].requested_resolution.emplace(
       Resolution({.width = 320, .height = 160}));
 
   video_stream_encoder_->ConfigureEncoder(video_encoder_config_.Copy(),
                                           kMaxPayloadLength);
 
-  EXPECT_EQ(video_source_.sink_wants().scale_resolution_down_to,
+  EXPECT_EQ(video_source_.sink_wants().requested_resolution,
             rtc::VideoSinkWants::FrameSize(320, 160));
 
-  video_encoder_config_.simulcast_layers[0].scale_resolution_down_to->height =
-      320;
-  video_encoder_config_.simulcast_layers[0].scale_resolution_down_to->width =
-      640;
+  video_encoder_config_.simulcast_layers[0].requested_resolution->height = 320;
+  video_encoder_config_.simulcast_layers[0].requested_resolution->width = 640;
   video_stream_encoder_->ConfigureEncoder(video_encoder_config_.Copy(),
                                           kMaxPayloadLength);
 
-  EXPECT_EQ(video_source_.sink_wants().scale_resolution_down_to,
+  EXPECT_EQ(video_source_.sink_wants().requested_resolution,
             rtc::VideoSinkWants::FrameSize(640, 320));
 
   video_stream_encoder_->Stop();
 }
 
 TEST_F(VideoStreamEncoderTest, RequestInWrongAspectRatioWithAdapter) {
-  // Use a real video stream factory or else `scale_resolution_down_to` is not
+  // Use a real video stream factory or else `requested_resolution` is not
   // applied correctly.
   video_encoder_config_.video_stream_factory = nullptr;
   ConfigureEncoder(video_encoder_config_.Copy());
@@ -2633,7 +2631,7 @@ TEST_F(VideoStreamEncoderTest, RequestInWrongAspectRatioWithAdapter) {
       &source, webrtc::DegradationPreference::MAINTAIN_FRAMERATE);
 
   ASSERT_THAT(video_encoder_config_.simulcast_layers, SizeIs(1));
-  video_encoder_config_.simulcast_layers[0].scale_resolution_down_to = {
+  video_encoder_config_.simulcast_layers[0].requested_resolution = {
       .width = 30, .height = 30};
   video_stream_encoder_->ConfigureEncoder(video_encoder_config_.Copy(),
                                           kMaxPayloadLength);
@@ -6316,8 +6314,8 @@ TEST_F(VideoStreamEncoderTest,
 
 enum class FrameResolutionChangeMethod {
   MODIFY_SOURCE,
-  MODIFY_SCALE_RESOLUTION_DOWN_TO,
-  MODIFY_SCALE_RESOLUTION_DOWN_BY,
+  MODIFY_REQUESTED_RESOLUTION,
+  MODIFY_SCALE_RESOLUTION_BY,
 };
 class VideoStreamEncoderInitialFrameDropperTest
     : public VideoStreamEncoderTest,
@@ -6331,12 +6329,12 @@ class VideoStreamEncoderInitialFrameDropperTest
     switch (frame_resolution_change_method_) {
       case FrameResolutionChangeMethod::MODIFY_SOURCE:
         break;
-      case FrameResolutionChangeMethod::MODIFY_SCALE_RESOLUTION_DOWN_TO:
+      case FrameResolutionChangeMethod::MODIFY_REQUESTED_RESOLUTION:
         video_encoder_config_.video_stream_factory = nullptr;
         captureWidth = kWidth;
         captureHeight = kHeight;
         break;
-      case FrameResolutionChangeMethod::MODIFY_SCALE_RESOLUTION_DOWN_BY:
+      case FrameResolutionChangeMethod::MODIFY_SCALE_RESOLUTION_BY:
         captureWidth = kWidth;
         captureHeight = kHeight;
         break;
@@ -6349,15 +6347,14 @@ class VideoStreamEncoderInitialFrameDropperTest
         captureWidth = width;
         captureHeight = height;
         break;
-      case FrameResolutionChangeMethod::MODIFY_SCALE_RESOLUTION_DOWN_TO:
+      case FrameResolutionChangeMethod::MODIFY_REQUESTED_RESOLUTION:
         ASSERT_THAT(video_encoder_config_.simulcast_layers, SizeIs(1));
-        video_encoder_config_.simulcast_layers[0]
-            .scale_resolution_down_to.emplace(
-                Resolution({.width = width, .height = height}));
+        video_encoder_config_.simulcast_layers[0].requested_resolution.emplace(
+            Resolution({.width = width, .height = height}));
         video_stream_encoder_->ConfigureEncoder(video_encoder_config_.Copy(),
                                                 kMaxPayloadLength);
         break;
-      case FrameResolutionChangeMethod::MODIFY_SCALE_RESOLUTION_DOWN_BY:
+      case FrameResolutionChangeMethod::MODIFY_SCALE_RESOLUTION_BY:
         ASSERT_THAT(video_encoder_config_.simulcast_layers, SizeIs(1));
         double scale_height =
             static_cast<double>(kHeight) / static_cast<double>(height);
@@ -6384,10 +6381,9 @@ class VideoStreamEncoderInitialFrameDropperTest
 INSTANTIATE_TEST_SUITE_P(
     VideoStreamEncoderInitialFrameDropperTest,
     VideoStreamEncoderInitialFrameDropperTest,
-    ::testing::Values(
-        FrameResolutionChangeMethod::MODIFY_SOURCE,
-        FrameResolutionChangeMethod::MODIFY_SCALE_RESOLUTION_DOWN_TO,
-        FrameResolutionChangeMethod::MODIFY_SCALE_RESOLUTION_DOWN_BY));
+    ::testing::Values(FrameResolutionChangeMethod::MODIFY_SOURCE,
+                      FrameResolutionChangeMethod::MODIFY_REQUESTED_RESOLUTION,
+                      FrameResolutionChangeMethod::MODIFY_SCALE_RESOLUTION_BY));
 
 TEST_P(VideoStreamEncoderInitialFrameDropperTest,
        InitialFrameDropActivatesWhenResolutionIncreases) {
@@ -6435,7 +6431,7 @@ TEST_P(VideoStreamEncoderInitialFrameDropperTest,
 
   int timestamp = 1;
 
-  // By using the `scale_resolution_down_to` API, ReconfigureEncoder() gets
+  // By using the `requested_resolution` API, ReconfigureEncoder() gets
   // triggered from VideoStreamEncoder::OnVideoSourceRestrictionsUpdated().
   SetEncoderFrameSize(kWidth, kHeight);
 
