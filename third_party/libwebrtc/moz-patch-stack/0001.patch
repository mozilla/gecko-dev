From: Byron Campen <docfaraday@gmail.com>
Date: Wed, 24 Jul 2024 18:01:00 -0500
Subject: (tmp-cherry-pick) Revert "p2p: reduce visibility of ICE tiebreaker
 further" (dbbb6cabc3)
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This reverts commit b5df2ba10db3cd04febcde8727e782457708f2fa.

Reason for revert: Breaks downstream

Original change's description:
> p2p: reduce visibility of ICE tiebreaker further
>
> since the tie breaker is owned by the allocator now.
>
> BUG=webrtc:42224914
>
> Change-Id: I76bd5ae714fb2a6df38e014991242f390ae87e6a
> Reviewed-on: https://webrtc-review.googlesource.com/c/src/+/351180
> Reviewed-by: Harald Alvestrand <hta@webrtc.org>
> Reviewed-by: Tomas Gunnarsson <tommi@webrtc.org>
> Commit-Queue: Philipp Hancke <phancke@meta.com>
> Cr-Commit-Position: refs/heads/main@{#42371}

Bug: webrtc:42224914
Change-Id: Ic9d5ee229738575910bd33dee278f6049be81205
Reviewed-on: https://webrtc-review.googlesource.com/c/src/+/351680
Bot-Commit: rubber-stamper@appspot.gserviceaccount.com <rubber-stamper@appspot.gserviceaccount.com>
Reviewed-by: Mirko Bonadei <mbonadei@webrtc.org>
Auto-Submit: Bj√∂rn Terelius <terelius@webrtc.org>
Owners-Override: Mirko Bonadei <mbonadei@webrtc.org>
Commit-Queue: Mirko Bonadei <mbonadei@webrtc.org>
Cr-Commit-Position: refs/heads/main@{#42374}
---
 p2p/base/dtls_transport_unittest.cc        |  2 +
 p2p/base/fake_ice_transport.h              |  9 +++
 p2p/base/ice_transport_internal.h          |  2 +
 p2p/base/mock_ice_transport.h              |  1 +
 p2p/base/p2p_transport_channel.cc          | 14 ++++-
 p2p/base/p2p_transport_channel.h           |  2 +
 p2p/base/p2p_transport_channel_unittest.cc | 72 ++++++++++++++--------
 pc/jsep_transport_controller.cc            |  2 +
 pc/jsep_transport_controller.h             |  1 +
 9 files changed, 78 insertions(+), 27 deletions(-)

diff --git a/p2p/base/dtls_transport_unittest.cc b/p2p/base/dtls_transport_unittest.cc
index f870c1e207..93653c116f 100644
--- a/p2p/base/dtls_transport_unittest.cc
+++ b/p2p/base/dtls_transport_unittest.cc
@@ -92,6 +92,8 @@ class DtlsTestClient : public sigslot::has_slots<> {
     fake_ice_transport_->SetAsync(true);
     fake_ice_transport_->SetAsyncDelay(async_delay_ms);
     fake_ice_transport_->SetIceRole(role);
+    fake_ice_transport_->SetIceTiebreaker((role == ICEROLE_CONTROLLING) ? 1
+                                                                        : 2);
     // Hook the raw packets so that we can verify they are encrypted.
     fake_ice_transport_->RegisterReceivedPacketCallback(
         this, [&](rtc::PacketTransportInternal* transport,
diff --git a/p2p/base/fake_ice_transport.h b/p2p/base/fake_ice_transport.h
index 788299bb38..285bfff59c 100644
--- a/p2p/base/fake_ice_transport.h
+++ b/p2p/base/fake_ice_transport.h
@@ -147,6 +147,10 @@ class FakeIceTransport : public IceTransportInternal {
   // Fake IceTransportInternal implementation.
   const std::string& transport_name() const override { return name_; }
   int component() const override { return component_; }
+  uint64_t IceTiebreaker() const {
+    RTC_DCHECK_RUN_ON(network_thread_);
+    return tiebreaker_;
+  }
   IceMode remote_ice_mode() const {
     RTC_DCHECK_RUN_ON(network_thread_);
     return remote_ice_mode_;
@@ -208,6 +212,10 @@ class FakeIceTransport : public IceTransportInternal {
     RTC_DCHECK_RUN_ON(network_thread_);
     return role_;
   }
+  void SetIceTiebreaker(uint64_t tiebreaker) override {
+    RTC_DCHECK_RUN_ON(network_thread_);
+    tiebreaker_ = tiebreaker;
+  }
   void SetIceParameters(const IceParameters& ice_params) override {
     RTC_DCHECK_RUN_ON(network_thread_);
     ice_parameters_ = ice_params;
@@ -398,6 +406,7 @@ class FakeIceTransport : public IceTransportInternal {
   Candidates remote_candidates_ RTC_GUARDED_BY(network_thread_);
   IceConfig ice_config_ RTC_GUARDED_BY(network_thread_);
   IceRole role_ RTC_GUARDED_BY(network_thread_) = ICEROLE_UNKNOWN;
+  uint64_t tiebreaker_ RTC_GUARDED_BY(network_thread_) = 0;
   IceParameters ice_parameters_ RTC_GUARDED_BY(network_thread_);
   IceParameters remote_ice_parameters_ RTC_GUARDED_BY(network_thread_);
   IceMode remote_ice_mode_ RTC_GUARDED_BY(network_thread_) = ICEMODE_FULL;
diff --git a/p2p/base/ice_transport_internal.h b/p2p/base/ice_transport_internal.h
index 48f12f9f50..46717cc230 100644
--- a/p2p/base/ice_transport_internal.h
+++ b/p2p/base/ice_transport_internal.h
@@ -254,6 +254,8 @@ class RTC_EXPORT IceTransportInternal : public rtc::PacketTransportInternal {
 
   virtual void SetIceRole(IceRole role) = 0;
 
+  virtual void SetIceTiebreaker(uint64_t tiebreaker) = 0;
+
   virtual void SetIceCredentials(absl::string_view ice_ufrag,
                                  absl::string_view ice_pwd);
 
diff --git a/p2p/base/mock_ice_transport.h b/p2p/base/mock_ice_transport.h
index b7b986e022..ef6bdce3c0 100644
--- a/p2p/base/mock_ice_transport.h
+++ b/p2p/base/mock_ice_transport.h
@@ -57,6 +57,7 @@ class MockIceTransport : public IceTransportInternal {
   const std::string& transport_name() const override { return transport_name_; }
   int component() const override { return 0; }
   void SetIceRole(IceRole role) override {}
+  void SetIceTiebreaker(uint64_t tiebreaker) override {}
   // The ufrag and pwd in `ice_params` must be set
   // before candidate gathering can start.
   void SetIceParameters(const IceParameters& ice_params) override {}
diff --git a/p2p/base/p2p_transport_channel.cc b/p2p/base/p2p_transport_channel.cc
index dcea5b0e47..241b423be8 100644
--- a/p2p/base/p2p_transport_channel.cc
+++ b/p2p/base/p2p_transport_channel.cc
@@ -162,6 +162,7 @@ P2PTransportChannel::P2PTransportChannel(
       error_(0),
       remote_ice_mode_(ICEMODE_FULL),
       ice_role_(ICEROLE_UNKNOWN),
+      ice_tiebreaker_(0),
       gathering_state_(kIceGatheringNew),
       weak_ping_interval_(GetWeakPingIntervalInFieldTrial(field_trials)),
       config_(RECEIVING_TIMEOUT,
@@ -315,6 +316,17 @@ IceRole P2PTransportChannel::GetIceRole() const {
   return ice_role_;
 }
 
+void P2PTransportChannel::SetIceTiebreaker(uint64_t tiebreaker) {
+  RTC_DCHECK_RUN_ON(network_thread_);
+  if (!ports_.empty() || !pruned_ports_.empty()) {
+    RTC_LOG(LS_ERROR)
+        << "Attempt to change tiebreaker after Port has been allocated.";
+    return;
+  }
+
+  ice_tiebreaker_ = tiebreaker;
+}
+
 IceTransportState P2PTransportChannel::GetState() const {
   RTC_DCHECK_RUN_ON(network_thread_);
   return state_;
@@ -914,7 +926,7 @@ void P2PTransportChannel::OnPortReady(PortAllocatorSession* session,
   // if one is pending.
 
   port->SetIceRole(ice_role_);
-  port->SetIceTiebreaker(allocator_->ice_tiebreaker());
+  port->SetIceTiebreaker(ice_tiebreaker_);
   ports_.push_back(port);
   port->SignalUnknownAddress.connect(this,
                                      &P2PTransportChannel::OnUnknownAddress);
diff --git a/p2p/base/p2p_transport_channel.h b/p2p/base/p2p_transport_channel.h
index 2750af1332..f7472df38a 100644
--- a/p2p/base/p2p_transport_channel.h
+++ b/p2p/base/p2p_transport_channel.h
@@ -128,6 +128,7 @@ class RTC_EXPORT P2PTransportChannel : public IceTransportInternal,
   bool receiving() const override;
   void SetIceRole(IceRole role) override;
   IceRole GetIceRole() const override;
+  void SetIceTiebreaker(uint64_t tiebreaker) override;
   void SetIceParameters(const IceParameters& ice_params) override;
   void SetRemoteIceParameters(const IceParameters& ice_params) override;
   void SetRemoteIceMode(IceMode mode) override;
@@ -438,6 +439,7 @@ class RTC_EXPORT P2PTransportChannel : public IceTransportInternal,
       RTC_GUARDED_BY(network_thread_);
   IceMode remote_ice_mode_ RTC_GUARDED_BY(network_thread_);
   IceRole ice_role_ RTC_GUARDED_BY(network_thread_);
+  uint64_t ice_tiebreaker_ RTC_GUARDED_BY(network_thread_);
   IceGatheringState gathering_state_ RTC_GUARDED_BY(network_thread_);
   std::unique_ptr<webrtc::BasicRegatheringController> regathering_controller_
       RTC_GUARDED_BY(network_thread_);
diff --git a/p2p/base/p2p_transport_channel_unittest.cc b/p2p/base/p2p_transport_channel_unittest.cc
index 29bdd990f3..79ca2a5f26 100644
--- a/p2p/base/p2p_transport_channel_unittest.cc
+++ b/p2p/base/p2p_transport_channel_unittest.cc
@@ -134,6 +134,9 @@ const cricket::IceParameters kIceParams[4] = {
     {kIceUfrag[2], kIcePwd[2], false},
     {kIceUfrag[3], kIcePwd[3], false}};
 
+const uint64_t kLowTiebreaker = 11111;
+const uint64_t kHighTiebreaker = 22222;
+
 cricket::IceConfig CreateIceConfig(
     int receiving_timeout,
     cricket::ContinualGatheringPolicy continual_gathering_policy,
@@ -374,6 +377,8 @@ class P2PTransportChannelTestBase : public ::testing::Test,
 
     void SetIceRole(IceRole role) { role_ = role; }
     IceRole ice_role() { return role_; }
+    void SetIceTiebreaker(uint64_t tiebreaker) { tiebreaker_ = tiebreaker; }
+    uint64_t GetIceTiebreaker() { return tiebreaker_; }
     void OnRoleConflict(bool role_conflict) { role_conflict_ = role_conflict; }
     bool role_conflict() { return role_conflict_; }
     void SetAllocationStepDelay(uint32_t delay) {
@@ -482,6 +487,7 @@ class P2PTransportChannelTestBase : public ::testing::Test,
       channel->SetRemoteIceParameters(remote_ice);
     }
     channel->SetIceRole(GetEndpoint(endpoint)->ice_role());
+    channel->SetIceTiebreaker(GetEndpoint(endpoint)->GetIceTiebreaker());
     return channel;
   }
 
@@ -556,6 +562,9 @@ class P2PTransportChannelTestBase : public ::testing::Test,
   void SetIceRole(int endpoint, IceRole role) {
     GetEndpoint(endpoint)->SetIceRole(role);
   }
+  void SetIceTiebreaker(int endpoint, uint64_t tiebreaker) {
+    GetEndpoint(endpoint)->SetIceTiebreaker(tiebreaker);
+  }
   bool GetRoleConflict(int endpoint) {
     return GetEndpoint(endpoint)->role_conflict();
   }
@@ -769,6 +778,31 @@ class P2PTransportChannelTestBase : public ::testing::Test,
     EXPECT_EQ(1u, RemoteCandidate(ep1_ch1())->generation());
   }
 
+  void TestSignalRoleConflict() {
+    rtc::ScopedFakeClock clock;
+    // Default EP1 is in controlling state.
+    SetIceTiebreaker(0, kLowTiebreaker);
+
+    SetIceRole(1, ICEROLE_CONTROLLING);
+    SetIceTiebreaker(1, kHighTiebreaker);
+
+    // Creating channels with both channels role set to CONTROLLING.
+    CreateChannels();
+    // Since both the channels initiated with controlling state and channel2
+    // has higher tiebreaker value, channel1 should receive SignalRoleConflict.
+    EXPECT_TRUE_SIMULATED_WAIT(GetRoleConflict(0), kShortTimeout, clock);
+    EXPECT_FALSE(GetRoleConflict(1));
+
+    EXPECT_TRUE_SIMULATED_WAIT(CheckConnected(ep1_ch1(), ep2_ch1()),
+                               kShortTimeout, clock);
+
+    EXPECT_TRUE(ep1_ch1()->selected_connection() &&
+                ep2_ch1()->selected_connection());
+
+    TestSendRecv(&clock);
+    DestroyChannels();
+  }
+
   void TestPacketInfoIsSet(rtc::PacketInfo info) {
     EXPECT_NE(info.packet_type, rtc::PacketType::kUnknown);
     EXPECT_NE(info.protocol, rtc::PacketInfoProtocolType::kUnknown);
@@ -1805,36 +1839,13 @@ TEST_F(P2PTransportChannelTest, TestTcpConnectionTcptypeSet) {
 }
 
 TEST_F(P2PTransportChannelTest, TestIceRoleConflict) {
-  rtc::ScopedFakeClock clock;
   AddAddress(0, kPublicAddrs[0]);
   AddAddress(1, kPublicAddrs[1]);
-
-  // Creating channels with both channels role set to CONTROLLING.
-  SetIceRole(0, ICEROLE_CONTROLLING);
-  SetIceRole(1, ICEROLE_CONTROLLING);
-
-  CreateChannels();
-  bool first_endpoint_has_lower_tiebreaker =
-      GetEndpoint(0)->allocator_->ice_tiebreaker() <
-      GetEndpoint(1)->allocator_->ice_tiebreaker();
-  // Since both the channels initiated with controlling state, the channel with
-  // the lower tiebreaker should receive SignalRoleConflict.
-  EXPECT_TRUE_SIMULATED_WAIT(
-      GetRoleConflict(first_endpoint_has_lower_tiebreaker ? 0 : 1),
-      kShortTimeout, clock);
-  EXPECT_FALSE(GetRoleConflict(first_endpoint_has_lower_tiebreaker ? 1 : 0));
-
-  EXPECT_TRUE_SIMULATED_WAIT(CheckConnected(ep1_ch1(), ep2_ch1()),
-                             kShortTimeout, clock);
-
-  EXPECT_TRUE(ep1_ch1()->selected_connection() &&
-              ep2_ch1()->selected_connection());
-
-  TestSendRecv(&clock);
-  DestroyChannels();
+  TestSignalRoleConflict();
 }
 
-// Tests that the ice configs (protocol and role) can be passed down to ports.
+// Tests that the ice configs (protocol, tiebreaker and role) can be passed
+// down to ports.
 TEST_F(P2PTransportChannelTest, TestIceConfigWillPassDownToPort) {
   rtc::ScopedFakeClock clock;
   AddAddress(0, kPublicAddrs[0]);
@@ -1843,7 +1854,9 @@ TEST_F(P2PTransportChannelTest, TestIceConfigWillPassDownToPort) {
   // Give the first connection the higher tiebreaker so its role won't
   // change unless we tell it to.
   SetIceRole(0, ICEROLE_CONTROLLING);
+  SetIceTiebreaker(0, kHighTiebreaker);
   SetIceRole(1, ICEROLE_CONTROLLING);
+  SetIceTiebreaker(1, kLowTiebreaker);
 
   CreateChannels();
 
@@ -1852,13 +1865,18 @@ TEST_F(P2PTransportChannelTest, TestIceConfigWillPassDownToPort) {
   const std::vector<PortInterface*> ports_before = ep1_ch1()->ports();
   for (size_t i = 0; i < ports_before.size(); ++i) {
     EXPECT_EQ(ICEROLE_CONTROLLING, ports_before[i]->GetIceRole());
+    EXPECT_EQ(kHighTiebreaker, ports_before[i]->IceTiebreaker());
   }
 
   ep1_ch1()->SetIceRole(ICEROLE_CONTROLLED);
+  ep1_ch1()->SetIceTiebreaker(kLowTiebreaker);
 
   const std::vector<PortInterface*> ports_after = ep1_ch1()->ports();
   for (size_t i = 0; i < ports_after.size(); ++i) {
     EXPECT_EQ(ICEROLE_CONTROLLED, ports_before[i]->GetIceRole());
+    // SetIceTiebreaker after ports have been created will fail. So expect the
+    // original value.
+    EXPECT_EQ(kHighTiebreaker, ports_before[i]->IceTiebreaker());
   }
 
   EXPECT_TRUE_SIMULATED_WAIT(CheckConnected(ep1_ch1(), ep2_ch1()),
@@ -2244,7 +2262,9 @@ TEST_F(P2PTransportChannelTest,
   // With conflicting ICE roles, endpoint 1 has the higher tie breaker and will
   // send a binding error response.
   SetIceRole(0, ICEROLE_CONTROLLING);
+  SetIceTiebreaker(0, kHighTiebreaker);
   SetIceRole(1, ICEROLE_CONTROLLING);
+  SetIceTiebreaker(1, kLowTiebreaker);
   // We want the remote TURN candidate to show up as prflx. To do this we need
   // to configure the server to accept packets from an address we haven't
   // explicitly installed permission for.
diff --git a/pc/jsep_transport_controller.cc b/pc/jsep_transport_controller.cc
index 505ed5059e..7152826725 100644
--- a/pc/jsep_transport_controller.cc
+++ b/pc/jsep_transport_controller.cc
@@ -58,6 +58,7 @@ JsepTransportController::JsepTransportController(
           }),
       config_(std::move(config)),
       active_reset_srtp_params_(config.active_reset_srtp_params),
+      ice_tiebreaker_(port_allocator ? port_allocator->ice_tiebreaker() : 0),
       bundles_(config.bundle_policy) {
   // The `transport_observer` is assumed to be non-null.
   RTC_DCHECK(config_.transport_observer);
@@ -403,6 +404,7 @@ JsepTransportController::CreateIceTransport(const std::string& transport_name,
       transport_name, component, std::move(init));
   RTC_DCHECK(transport);
   transport->internal()->SetIceRole(ice_role_);
+  transport->internal()->SetIceTiebreaker(ice_tiebreaker_);
   transport->internal()->SetIceConfig(ice_config_);
   return transport;
 }
diff --git a/pc/jsep_transport_controller.h b/pc/jsep_transport_controller.h
index da0b921473..cf2b411f42 100644
--- a/pc/jsep_transport_controller.h
+++ b/pc/jsep_transport_controller.h
@@ -507,6 +507,7 @@ class JsepTransportController : public sigslot::has_slots<> {
 
   cricket::IceConfig ice_config_;
   cricket::IceRole ice_role_ = cricket::ICEROLE_CONTROLLING;
+  uint64_t ice_tiebreaker_;
   rtc::scoped_refptr<rtc::RTCCertificate> certificate_;
 
   BundleManager bundles_;
