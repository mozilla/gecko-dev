From: Dan Minor <dminor@mozilla.com>
Date: Tue, 31 Jul 2018 13:32:00 -0400
Subject: Bug 1376873 - OS X desktop capture fixes; r=pehrsons

Differential Revision: https://phabricator.services.mozilla.com/D7464
Mercurial Revision: https://hg.mozilla.org/mozilla-central/rev/02c038eca65c1218b56fdf8937fdeab3d8767fe6
---
 .../desktop_capture/mac/screen_capturer_mac.h |  14 +-
 .../mac/screen_capturer_mac.mm                | 150 +++++++++++-------
 .../mouse_cursor_monitor_mac.mm               |  46 +++---
 3 files changed, 127 insertions(+), 83 deletions(-)

diff --git a/modules/desktop_capture/mac/screen_capturer_mac.h b/modules/desktop_capture/mac/screen_capturer_mac.h
index 7e38b5bd08..7be05cc639 100644
--- a/modules/desktop_capture/mac/screen_capturer_mac.h
+++ b/modules/desktop_capture/mac/screen_capturer_mac.h
@@ -36,9 +36,10 @@ class DisplayStreamManager;
 // A class to perform video frame capturing for mac.
 class ScreenCapturerMac final : public DesktopCapturer {
  public:
-  ScreenCapturerMac(rtc::scoped_refptr<DesktopConfigurationMonitor> desktop_config_monitor,
-                    bool detect_updated_region,
-                    bool allow_iosurface);
+  ScreenCapturerMac(
+      rtc::scoped_refptr<DesktopConfigurationMonitor> desktop_config_monitor,
+      bool detect_updated_region,
+      bool allow_iosurface);
   ~ScreenCapturerMac() override;
 
   ScreenCapturerMac(const ScreenCapturerMac&) = delete;
@@ -113,6 +114,13 @@ class ScreenCapturerMac final : public DesktopCapturer {
 
   // Start, CaptureFrame and destructor have to called in the same thread.
   SequenceChecker thread_checker_;
+
+  // Used to force CaptureFrame to update it's screen configuration
+  // and reregister event handlers. This ensure that this
+  // occurs on the ScreenCapture thread. Read and written from
+  // both the VideoCapture thread and ScreenCapture thread.
+  // Protected by desktop_config_monitor_.
+  bool update_screen_configuration_ = false;
 };
 
 }  // namespace webrtc
diff --git a/modules/desktop_capture/mac/screen_capturer_mac.mm b/modules/desktop_capture/mac/screen_capturer_mac.mm
index d4e9c111db..21a9c1ca4a 100644
--- a/modules/desktop_capture/mac/screen_capturer_mac.mm
+++ b/modules/desktop_capture/mac/screen_capturer_mac.mm
@@ -26,10 +26,11 @@ namespace {
 
 // Scales all coordinates of a rect by a specified factor.
 DesktopRect ScaleAndRoundCGRect(const CGRect& rect, float scale) {
-  return DesktopRect::MakeLTRB(static_cast<int>(floor(rect.origin.x * scale)),
-                               static_cast<int>(floor(rect.origin.y * scale)),
-                               static_cast<int>(ceil((rect.origin.x + rect.size.width) * scale)),
-                               static_cast<int>(ceil((rect.origin.y + rect.size.height) * scale)));
+  return DesktopRect::MakeLTRB(
+      static_cast<int>(floor(rect.origin.x * scale)),
+      static_cast<int>(floor(rect.origin.y * scale)),
+      static_cast<int>(ceil((rect.origin.x + rect.size.width) * scale)),
+      static_cast<int>(ceil((rect.origin.y + rect.size.height) * scale)));
 }
 
 // Copy pixels in the `rect` from `src_place` to `dest_plane`. `rect` should be
@@ -63,8 +64,8 @@ void CopyRect(const uint8_t* src_plane,
 CFArrayRef CreateWindowListWithExclusion(CGWindowID window_to_exclude) {
   if (!window_to_exclude) return nullptr;
 
-  CFArrayRef all_windows =
-      CGWindowListCopyWindowInfo(kCGWindowListOptionOnScreenOnly, kCGNullWindowID);
+  CFArrayRef all_windows = CGWindowListCopyWindowInfo(
+      kCGWindowListOptionOnScreenOnly, kCGNullWindowID);
   if (!all_windows) return nullptr;
 
   CFMutableArrayRef returned_array =
@@ -72,8 +73,8 @@ CFArrayRef CreateWindowListWithExclusion(CGWindowID window_to_exclude) {
 
   bool found = false;
   for (CFIndex i = 0; i < CFArrayGetCount(all_windows); ++i) {
-    CFDictionaryRef window =
-        reinterpret_cast<CFDictionaryRef>(CFArrayGetValueAtIndex(all_windows, i));
+    CFDictionaryRef window = reinterpret_cast<CFDictionaryRef>(
+        CFArrayGetValueAtIndex(all_windows, i));
 
     CGWindowID id = GetWindowId(window);
     if (id == window_to_exclude) {
@@ -93,7 +94,8 @@ CFArrayRef CreateWindowListWithExclusion(CGWindowID window_to_exclude) {
 
 // Returns the bounds of `window` in physical pixels, enlarged by a small amount
 // on four edges to take account of the border/shadow effects.
-DesktopRect GetExcludedWindowPixelBounds(CGWindowID window, float dip_to_pixel_scale) {
+DesktopRect GetExcludedWindowPixelBounds(CGWindowID window,
+                                         float dip_to_pixel_scale) {
   // The amount of pixels to add to the actual window bounds to take into
   // account of the border/shadow effects.
   static const int kBorderEffectSize = 20;
@@ -103,13 +105,14 @@ DesktopRect GetExcludedWindowPixelBounds(CGWindowID window, float dip_to_pixel_s
 
   CFArrayRef window_id_array =
       CFArrayCreate(nullptr, reinterpret_cast<const void**>(&ids), 1, nullptr);
-  CFArrayRef window_array = CGWindowListCreateDescriptionFromArray(window_id_array);
+  CFArrayRef window_array =
+      CGWindowListCreateDescriptionFromArray(window_id_array);
 
   if (CFArrayGetCount(window_array) > 0) {
-    CFDictionaryRef win =
-        reinterpret_cast<CFDictionaryRef>(CFArrayGetValueAtIndex(window_array, 0));
-    CFDictionaryRef bounds_ref =
-        reinterpret_cast<CFDictionaryRef>(CFDictionaryGetValue(win, kCGWindowBounds));
+    CFDictionaryRef win = reinterpret_cast<CFDictionaryRef>(
+        CFArrayGetValueAtIndex(window_array, 0));
+    CFDictionaryRef bounds_ref = reinterpret_cast<CFDictionaryRef>(
+        CFDictionaryGetValue(win, kCGWindowBounds));
     CGRectMakeWithDictionaryRepresentation(bounds_ref, &rect);
   }
 
@@ -127,9 +130,10 @@ DesktopRect GetExcludedWindowPixelBounds(CGWindowID window, float dip_to_pixel_s
 // Create an image of the given region using the given `window_list`.
 // `pixel_bounds` should be in the primary display's coordinate in physical
 // pixels.
-rtc::ScopedCFTypeRef<CGImageRef> CreateExcludedWindowRegionImage(const DesktopRect& pixel_bounds,
-                                                                 float dip_to_pixel_scale,
-                                                                 CFArrayRef window_list) {
+rtc::ScopedCFTypeRef<CGImageRef> CreateExcludedWindowRegionImage(
+    const DesktopRect& pixel_bounds,
+    float dip_to_pixel_scale,
+    CFArrayRef window_list) {
   CGRect window_bounds;
   // The origin is in DIP while the size is in physical pixels. That's what
   // CGWindowListCreateImageFromArray expects.
@@ -138,8 +142,8 @@ rtc::ScopedCFTypeRef<CGImageRef> CreateExcludedWindowRegionImage(const DesktopRe
   window_bounds.size.width = pixel_bounds.width();
   window_bounds.size.height = pixel_bounds.height();
 
-  return rtc::ScopedCFTypeRef<CGImageRef>(
-      CGWindowListCreateImageFromArray(window_bounds, window_list, kCGWindowImageDefault));
+  return rtc::ScopedCFTypeRef<CGImageRef>(CGWindowListCreateImageFromArray(
+      window_bounds, window_list, kCGWindowImageDefault));
 }
 
 }  // namespace
@@ -185,6 +189,7 @@ void ScreenCapturerMac::Start(Callback* callback) {
                        current_display_);
 
   callback_ = callback;
+  update_screen_configuration_ = false;
   // Start and operate CGDisplayStream handler all from capture thread.
   if (!RegisterRefreshAndMoveHandlers()) {
     RTC_LOG(LS_ERROR) << "Failed to register refresh and move handlers.";
@@ -204,8 +209,10 @@ void ScreenCapturerMac::CaptureFrame() {
     RTC_DLOG(LS_WARNING) << "Overwriting frame that is still shared.";
   }
 
-  MacDesktopConfiguration new_config = desktop_config_monitor_->desktop_configuration();
-  if (!desktop_config_.Equals(new_config)) {
+  MacDesktopConfiguration new_config =
+      desktop_config_monitor_->desktop_configuration();
+  if (update_screen_configuration_ || !desktop_config_.Equals(new_config)) {
+    update_screen_configuration_ = false;
     desktop_config_ = new_config;
     // If the display configuraiton has changed then refresh capturer data
     // structures. Occasionally, the refresh and move handlers are lost when
@@ -236,7 +243,8 @@ void ScreenCapturerMac::CaptureFrame() {
   // If the current buffer is from an older generation then allocate a new one.
   // Note that we can't reallocate other buffers at this point, since the caller
   // may still be reading from them.
-  if (!queue_.current_frame()) queue_.ReplaceCurrentFrame(SharedDesktopFrame::Wrap(CreateFrame()));
+  if (!queue_.current_frame())
+    queue_.ReplaceCurrentFrame(SharedDesktopFrame::Wrap(CreateFrame()));
 
   DesktopFrame* current_frame = queue_.current_frame();
 
@@ -248,15 +256,16 @@ void ScreenCapturerMac::CaptureFrame() {
   if (detect_updated_region_) {
     *new_frame->mutable_updated_region() = region;
   } else {
-    new_frame->mutable_updated_region()->AddRect(DesktopRect::MakeSize(new_frame->size()));
+    new_frame->mutable_updated_region()->AddRect(
+        DesktopRect::MakeSize(new_frame->size()));
   }
 
   if (current_display_) {
     const MacDisplayConfiguration* config =
         desktop_config_.FindDisplayConfigurationById(current_display_);
     if (config) {
-      new_frame->set_top_left(
-          config->bounds.top_left().subtract(desktop_config_.bounds.top_left()));
+      new_frame->set_top_left(config->bounds.top_left().subtract(
+          desktop_config_.bounds.top_left()));
     }
   }
 
@@ -287,7 +296,8 @@ bool ScreenCapturerMac::SelectSource(SourceId id) {
     current_display_ = 0;
   } else {
     const MacDisplayConfiguration* config =
-        desktop_config_.FindDisplayConfigurationById(static_cast<CGDirectDisplayID>(id));
+        desktop_config_.FindDisplayConfigurationById(
+            static_cast<CGDirectDisplayID>(id));
     if (!config) return false;
     current_display_ = config->id;
   }
@@ -296,11 +306,15 @@ bool ScreenCapturerMac::SelectSource(SourceId id) {
   return true;
 }
 
-bool ScreenCapturerMac::CgBlit(const DesktopFrame& frame, const DesktopRegion& region) {
-  // If not all screen region is dirty, copy the entire contents of the previous capture buffer,
-  // to capture over.
-  if (queue_.previous_frame() && !region.Equals(DesktopRegion(screen_pixel_bounds_))) {
-    memcpy(frame.data(), queue_.previous_frame()->data(), frame.stride() * frame.size().height());
+bool ScreenCapturerMac::CgBlit(const DesktopFrame& frame,
+                               const DesktopRegion& region) {
+  // If not all screen region is dirty, copy the entire contents of the previous
+  // capture buffer, to capture over.
+  if (queue_.previous_frame() &&
+      !region.Equals(DesktopRegion(screen_pixel_bounds_))) {
+    memcpy(frame.data(),
+           queue_.previous_frame()->data(),
+           frame.stride() * frame.size().height());
   }
 
   MacDisplayConfigurations displays_to_capture;
@@ -329,12 +343,15 @@ bool ScreenCapturerMac::CgBlit(const DesktopFrame& frame, const DesktopRegion& r
     // Capturing mixed-DPI on one surface is hard, so we only return displays
     // that match the "primary" display's DPI. The primary display is always
     // the first in the list.
-    if (i > 0 && display_config.dip_to_pixel_scale != displays_to_capture[0].dip_to_pixel_scale) {
+    if (i > 0 &&
+        display_config.dip_to_pixel_scale !=
+            displays_to_capture[0].dip_to_pixel_scale) {
       continue;
     }
     // Determine the display's position relative to the desktop, in pixels.
     DesktopRect display_bounds = display_config.pixel_bounds;
-    display_bounds.Translate(-screen_pixel_bounds_.left(), -screen_pixel_bounds_.top());
+    display_bounds.Translate(-screen_pixel_bounds_.left(),
+                             -screen_pixel_bounds_.top());
 
     // Determine which parts of the blit region, if any, lay within the monitor.
     DesktopRegion copy_region = region;
@@ -348,15 +365,17 @@ bool ScreenCapturerMac::CgBlit(const DesktopFrame& frame, const DesktopRegion& r
     rtc::ScopedCFTypeRef<CGImageRef> excluded_image;
     if (excluded_window_ && window_list) {
       // Get the region of the excluded window relative the primary display.
-      excluded_window_bounds =
-          GetExcludedWindowPixelBounds(excluded_window_, display_config.dip_to_pixel_scale);
+      excluded_window_bounds = GetExcludedWindowPixelBounds(
+          excluded_window_, display_config.dip_to_pixel_scale);
       excluded_window_bounds.IntersectWith(display_config.pixel_bounds);
 
       // Create the image under the excluded window first, because it's faster
       // than captuing the whole display.
       if (!excluded_window_bounds.is_empty()) {
-        excluded_image = CreateExcludedWindowRegionImage(
-            excluded_window_bounds, display_config.dip_to_pixel_scale, window_list);
+        excluded_image =
+            CreateExcludedWindowRegionImage(excluded_window_bounds,
+                                            display_config.dip_to_pixel_scale,
+                                            window_list);
       }
     }
 
@@ -370,8 +389,8 @@ bool ScreenCapturerMac::CgBlit(const DesktopFrame& frame, const DesktopRegion& r
     int src_bytes_per_row = frame_source->stride();
     RTC_DCHECK(display_base_address);
 
-    // `frame_source` size may be different from display_bounds in case the screen was
-    // resized recently.
+    // `frame_source` size may be different from display_bounds in case the
+    // screen was resized recently.
     copy_region.IntersectWith(frame_source->rect());
 
     // Copy the dirty region from the display buffer into our desktop buffer.
@@ -387,7 +406,8 @@ bool ScreenCapturerMac::CgBlit(const DesktopFrame& frame, const DesktopRegion& r
 
     if (excluded_image) {
       CGDataProviderRef provider = CGImageGetDataProvider(excluded_image.get());
-      rtc::ScopedCFTypeRef<CFDataRef> excluded_image_data(CGDataProviderCopyData(provider));
+      rtc::ScopedCFTypeRef<CFDataRef> excluded_image_data(
+          CGDataProviderCopyData(provider));
       RTC_DCHECK(excluded_image_data);
       display_base_address = CFDataGetBytePtr(excluded_image_data.get());
       src_bytes_per_row = CGImageGetBytesPerRow(excluded_image.get());
@@ -398,14 +418,18 @@ bool ScreenCapturerMac::CgBlit(const DesktopFrame& frame, const DesktopRegion& r
       window_bounds_relative_to_desktop.Translate(-screen_pixel_bounds_.left(),
                                                   -screen_pixel_bounds_.top());
 
-      DesktopRect rect_to_copy = DesktopRect::MakeSize(excluded_window_bounds.size());
-      rect_to_copy.IntersectWith(DesktopRect::MakeWH(CGImageGetWidth(excluded_image.get()),
-                                                     CGImageGetHeight(excluded_image.get())));
+      DesktopRect rect_to_copy =
+          DesktopRect::MakeSize(excluded_window_bounds.size());
+      rect_to_copy.IntersectWith(
+          DesktopRect::MakeWH(CGImageGetWidth(excluded_image.get()),
+                              CGImageGetHeight(excluded_image.get())));
 
-      if (CGImageGetBitsPerPixel(excluded_image.get()) / 8 == DesktopFrame::kBytesPerPixel) {
+      if (CGImageGetBitsPerPixel(excluded_image.get()) / 8 ==
+          DesktopFrame::kBytesPerPixel) {
         CopyRect(display_base_address,
                  src_bytes_per_row,
-                 frame.GetFrameDataAtPos(window_bounds_relative_to_desktop.top_left()),
+                 frame.GetFrameDataAtPos(
+                     window_bounds_relative_to_desktop.top_left()),
                  frame.stride(),
                  DesktopFrame::kBytesPerPixel,
                  rect_to_copy);
@@ -454,10 +478,11 @@ bool ScreenCapturerMac::RegisterRefreshAndMoveHandlers() {
     CGDirectDisplayID display_id = config.id;
     DesktopVector display_origin = config.pixel_bounds.top_left();
 
-    CGDisplayStreamFrameAvailableHandler handler = ^(CGDisplayStreamFrameStatus status,
-                                                     uint64_t /* display_time */,
-                                                     IOSurfaceRef frame_surface,
-                                                     CGDisplayStreamUpdateRef updateRef) {
+    CGDisplayStreamFrameAvailableHandler handler = ^(
+        CGDisplayStreamFrameStatus status,
+        uint64_t /* display_time */,
+        IOSurfaceRef frame_surface,
+        CGDisplayStreamUpdateRef updateRef) {
       RTC_DCHECK(thread_checker_.IsCurrent());
       if (status == kCGDisplayStreamFrameStatusStopped) return;
 
@@ -465,8 +490,8 @@ bool ScreenCapturerMac::RegisterRefreshAndMoveHandlers() {
       if (status != kCGDisplayStreamFrameStatusFrameComplete) return;
 
       size_t count = 0;
-      const CGRect* rects =
-          CGDisplayStreamUpdateGetRects(updateRef, kCGDisplayStreamUpdateDirtyRects, &count);
+      const CGRect* rects = CGDisplayStreamUpdateGetRects(
+          updateRef, kCGDisplayStreamUpdateDirtyRects, &count);
       if (count != 0) {
         // According to CGDisplayStream.h, it's safe to call
         // CGDisplayStreamStop() from within the callback.
@@ -482,14 +507,20 @@ bool ScreenCapturerMac::RegisterRefreshAndMoveHandlers() {
                            &kCFTypeDictionaryKeyCallBacks,
                            &kCFTypeDictionaryValueCallBacks));
 
-    CGDisplayStreamRef display_stream = CGDisplayStreamCreate(
-        display_id, pixel_width, pixel_height, 'BGRA', properties_dict.get(), handler);
+    CGDisplayStreamRef display_stream =
+        CGDisplayStreamCreate(display_id,
+                              pixel_width,
+                              pixel_height,
+                              'BGRA',
+                              properties_dict.get(),
+                              handler);
 
     if (display_stream) {
       CGError error = CGDisplayStreamStart(display_stream);
       if (error != kCGErrorSuccess) return false;
 
-      CFRunLoopSourceRef source = CGDisplayStreamGetRunLoopSource(display_stream);
+      CFRunLoopSourceRef source =
+          CGDisplayStreamGetRunLoopSource(display_stream);
       CFRunLoopAddSource(CFRunLoopGetCurrent(), source, kCFRunLoopCommonModes);
       display_streams_.push_back(display_stream);
     }
@@ -542,14 +573,17 @@ void ScreenCapturerMac::ScreenRefresh(CGDirectDisplayID display_id,
   // Always having the latest iosurface before invalidating a region.
   // See https://bugs.chromium.org/p/webrtc/issues/detail?id=8652 for details.
   desktop_frame_provider_.InvalidateIOSurface(
-      display_id, rtc::ScopedCFTypeRef<IOSurfaceRef>(io_surface, rtc::RetainPolicy::RETAIN));
+      display_id,
+      rtc::ScopedCFTypeRef<IOSurfaceRef>(io_surface,
+                                         rtc::RetainPolicy::RETAIN));
   helper_.InvalidateRegion(region);
 }
 
 std::unique_ptr<DesktopFrame> ScreenCapturerMac::CreateFrame() {
-  std::unique_ptr<DesktopFrame> frame(new BasicDesktopFrame(screen_pixel_bounds_.size()));
-  frame->set_dpi(
-      DesktopVector(kStandardDPI * dip_to_pixel_scale_, kStandardDPI * dip_to_pixel_scale_));
+  std::unique_ptr<DesktopFrame> frame(
+      new BasicDesktopFrame(screen_pixel_bounds_.size()));
+  frame->set_dpi(DesktopVector(kStandardDPI * dip_to_pixel_scale_,
+                               kStandardDPI * dip_to_pixel_scale_));
   return frame;
 }
 
diff --git a/modules/desktop_capture/mouse_cursor_monitor_mac.mm b/modules/desktop_capture/mouse_cursor_monitor_mac.mm
index 3db4332cd1..e86d9210cf 100644
--- a/modules/desktop_capture/mouse_cursor_monitor_mac.mm
+++ b/modules/desktop_capture/mouse_cursor_monitor_mac.mm
@@ -10,7 +10,6 @@
 
 #include "modules/desktop_capture/mouse_cursor_monitor.h"
 
-
 #include <memory>
 
 #include <ApplicationServices/ApplicationServices.h>
@@ -33,13 +32,14 @@ namespace {
 CGImageRef CreateScaledCGImage(CGImageRef image, int width, int height) {
   // Create context, keeping original image properties.
   CGColorSpaceRef colorspace = CGImageGetColorSpace(image);
-  CGContextRef context = CGBitmapContextCreate(nullptr,
-                                               width,
-                                               height,
-                                               CGImageGetBitsPerComponent(image),
-                                               width * DesktopFrame::kBytesPerPixel,
-                                               colorspace,
-                                               CGImageGetBitmapInfo(image));
+  CGContextRef context =
+      CGBitmapContextCreate(nullptr,
+                            width,
+                            height,
+                            CGImageGetBitsPerComponent(image),
+                            width * DesktopFrame::kBytesPerPixel,
+                            colorspace,
+                            CGImageGetBitmapInfo(image));
 
   if (!context) return nil;
 
@@ -66,7 +66,7 @@ class MouseCursorMonitorMac : public MouseCursorMonitor {
  private:
   static void DisplaysReconfiguredCallback(CGDirectDisplayID display,
                                            CGDisplayChangeSummaryFlags flags,
-                                           void *user_parameter);
+                                           void* user_parameter);
   void DisplaysReconfigured(CGDirectDisplayID display,
                             CGDisplayChangeSummaryFlags flags);
 
@@ -80,9 +80,10 @@ class MouseCursorMonitorMac : public MouseCursorMonitor {
   __strong NSImage* last_cursor_ = NULL;
 };
 
-MouseCursorMonitorMac::MouseCursorMonitorMac(const DesktopCaptureOptions& options,
-                                             CGWindowID window_id,
-                                             ScreenId screen_id)
+MouseCursorMonitorMac::MouseCursorMonitorMac(
+    const DesktopCaptureOptions& options,
+    CGWindowID window_id,
+    ScreenId screen_id)
     : configuration_monitor_(options.configuration_monitor()),
       window_id_(window_id),
       screen_id_(screen_id),
@@ -115,8 +116,7 @@ void MouseCursorMonitorMac::Capture() {
 
   CaptureImage(scale);
 
-  if (mode_ != SHAPE_AND_POSITION)
-    return;
+  if (mode_ != SHAPE_AND_POSITION) return;
 
   // Always report cursor position in DIP pixel.
   callback_->OnMouseCursorPosition(
@@ -133,7 +133,9 @@ void MouseCursorMonitorMac::CaptureImage(float scale) {
   NSSize nssize = [nsimage size];  // DIP size
 
   // No need to caputre cursor image if it's unchanged since last capture.
-  if ([[nsimage TIFFRepresentation] isEqual:[last_cursor_ TIFFRepresentation]]) return;
+  if (last_cursor_ &&
+      [[nsimage TIFFRepresentation] isEqual:[last_cursor_ TIFFRepresentation]])
+    return;
   last_cursor_ = nsimage;
 
   DesktopSize size(round(nssize.width * scale),
@@ -144,17 +146,18 @@ void MouseCursorMonitorMac::CaptureImage(float scale) {
                std::min(size.width(), static_cast<int>(nshotspot.x * scale))),
       std::max(0,
                std::min(size.height(), static_cast<int>(nshotspot.y * scale))));
-  CGImageRef cg_image =
-      [nsimage CGImageForProposedRect:NULL context:nil hints:nil];
-  if (!cg_image)
-    return;
+  CGImageRef cg_image = [nsimage CGImageForProposedRect:NULL
+                                                context:nil
+                                                  hints:nil];
+  if (!cg_image) return;
 
   // Before 10.12, OSX may report 1X cursor on Retina screen. (See
   // crbug.com/632995.) After 10.12, OSX may report 2X cursor on non-Retina
   // screen. (See crbug.com/671436.) So scaling the cursor if needed.
   CGImageRef scaled_cg_image = nil;
   if (CGImageGetWidth(cg_image) != static_cast<size_t>(size.width())) {
-    scaled_cg_image = CreateScaledCGImage(cg_image, size.width(), size.height());
+    scaled_cg_image =
+        CreateScaledCGImage(cg_image, size.width(), size.height());
     if (scaled_cg_image != nil) {
       cg_image = scaled_cg_image;
     }
@@ -199,8 +202,7 @@ MouseCursorMonitor* MouseCursorMonitor::CreateForWindow(
 }
 
 MouseCursorMonitor* MouseCursorMonitor::CreateForScreen(
-    const DesktopCaptureOptions& options,
-    ScreenId screen) {
+    const DesktopCaptureOptions& options, ScreenId screen) {
   return new MouseCursorMonitorMac(options, kCGNullWindowID, screen);
 }
 
