From: Andreas Pehrson <apehrson@mozilla.com>
Date: Tue, 27 Aug 2024 10:01:00 +0000
Subject: Bug 1914835 - With ScreenCaptureKit embed the mouse cursor directly.
 r=webrtc-reviewers,ng

The MouseCursorMonitor on macOS is rather expensive, as for every pulled frame
it compares all pixels of the cursors used for the current and last frames.
Getting to the pixels may also incur a conversion.

Note that this comparison happens even if the backend reports it had embedded
the cursor already, as the embedding only affects composing the monitored cursor
into a captured frame.

Differential Revision: https://phabricator.services.mozilla.com/D220092
Mercurial Revision: https://hg.mozilla.org/mozilla-central/rev/8ca7b371646d8aa40b2c3faf54570fcd1331a677
---
 .../desktop_capture/mac/screen_capturer_sck.h |   3 +
 .../mac/screen_capturer_sck.mm                | 182 +++++++++++-------
 2 files changed, 111 insertions(+), 74 deletions(-)

diff --git a/modules/desktop_capture/mac/screen_capturer_sck.h b/modules/desktop_capture/mac/screen_capturer_sck.h
index 2c5241d33e..105cbf0783 100644
--- a/modules/desktop_capture/mac/screen_capturer_sck.h
+++ b/modules/desktop_capture/mac/screen_capturer_sck.h
@@ -18,6 +18,9 @@
 
 namespace webrtc {
 
+// Returns true if the ScreenCaptureKit capturer is available.
+bool ScreenCapturerSckAvailable();
+
 // A DesktopCapturer implementation that uses ScreenCaptureKit.
 std::unique_ptr<DesktopCapturer> CreateScreenCapturerSck(
     const DesktopCaptureOptions& options);
diff --git a/modules/desktop_capture/mac/screen_capturer_sck.mm b/modules/desktop_capture/mac/screen_capturer_sck.mm
index 9e2d9047e6..707199cd9e 100644
--- a/modules/desktop_capture/mac/screen_capturer_sck.mm
+++ b/modules/desktop_capture/mac/screen_capturer_sck.mm
@@ -24,14 +24,16 @@
 
 using webrtc::DesktopFrameIOSurface;
 
+#define SCK_AVAILABLE @available(macOS 14.0, *)
+
 namespace webrtc {
 class ScreenCapturerSck;
 }  // namespace webrtc
 
-// The ScreenCaptureKit API was available in macOS 12.3, but full-screen capture was reported to be
-// broken before macOS 13 - see http://crbug.com/40234870.
-// Also, the `SCContentFilter` fields `contentRect` and `pointPixelScale` were introduced in
-// macOS 14.
+// The ScreenCaptureKit API was available in macOS 12.3, but full-screen capture
+// was reported to be broken before macOS 13 - see http://crbug.com/40234870.
+// Also, the `SCContentFilter` fields `contentRect` and `pointPixelScale` were
+// introduced in macOS 14.
 API_AVAILABLE(macos(14.0))
 @interface SckHelper : NSObject <SCStreamDelegate, SCStreamOutput>
 
@@ -39,16 +41,26 @@ API_AVAILABLE(macos(14.0))
 
 - (void)onShareableContentCreated:(SCShareableContent*)content;
 
-// Called just before the capturer is destroyed. This avoids a dangling pointer, and prevents any
-// new calls into a deleted capturer. If any method-call on the capturer is currently running on a
-// different thread, this blocks until it completes.
+// Called just before the capturer is destroyed. This avoids a dangling pointer,
+// and prevents any new calls into a deleted capturer. If any method-call on the
+// capturer is currently running on a different thread, this blocks until it
+// completes.
 - (void)releaseCapturer;
 
 @end
 
 namespace webrtc {
 
-class API_AVAILABLE(macos(14.0)) ScreenCapturerSck final : public DesktopCapturer {
+bool ScreenCapturerSckAvailable() {
+  bool sonomaOrHigher = false;
+  if (SCK_AVAILABLE) {
+    sonomaOrHigher = true;
+  }
+  return sonomaOrHigher;
+}
+
+class API_AVAILABLE(macos(14.0)) ScreenCapturerSck final
+    : public DesktopCapturer {
  public:
   explicit ScreenCapturerSck(const DesktopCaptureOptions& options);
 
@@ -63,35 +75,38 @@ class API_AVAILABLE(macos(14.0)) ScreenCapturerSck final : public DesktopCapture
   void CaptureFrame() override;
   bool SelectSource(SourceId id) override;
 
-  // Called by SckHelper when shareable content is returned by ScreenCaptureKit. `content` will be
-  // nil if an error occurred. May run on an arbitrary thread.
+  // Called by SckHelper when shareable content is returned by ScreenCaptureKit.
+  // `content` will be nil if an error occurred. May run on an arbitrary thread.
   void OnShareableContentCreated(SCShareableContent* content);
 
-  // Called by SckHelper to notify of a newly captured frame. May run on an arbitrary thread.
+  // Called by SckHelper to notify of a newly captured frame. May run on an
+  // arbitrary thread.
   void OnNewIOSurface(IOSurfaceRef io_surface, CFDictionaryRef attachment);
 
  private:
-  // Called when starting the capturer or the configuration has changed (either from a
-  // SelectSource() call, or the screen-resolution has changed). This tells SCK to fetch new
-  // shareable content, and the completion-handler will either start a new stream, or reconfigure
-  // the existing stream. Runs on the caller's thread.
+  // Called when starting the capturer or the configuration has changed (either
+  // from a SelectSource() call, or the screen-resolution has changed). This
+  // tells SCK to fetch new shareable content, and the completion-handler will
+  // either start a new stream, or reconfigure the existing stream. Runs on the
+  // caller's thread.
   void StartOrReconfigureCapturer();
 
-  // Helper object to receive Objective-C callbacks from ScreenCaptureKit and call into this C++
-  // object. The helper may outlive this C++ instance, if a completion-handler is passed to
-  // ScreenCaptureKit APIs and the C++ object is deleted before the handler executes.
+  // Helper object to receive Objective-C callbacks from ScreenCaptureKit and
+  // call into this C++ object. The helper may outlive this C++ instance, if a
+  // completion-handler is passed to ScreenCaptureKit APIs and the C++ object is
+  // deleted before the handler executes.
   SckHelper* __strong helper_;
 
-  // Callback for returning captured frames, or errors, to the caller. Only used on the caller's
-  // thread.
+  // Callback for returning captured frames, or errors, to the caller. Only used
+  // on the caller's thread.
   Callback* callback_ = nullptr;
 
-  // Options passed to the constructor. May be accessed on any thread, but the options are
-  // unchanged during the capturer's lifetime.
+  // Options passed to the constructor. May be accessed on any thread, but the
+  // options are unchanged during the capturer's lifetime.
   DesktopCaptureOptions capture_options_;
 
-  // Signals that a permanent error occurred. This may be set on any thread, and is read by
-  // CaptureFrame() which runs on the caller's thread.
+  // Signals that a permanent error occurred. This may be set on any thread, and
+  // is read by CaptureFrame() which runs on the caller's thread.
   std::atomic<bool> permanent_error_ = false;
 
   // Guards some variables that may be accessed on different threads.
@@ -100,25 +115,28 @@ class API_AVAILABLE(macos(14.0)) ScreenCapturerSck final : public DesktopCapture
   // Provides captured desktop frames.
   SCStream* __strong stream_ RTC_GUARDED_BY(lock_);
 
-  // Currently selected display, or 0 if the full desktop is selected. This capturer does not
-  // support full-desktop capture, and will fall back to the first display.
+  // Currently selected display, or 0 if the full desktop is selected. This
+  // capturer does not support full-desktop capture, and will fall back to the
+  // first display.
   CGDirectDisplayID current_display_ RTC_GUARDED_BY(lock_) = 0;
 
-  // Used by CaptureFrame() to detect if the screen configuration has changed. Only used on the
-  // caller's thread.
+  // Used by CaptureFrame() to detect if the screen configuration has changed.
+  // Only used on the caller's thread.
   MacDesktopConfiguration desktop_config_;
 
   Mutex latest_frame_lock_;
-  std::unique_ptr<SharedDesktopFrame> latest_frame_ RTC_GUARDED_BY(latest_frame_lock_);
+  std::unique_ptr<SharedDesktopFrame> latest_frame_
+      RTC_GUARDED_BY(latest_frame_lock_);
 
   int32_t latest_frame_dpi_ RTC_GUARDED_BY(latest_frame_lock_) = kStandardDPI;
 
-  // Tracks whether the latest frame contains new data since it was returned to the caller. This is
-  // used to set the DesktopFrame's `updated_region` property. The flag is cleared after the frame
-  // is sent to OnCaptureResult(), and is set when SCK reports a new frame with non-empty "dirty"
-  // rectangles.
-  // TODO: crbug.com/327458809 - Replace this flag with ScreenCapturerHelper to more accurately
-  // track the dirty rectangles from the SCStreamFrameInfoDirtyRects attachment.
+  // Tracks whether the latest frame contains new data since it was returned to
+  // the caller. This is used to set the DesktopFrame's `updated_region`
+  // property. The flag is cleared after the frame is sent to OnCaptureResult(),
+  // and is set when SCK reports a new frame with non-empty "dirty" rectangles.
+  // TODO: crbug.com/327458809 - Replace this flag with ScreenCapturerHelper to
+  // more accurately track the dirty rectangles from the
+  // SCStreamFrameInfoDirtyRects attachment.
   bool frame_is_dirty_ RTC_GUARDED_BY(latest_frame_lock_) = true;
 };
 
@@ -134,7 +152,8 @@ ScreenCapturerSck::~ScreenCapturerSck() {
 
 void ScreenCapturerSck::Start(DesktopCapturer::Callback* callback) {
   callback_ = callback;
-  desktop_config_ = capture_options_.configuration_monitor()->desktop_configuration();
+  desktop_config_ =
+      capture_options_.configuration_monitor()->desktop_configuration();
   StartOrReconfigureCapturer();
 }
 
@@ -164,7 +183,8 @@ void ScreenCapturerSck::CaptureFrame() {
       frame = latest_frame_->Share();
       frame->set_dpi(DesktopVector(latest_frame_dpi_, latest_frame_dpi_));
       if (frame_is_dirty_) {
-        frame->mutable_updated_region()->AddRect(DesktopRect::MakeSize(frame->size()));
+        frame->mutable_updated_region()->AddRect(
+            DesktopRect::MakeSize(frame->size()));
         frame_is_dirty_ = false;
       }
     }
@@ -189,7 +209,8 @@ bool ScreenCapturerSck::SelectSource(SourceId id) {
     }
   }
 
-  // If the capturer was already started, reconfigure it. Otherwise, wait until Start() gets called.
+  // If the capturer was already started, reconfigure it. Otherwise, wait until
+  // Start() gets called.
   if (stream_started) {
     StartOrReconfigureCapturer();
   }
@@ -220,9 +241,10 @@ void ScreenCapturerSck::OnShareableContentCreated(SCShareableContent* content) {
       }
     }
     if (!captured_display) {
-      if (current_display_ == static_cast<CGDirectDisplayID>(kFullDesktopScreenId)) {
-        RTC_LOG(LS_WARNING)
-            << "Full screen capture is not supported, falling back to first display.";
+      if (current_display_ ==
+          static_cast<CGDirectDisplayID>(kFullDesktopScreenId)) {
+        RTC_LOG(LS_WARNING) << "Full screen capture is not supported, falling "
+                               "back to first display.";
       } else {
         RTC_LOG(LS_WARNING) << "Display " << current_display_
                             << " not found, falling back to first display.";
@@ -231,8 +253,9 @@ void ScreenCapturerSck::OnShareableContentCreated(SCShareableContent* content) {
     }
   }
 
-  SCContentFilter* filter = [[SCContentFilter alloc] initWithDisplay:captured_display
-                                                    excludingWindows:@[]];
+  SCContentFilter* filter =
+      [[SCContentFilter alloc] initWithDisplay:captured_display
+                              excludingWindows:@[]];
   SCStreamConfiguration* config = [[SCStreamConfiguration alloc] init];
   config.pixelFormat = kCVPixelFormatType_32BGRA;
   config.showsCursor = capture_options_.prefer_cursor_embedded();
@@ -252,14 +275,18 @@ void ScreenCapturerSck::OnShareableContentCreated(SCShareableContent* content) {
     [stream_ updateContentFilter:filter completionHandler:nil];
     [stream_ updateConfiguration:config completionHandler:nil];
   } else {
-    stream_ = [[SCStream alloc] initWithFilter:filter configuration:config delegate:helper_];
+    stream_ = [[SCStream alloc] initWithFilter:filter
+                                 configuration:config
+                                      delegate:helper_];
 
-    // TODO: crbug.com/327458809 - Choose an appropriate sampleHandlerQueue for best performance.
+    // TODO: crbug.com/327458809 - Choose an appropriate sampleHandlerQueue for
+    // best performance.
     NSError* add_stream_output_error;
-    bool add_stream_output_result = [stream_ addStreamOutput:helper_
-                                                        type:SCStreamOutputTypeScreen
-                                          sampleHandlerQueue:nil
-                                                       error:&add_stream_output_error];
+    bool add_stream_output_result =
+        [stream_ addStreamOutput:helper_
+                            type:SCStreamOutputTypeScreen
+              sampleHandlerQueue:nil
+                           error:&add_stream_output_error];
     if (!add_stream_output_result) {
       stream_ = nil;
       RTC_LOG(LS_ERROR) << "addStreamOutput failed.";
@@ -269,8 +296,9 @@ void ScreenCapturerSck::OnShareableContentCreated(SCShareableContent* content) {
 
     auto handler = ^(NSError* error) {
       if (error) {
-        // It should be safe to access `this` here, because the C++ destructor calls
-        // stopCaptureWithCompletionHandler on the stream, which cancels this handler.
+        // It should be safe to access `this` here, because the C++ destructor
+        // calls stopCaptureWithCompletionHandler on the stream, which cancels
+        // this handler.
         permanent_error_ = true;
         RTC_LOG(LS_ERROR) << "startCaptureWithCompletionHandler failed.";
       } else {
@@ -282,8 +310,10 @@ void ScreenCapturerSck::OnShareableContentCreated(SCShareableContent* content) {
   }
 }
 
-void ScreenCapturerSck::OnNewIOSurface(IOSurfaceRef io_surface, CFDictionaryRef attachment) {
-  rtc::ScopedCFTypeRef<IOSurfaceRef> scoped_io_surface(io_surface, rtc::RetainPolicy::RETAIN);
+void ScreenCapturerSck::OnNewIOSurface(IOSurfaceRef io_surface,
+                                       CFDictionaryRef attachment) {
+  rtc::ScopedCFTypeRef<IOSurfaceRef> scoped_io_surface(
+      io_surface, rtc::RetainPolicy::RETAIN);
   std::unique_ptr<DesktopFrameIOSurface> desktop_frame_io_surface =
       DesktopFrameIOSurface::Wrap(scoped_io_surface);
   if (!desktop_frame_io_surface) {
@@ -297,18 +327,19 @@ void ScreenCapturerSck::OnNewIOSurface(IOSurfaceRef io_surface, CFDictionaryRef
   bool dirty;
   {
     MutexLock lock(&latest_frame_lock_);
-    // Mark the frame as dirty if it has a different size, and ignore any DirtyRects attachment in
-    // this case. This is because SCK does not apply a correct attachment to the frame in the case
-    // where the stream was reconfigured.
+    // Mark the frame as dirty if it has a different size, and ignore any
+    // DirtyRects attachment in this case. This is because SCK does not apply a
+    // correct attachment to the frame in the case where the stream was
+    // reconfigured.
     dirty = !latest_frame_ || !latest_frame_->size().equals(frame->size());
   }
 
   if (!dirty) {
-    const void* dirty_rects_ptr =
-        CFDictionaryGetValue(attachment, (__bridge CFStringRef)SCStreamFrameInfoDirtyRects);
+    const void* dirty_rects_ptr = CFDictionaryGetValue(
+        attachment, (__bridge CFStringRef)SCStreamFrameInfoDirtyRects);
     if (!dirty_rects_ptr) {
-      // This is never expected to happen - SCK attaches a non-empty dirty-rects list to every
-      // frame, even when nothing has changed.
+      // This is never expected to happen - SCK attaches a non-empty dirty-rects
+      // list to every frame, even when nothing has changed.
       return;
     }
     if (CFGetTypeID(dirty_rects_ptr) != CFArrayGetTypeID()) {
@@ -320,12 +351,13 @@ void ScreenCapturerSck::OnNewIOSurface(IOSurfaceRef io_surface, CFDictionaryRef
     for (int i = 0; i < size; i++) {
       const void* rect_ptr = CFArrayGetValueAtIndex(dirty_rects_array, i);
       if (CFGetTypeID(rect_ptr) != CFDictionaryGetTypeID()) {
-        // This is never expected to happen - the dirty-rects attachment should always be an array
-        // of dictionaries.
+        // This is never expected to happen - the dirty-rects attachment should
+        // always be an array of dictionaries.
         return;
       }
       CGRect rect{};
-      CGRectMakeWithDictionaryRepresentation(static_cast<CFDictionaryRef>(rect_ptr), &rect);
+      CGRectMakeWithDictionaryRepresentation(
+          static_cast<CFDictionaryRef>(rect_ptr), &rect);
       if (!CGRectIsEmpty(rect)) {
         dirty = true;
         break;
@@ -341,9 +373,9 @@ void ScreenCapturerSck::OnNewIOSurface(IOSurfaceRef io_surface, CFDictionaryRef
 }
 
 void ScreenCapturerSck::StartOrReconfigureCapturer() {
-  // The copy is needed to avoid capturing `this` in the Objective-C block. Accessing `helper_`
-  // inside the block is equivalent to `this->helper_` and would crash (UAF) if `this` is
-  // deleted before the block is executed.
+  // The copy is needed to avoid capturing `this` in the Objective-C block.
+  // Accessing `helper_` inside the block is equivalent to `this->helper_` and
+  // would crash (UAF) if `this` is deleted before the block is executed.
   SckHelper* local_helper = helper_;
   auto handler = ^(SCShareableContent* content, NSError* /* error */) {
     [local_helper onShareableContentCreated:content];
@@ -352,19 +384,19 @@ void ScreenCapturerSck::StartOrReconfigureCapturer() {
   [SCShareableContent getShareableContentWithCompletionHandler:handler];
 }
 
-std::unique_ptr<DesktopCapturer> CreateScreenCapturerSck(const DesktopCaptureOptions& options) {
-  if (@available(macOS 14.0, *)) {
+std::unique_ptr<DesktopCapturer> CreateScreenCapturerSck(
+    const DesktopCaptureOptions& options) {
+  if (SCK_AVAILABLE) {
     return std::make_unique<ScreenCapturerSck>(options);
-  } else {
-    return nullptr;
   }
+  return nullptr;
 }
 
 }  // namespace webrtc
 
 @implementation SckHelper {
-  // This lock is to prevent the capturer being destroyed while an instance method is still running
-  // on another thread.
+  // This lock is to prevent the capturer being destroyed while an instance
+  // method is still running on another thread.
   webrtc::Mutex _capturer_lock;
   webrtc::ScreenCapturerSck* _capturer;
 }
@@ -397,8 +429,8 @@ std::unique_ptr<DesktopCapturer> CreateScreenCapturerSck(const DesktopCaptureOpt
     return;
   }
 
-  CFArrayRef attachmentsArray =
-      CMSampleBufferGetSampleAttachmentsArray(sampleBuffer, /*createIfNecessary=*/false);
+  CFArrayRef attachmentsArray = CMSampleBufferGetSampleAttachmentsArray(
+      sampleBuffer, /*createIfNecessary=*/false);
   if (!attachmentsArray || CFArrayGetCount(attachmentsArray) <= 0) {
     RTC_LOG(LS_ERROR) << "Discarding frame with no attachments.";
     return;
@@ -419,3 +451,5 @@ std::unique_ptr<DesktopCapturer> CreateScreenCapturerSck(const DesktopCaptureOpt
 }
 
 @end
+
+#undef SCK_AVAILABLE
