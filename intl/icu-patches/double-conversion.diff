diff --git a/intl/icu/source/i18n/measunit_extra.cpp b/intl/icu/source/i18n/measunit_extra.cpp
--- a/intl/icu/source/i18n/measunit_extra.cpp
+++ b/intl/icu/source/i18n/measunit_extra.cpp
@@ -10,17 +10,21 @@
 
 // Allow implicit conversion from char16_t* to UnicodeString for this file:
 // Helpful in toString methods and elsewhere.
 #define UNISTR_FROM_STRING_EXPLICIT
 
 #include "charstr.h"
 #include "cmemory.h"
 #include "cstring.h"
+#ifdef JS_HAS_INTL_API
+#include "double-conversion/string-to-double.h"
+#else
 #include "double-conversion-string-to-double.h"
+#endif
 #include "measunit_impl.h"
 #include "resource.h"
 #include "uarrsort.h"
 #include "uassert.h"
 #include "ucln_in.h"
 #include "umutex.h"
 #include "unicode/bytestrie.h"
 #include "unicode/bytestriebuilder.h"
@@ -33,17 +37,21 @@
 #include "util.h"
 #include <limits.h>
 #include <cstdlib>
 U_NAMESPACE_BEGIN
 
 
 namespace {
 
+#ifdef JS_HAS_INTL_API
+using double_conversion::StringToDoubleConverter;
+#else
 using icu::double_conversion::StringToDoubleConverter;
+#endif
 
 // TODO: Propose a new error code for this?
 constexpr UErrorCode kUnitIdentifierSyntaxError = U_ILLEGAL_ARGUMENT_ERROR;
 
 // Trie value offset for SI or binary prefixes. This is big enough to ensure we only
 // insert positive integers into the trie.
 constexpr int32_t kPrefixOffset = 64;
 static_assert(kPrefixOffset + UMEASURE_PREFIX_INTERNAL_MIN_BIN > 0,
diff --git a/intl/icu/source/i18n/number_decimalquantity.cpp b/intl/icu/source/i18n/number_decimalquantity.cpp
--- a/intl/icu/source/i18n/number_decimalquantity.cpp
+++ b/intl/icu/source/i18n/number_decimalquantity.cpp
@@ -11,28 +11,37 @@
 #include <stdlib.h>
 
 #include "unicode/plurrule.h"
 #include "cmemory.h"
 #include "number_decnum.h"
 #include "putilimp.h"
 #include "number_decimalquantity.h"
 #include "number_roundingutils.h"
+#ifdef JS_HAS_INTL_API
+#include "double-conversion/double-conversion.h"
+#else
 #include "double-conversion.h"
+#endif
 #include "charstr.h"
 #include "number_utils.h"
 #include "uassert.h"
 #include "util.h"
 
 using namespace icu;
 using namespace icu::number;
 using namespace icu::number::impl;
 
+#ifdef JS_HAS_INTL_API
+using double_conversion::DoubleToStringConverter;
+using double_conversion::StringToDoubleConverter;
+#else
 using icu::double_conversion::DoubleToStringConverter;
 using icu::double_conversion::StringToDoubleConverter;
+#endif
 
 namespace {
 
 int8_t NEGATIVE_FLAG = 1;
 int8_t INFINITY_FLAG = 2;
 int8_t NAN_FLAG = 4;
 
 /** Helper function for safe subtraction (no overflow). */
diff --git a/intl/icu/source/i18n/number_rounding.cpp b/intl/icu/source/i18n/number_rounding.cpp
--- a/intl/icu/source/i18n/number_rounding.cpp
+++ b/intl/icu/source/i18n/number_rounding.cpp
@@ -5,17 +5,21 @@
 
 #if !UCONFIG_NO_FORMATTING
 
 #include "charstr.h"
 #include "uassert.h"
 #include "unicode/numberformatter.h"
 #include "number_types.h"
 #include "number_decimalquantity.h"
+#ifdef JS_HAS_INTL_API
+#include "double-conversion/double-conversion.h"
+#else
 #include "double-conversion.h"
+#endif
 #include "number_roundingutils.h"
 #include "number_skeletons.h"
 #include "number_decnum.h"
 #include "putilimp.h"
 #include "string_segment.h"
 
 using namespace icu;
 using namespace icu::number;
diff --git a/intl/icu/source/i18n/number_utils.cpp b/intl/icu/source/i18n/number_utils.cpp
--- a/intl/icu/source/i18n/number_utils.cpp
+++ b/intl/icu/source/i18n/number_utils.cpp
@@ -12,26 +12,34 @@
 #include <stdlib.h>
 #include <cmath>
 #include "number_decnum.h"
 #include "number_types.h"
 #include "number_utils.h"
 #include "charstr.h"
 #include "decContext.h"
 #include "decNumber.h"
+#ifdef JS_HAS_INTL_API
+#include "double-conversion/double-conversion.h"
+#else
 #include "double-conversion.h"
+#endif
 #include "fphdlimp.h"
 #include "uresimp.h"
 #include "ureslocs.h"
 
 using namespace icu;
 using namespace icu::number;
 using namespace icu::number::impl;
 
+#ifdef JS_HAS_INTL_API
+using double_conversion::DoubleToStringConverter;
+#else
 using icu::double_conversion::DoubleToStringConverter;
+#endif
 
 
 namespace {
 
 const char16_t*
 doGetPattern(UResourceBundle* res, const char* nsName, const char* patternKey, UErrorCode& publicStatus,
              UErrorCode& localStatus) {
     // Construct the path into the resource bundle
diff --git a/intl/icu/source/i18n/units_converter.cpp b/intl/icu/source/i18n/units_converter.cpp
--- a/intl/icu/source/i18n/units_converter.cpp
+++ b/intl/icu/source/i18n/units_converter.cpp
@@ -2,17 +2,21 @@
 // License & terms of use: http://www.unicode.org/copyright.html
 
 #include "unicode/utypes.h"
 
 #if !UCONFIG_NO_FORMATTING
 
 #include "charstr.h"
 #include "cmemory.h"
+#ifdef JS_HAS_INTL_API
+#include "double-conversion/string-to-double.h"
+#else
 #include "double-conversion-string-to-double.h"
+#endif
 #include "measunit_impl.h"
 #include "putilimp.h"
 #include "uassert.h"
 #include "unicode/errorcode.h"
 #include "unicode/localpointer.h"
 #include "unicode/stringpiece.h"
 #include "units_converter.h"
 #include <algorithm>
@@ -101,17 +105,21 @@ void U_I18N_API Factor::substituteConsta
         this->constantExponents[i] = 0;
     }
 }
 
 namespace {
 
 /* Helpers */
 
+#ifdef JS_HAS_INTL_API
+using double_conversion::StringToDoubleConverter;
+#else
 using icu::double_conversion::StringToDoubleConverter;
+#endif
 
 // TODO: Make this a shared-utility function.
 // Returns `double` from a scientific number(i.e. "1", "2.01" or "3.09E+4")
 double strToDouble(StringPiece strNum, UErrorCode &status) {
     // We are processing well-formed input, so we don't need any special options to
     // StringToDoubleConverter.
     StringToDoubleConverter converter(0, 0, 0, "", "");
     int32_t count;
