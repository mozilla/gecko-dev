// @generated
# [doc = " Implement `DataProvider<SegmenterBreakWordOverrideV1>` on the given struct using the data\n hardcoded in this file. This allows the struct to be used with\n `icu`'s `_unstable` constructors.\n\n Using this implementation will embed the following data in the binary's data segment:\n * 40B for the lookup data structure (2 data identifiers)\n * 556B[^1] for the actual data (1 unique structs)\n \n [^1]: these numbers can be smaller in practice due to linker deduplication"] # [doc (hidden)] # [macro_export] macro_rules ! __impl_segmenter_break_word_override_v1 { ($ provider : ty) => { # [clippy :: msrv = "1.82"] const _ : () = < $ provider > :: MUST_USE_MAKE_PROVIDER_MACRO ; # [clippy :: msrv = "1.82"] impl $ provider { const DATA_SEGMENTER_BREAK_WORD_OVERRIDE_V1 : icu_provider :: baked :: zerotrie :: Data < icu :: segmenter :: provider :: SegmenterBreakWordOverrideV1 > = { const TRIE : icu_provider :: baked :: zerotrie :: ZeroTrieSimpleAscii < & 'static [u8] > = icu_provider :: baked :: zerotrie :: ZeroTrieSimpleAscii { store : b"\xC2fs\x02i\x80v\x80" , } ; const VALUES : & 'static [< icu :: segmenter :: provider :: SegmenterBreakWordOverrideV1 as icu_provider :: baked :: zerotrie :: DynamicDataMarker > :: DataStruct] = & [icu :: segmenter :: provider :: RuleBreakDataOverride { property_table_override : icu :: collections :: codepointtrie :: CodePointTrie :: from_parts (icu :: collections :: codepointtrie :: CodePointTrieHeader { high_start : 65536u32 , shifted12_high_start : 16u16 , index3_null_offset : 1u16 , data_null_offset : 64u32 , null_value : 0u32 , trie_type : icu :: collections :: codepointtrie :: TrieType :: Small , } , unsafe { zerovec :: ZeroVec :: from_bytes_unchecked (b"\0\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0\x88\0\x90\0\x90\0\x91\0\0\0\x10\0 \x000\0@\0P\0`\0p\0@\0P\0`\0p\0@\0P\0`\0p\0@\0P\0`\0p\0@\0P\0`\0p\0@\0P\0`\0p\0@\0P\0`\0p\0@\0P\0`\0p\0@\0@\0@\0@\0@\x005\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\x000\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0D\0H\0H\0H\0H\0H\0H\0H\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0h\0") } , unsafe { zerovec :: ZeroVec :: from_bytes_unchecked (b"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0E\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0") } , 0u8) , } ,] ; unsafe { icu_provider :: baked :: zerotrie :: Data :: from_trie_and_values_unchecked (TRIE , VALUES) } } ; } # [clippy :: msrv = "1.82"] impl icu_provider :: DataProvider < icu :: segmenter :: provider :: SegmenterBreakWordOverrideV1 > for $ provider { fn load (& self , req : icu_provider :: DataRequest ,) -> Result < icu_provider :: DataResponse < icu :: segmenter :: provider :: SegmenterBreakWordOverrideV1 > , icu_provider :: DataError > { let mut metadata = icu_provider :: DataResponseMetadata :: default () ; let payload = if let Some (payload) = icu_provider :: baked :: DataStore :: get (& Self :: DATA_SEGMENTER_BREAK_WORD_OVERRIDE_V1 , req . id , req . metadata . attributes_prefix_match) { payload } else { const FALLBACKER : icu :: locale :: fallback :: LocaleFallbackerWithConfig < 'static > = icu :: locale :: fallback :: LocaleFallbacker :: new () . for_config (< icu :: segmenter :: provider :: SegmenterBreakWordOverrideV1 as icu_provider :: DataMarker > :: INFO . fallback_config) ; let mut fallback_iterator = FALLBACKER . fallback_for (req . id . locale . clone ()) ; loop { if let Some (payload) = icu_provider :: baked :: DataStore :: get (& Self :: DATA_SEGMENTER_BREAK_WORD_OVERRIDE_V1 , icu_provider :: DataIdentifierBorrowed :: for_marker_attributes_and_locale (req . id . marker_attributes , fallback_iterator . get ()) , req . metadata . attributes_prefix_match) { metadata . locale = Some (fallback_iterator . take ()) ; break payload ; } if fallback_iterator . get () . is_unknown () { return Err (icu_provider :: DataErrorKind :: IdentifierNotFound . with_req (< icu :: segmenter :: provider :: SegmenterBreakWordOverrideV1 as icu_provider :: DataMarker > :: INFO , req)) ; } fallback_iterator . step () ; } } ; Ok (icu_provider :: DataResponse { payload , metadata }) } } } ; ($ provider : ty , ITER) => { __impl_segmenter_break_word_override_v1 ! ($ provider) ; # [clippy :: msrv = "1.82"] impl icu_provider :: IterableDataProvider < icu :: segmenter :: provider :: SegmenterBreakWordOverrideV1 > for $ provider { fn iter_ids (& self) -> Result < std :: collections :: BTreeSet < icu_provider :: DataIdentifierCow < 'static >> , icu_provider :: DataError > { Ok (icu_provider :: baked :: DataStore :: iter (& Self :: DATA_SEGMENTER_BREAK_WORD_OVERRIDE_V1) . collect ()) } } } ; ($ provider : ty , DRY) => { } ; ($ provider : ty , DRY , ITER) => { __impl_segmenter_break_word_override_v1 ! ($ provider , ITER) ; } ; } # [doc (inline)] pub use __impl_segmenter_break_word_override_v1 as impl_segmenter_break_word_override_v1 ;