// @generated
# [doc = " Implement `DataProvider<SegmenterDictionaryExtendedV1>` on the given struct using the data\n hardcoded in this file. This allows the struct to be used with\n `icu`'s `_unstable` constructors.\n\n Using this implementation will embed the following data in the binary's data segment:\n * 79B for the lookup data structure (4 data identifiers)\n * 26B[^1] for the actual data (1 unique structs)\n \n [^1]: these numbers can be smaller in practice due to linker deduplication"] # [doc (hidden)] # [macro_export] macro_rules ! __impl_segmenter_dictionary_extended_v1 { ($ provider : ty) => { # [clippy :: msrv = "1.82"] const _ : () = < $ provider > :: MUST_USE_MAKE_PROVIDER_MACRO ; # [clippy :: msrv = "1.82"] impl $ provider { const DATA_SEGMENTER_DICTIONARY_EXTENDED_V1 : icu_provider :: baked :: zerotrie :: Data < icu :: segmenter :: provider :: SegmenterDictionaryExtendedV1 > = { const TRIE : icu_provider :: baked :: zerotrie :: ZeroTrieSimpleAscii < & 'static [u8] > = icu_provider :: baked :: zerotrie :: ZeroTrieSimpleAscii { store : b"und\x1E\xC4bklt\x0B\x14\x1Burmesedict\x80hmerdict\x80aodict\x80haidict\x80" , } ; const VALUES : & 'static [< icu :: segmenter :: provider :: SegmenterDictionaryExtendedV1 as icu_provider :: baked :: zerotrie :: DynamicDataMarker > :: DataStruct] = & [icu :: segmenter :: provider :: UCharDictionaryBreakData { trie_data : unsafe { zerovec :: ZeroVec :: from_bytes_unchecked (b"\0\0") } , } ,] ; unsafe { icu_provider :: baked :: zerotrie :: Data :: from_trie_and_values_unchecked (TRIE , VALUES) } } ; } # [clippy :: msrv = "1.82"] impl icu_provider :: DataProvider < icu :: segmenter :: provider :: SegmenterDictionaryExtendedV1 > for $ provider { fn load (& self , req : icu_provider :: DataRequest ,) -> Result < icu_provider :: DataResponse < icu :: segmenter :: provider :: SegmenterDictionaryExtendedV1 > , icu_provider :: DataError > { let metadata = icu_provider :: DataResponseMetadata :: default () ; let Some (payload) = icu_provider :: baked :: DataStore :: get (& Self :: DATA_SEGMENTER_DICTIONARY_EXTENDED_V1 , req . id , req . metadata . attributes_prefix_match) else { return Err (icu_provider :: DataErrorKind :: IdentifierNotFound . with_req (< icu :: segmenter :: provider :: SegmenterDictionaryExtendedV1 as icu_provider :: DataMarker > :: INFO , req)) } ; Ok (icu_provider :: DataResponse { payload , metadata }) } } } ; ($ provider : ty , ITER) => { __impl_segmenter_dictionary_extended_v1 ! ($ provider) ; # [clippy :: msrv = "1.82"] impl icu_provider :: IterableDataProvider < icu :: segmenter :: provider :: SegmenterDictionaryExtendedV1 > for $ provider { fn iter_ids (& self) -> Result < std :: collections :: BTreeSet < icu_provider :: DataIdentifierCow < 'static >> , icu_provider :: DataError > { Ok (icu_provider :: baked :: DataStore :: iter (& Self :: DATA_SEGMENTER_DICTIONARY_EXTENDED_V1) . collect ()) } } } ; ($ provider : ty , DRY) => { } ; ($ provider : ty , DRY , ITER) => { __impl_segmenter_dictionary_extended_v1 ! ($ provider , ITER) ; } ; } # [doc (inline)] pub use __impl_segmenter_dictionary_extended_v1 as impl_segmenter_dictionary_extended_v1 ;