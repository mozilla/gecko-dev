[readable-stream-reader.https.html]
  type: testharness
  disabled: @True
  [Can get the ReadableStreamReader constructor indirectly]
    expected: FAIL

  [ReadableStreamReader instances should have the correct list of properties]
    expected: FAIL

  [ReadableStreamReader closed should always return the same promise object]
    expected: FAIL

  [Constructing a ReadableStreamReader directly should fail if the stream is already locked (via direct construction)]
    expected: FAIL

  [Getting a ReadableStreamReader via getReader should fail if the stream is already locked (via direct construction)]
    expected: FAIL

  [Constructing a ReadableStreamReader directly should fail if the stream is already locked (via getReader)]
    expected: FAIL

  [Getting a ReadableStreamReader via getReader should fail if the stream is already locked (via getReader)]
    expected: FAIL

  [Constructing a ReadableStreamReader directly should be OK if the stream is closed]
    expected: FAIL

  [Constructing a ReadableStreamReader directly should be OK if the stream is errored]
    expected: FAIL

  [Reading from a reader for an empty stream will wait until a chunk is available]
    expected: FAIL

  [cancel() on a reader does not release the reader]
    expected: FAIL

  [closed should be fulfilled after stream is closed (.closed access before acquiring)]
    expected: FAIL

  [closed should be rejected after reader releases its lock (multiple stream locks)]
    expected: FAIL

  [Multiple readers can access the stream in sequence]
    expected: FAIL

  [Cannot use an already-released reader to unlock a stream again]
    expected: FAIL

  [cancel() on a released reader is a no-op and does not pass through]
    expected: FAIL

  [Getting a second reader after erroring the stream and releasing the reader should succeed]
    expected: FAIL

  [ReadableStreamReader closed promise should be rejected with undefined if that is the error]
    expected: FAIL

  [ReadableStreamReader: if start rejects with no parameter, it should error the stream with an undefined error]
    expected: FAIL

  [Erroring a ReadableStream after checking closed should reject ReadableStreamReader closed promise]
    expected: FAIL

  [Erroring a ReadableStream before checking closed should reject ReadableStreamReader closed promise]
    expected: FAIL

  [Reading twice on a stream that gets closed]
    expected: FAIL

  [Reading twice on a closed stream]
    expected: FAIL

  [Reading twice on an errored stream]
    expected: FAIL

  [Reading twice on a stream that gets errored]
    expected: FAIL

  [Can get the ReadableStreamReader constructor indirectly]
    expected: FAIL

  [ReadableStreamReader instances should have the correct list of properties]
    expected: FAIL

  [ReadableStreamReader closed should always return the same promise object]
    expected: FAIL

  [Constructing a ReadableStreamReader directly should fail if the stream is already locked (via direct construction)]
    expected: FAIL

  [Getting a ReadableStreamReader via getReader should fail if the stream is already locked (via direct construction)]
    expected: FAIL

  [Constructing a ReadableStreamReader directly should fail if the stream is already locked (via getReader)]
    expected: FAIL

  [Getting a ReadableStreamReader via getReader should fail if the stream is already locked (via getReader)]
    expected: FAIL

  [Constructing a ReadableStreamReader directly should be OK if the stream is closed]
    expected: FAIL

  [Constructing a ReadableStreamReader directly should be OK if the stream is errored]
    expected: FAIL

  [Reading from a reader for an empty stream will wait until a chunk is available]
    expected: FAIL

  [cancel() on a reader does not release the reader]
    expected: FAIL

  [closed should be fulfilled after stream is closed (.closed access before acquiring)]
    expected: FAIL

  [closed should be rejected after reader releases its lock (multiple stream locks)]
    expected: FAIL

  [Multiple readers can access the stream in sequence]
    expected: FAIL

  [Cannot use an already-released reader to unlock a stream again]
    expected: FAIL

  [cancel() on a released reader is a no-op and does not pass through]
    expected: FAIL

  [Getting a second reader after erroring the stream and releasing the reader should succeed]
    expected: FAIL

  [ReadableStreamReader closed promise should be rejected with undefined if that is the error]
    expected: FAIL

  [ReadableStreamReader: if start rejects with no parameter, it should error the stream with an undefined error]
    expected: FAIL

  [Erroring a ReadableStream after checking closed should reject ReadableStreamReader closed promise]
    expected: FAIL

  [Erroring a ReadableStream before checking closed should reject ReadableStreamReader closed promise]
    expected: FAIL

  [Reading twice on a stream that gets closed]
    expected: FAIL

  [Reading twice on a closed stream]
    expected: FAIL

  [Reading twice on an errored stream]
    expected: FAIL

  [Reading twice on a stream that gets errored]
    expected: FAIL

  [Can get the ReadableStreamReader constructor indirectly]
    expected: FAIL

  [ReadableStreamReader instances should have the correct list of properties]
    expected: FAIL

  [ReadableStreamReader closed should always return the same promise object]
    expected: FAIL

  [Constructing a ReadableStreamReader directly should fail if the stream is already locked (via direct construction)]
    expected: FAIL

  [Getting a ReadableStreamReader via getReader should fail if the stream is already locked (via direct construction)]
    expected: FAIL

  [Constructing a ReadableStreamReader directly should fail if the stream is already locked (via getReader)]
    expected: FAIL

  [Getting a ReadableStreamReader via getReader should fail if the stream is already locked (via getReader)]
    expected: FAIL

  [Constructing a ReadableStreamReader directly should be OK if the stream is closed]
    expected: FAIL

  [Constructing a ReadableStreamReader directly should be OK if the stream is errored]
    expected: FAIL

  [Reading from a reader for an empty stream will wait until a chunk is available]
    expected: FAIL

  [cancel() on a reader does not release the reader]
    expected: FAIL

  [closed should be fulfilled after stream is closed (.closed access before acquiring)]
    expected: FAIL

  [closed should be rejected after reader releases its lock (multiple stream locks)]
    expected: FAIL

  [Multiple readers can access the stream in sequence]
    expected: FAIL

  [Cannot use an already-released reader to unlock a stream again]
    expected: FAIL

  [cancel() on a released reader is a no-op and does not pass through]
    expected: FAIL

  [Getting a second reader after erroring the stream and releasing the reader should succeed]
    expected: FAIL

  [ReadableStreamReader closed promise should be rejected with undefined if that is the error]
    expected: FAIL

  [ReadableStreamReader: if start rejects with no parameter, it should error the stream with an undefined error]
    expected: FAIL

  [Erroring a ReadableStream after checking closed should reject ReadableStreamReader closed promise]
    expected: FAIL

  [Erroring a ReadableStream before checking closed should reject ReadableStreamReader closed promise]
    expected: FAIL

  [Reading twice on a stream that gets closed]
    expected: FAIL

  [Reading twice on a closed stream]
    expected: FAIL

  [Reading twice on an errored stream]
    expected: FAIL

  [Reading twice on a stream that gets errored]
    expected: FAIL

