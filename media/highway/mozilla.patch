diff --git a/third_party/highway/hwy/aligned_allocator.h b/third_party/highway/hwy/aligned_allocator.h
index 7584318a75792..1e846712f4c47 100644
--- a/third_party/highway/hwy/aligned_allocator.h
+++ b/third_party/highway/hwy/aligned_allocator.h
@@ -222,8 +222,8 @@ class Span {
   Span() = default;
   Span(T* data, size_t size) : size_(size), data_(data) {}
   template <typename U>
-  Span(U u) : Span(u.data(), u.size()) {}
-  Span(std::initializer_list<const T> v) : Span(v.begin(), v.size()) {}
+  MOZ_IMPLICIT Span(U u) : Span(u.data(), u.size()) {}
+  MOZ_IMPLICIT Span(std::initializer_list<const T> v) : Span(v.begin(), v.size()) {}
 
   // Copies the contents of the initializer list to the span.
   Span<T>& operator=(std::initializer_list<const T> v) {
diff --git a/third_party/highway/hwy/base.h b/third_party/highway/hwy/base.h
index c289db7262bcb..1b5feea668174 100644
--- a/third_party/highway/hwy/base.h
+++ b/third_party/highway/hwy/base.h
@@ -1102,7 +1102,7 @@ struct alignas(2) float16_t {
 #if HWY_HAVE_SCALAR_F16_TYPE
   // NEON vget/set_lane intrinsics and SVE `svaddv` could use explicit
   // float16_t(intrinsic()), but user code expects implicit conversions.
-  constexpr float16_t(Native arg) noexcept : native(arg) {}
+  MOZ_IMPLICIT constexpr float16_t(Native arg) noexcept : native(arg) {}
   constexpr operator Native() const noexcept { return native; }
 #endif
 
@@ -1129,7 +1129,7 @@ struct alignas(2) float16_t {
 #if HWY_HAVE_SCALAR_F16_OPERATORS || HWY_IDE
   template <typename T, hwy::EnableIf<!IsSame<RemoveCvRef<T>, float16_t>() &&
                                       IsConvertible<T, Native>()>* = nullptr>
-  constexpr float16_t(T&& arg) noexcept
+  MOZ_IMPLICIT constexpr float16_t(T&& arg) noexcept
       : native(static_cast<Native>(static_cast<T&&>(arg))) {}
 
   template <typename T, hwy::EnableIf<!IsSame<RemoveCvRef<T>, float16_t>() &&
@@ -1572,7 +1572,7 @@ struct alignas(2) bfloat16_t {
 
 // Only enable implicit conversions if we have a native type.
 #if HWY_HAVE_SCALAR_BF16_TYPE
-  constexpr bfloat16_t(Native arg) noexcept : native(arg) {}
+  MOZ_IMPLICIT constexpr bfloat16_t(Native arg) noexcept : native(arg) {}
   constexpr operator Native() const noexcept { return native; }
 #endif
 
